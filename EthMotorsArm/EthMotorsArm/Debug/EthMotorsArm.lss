
EthMotorsArm.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000c030  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000074  20000000  0000c030  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  00020074  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00020074  2**0
                  CONTENTS
  4 .bss          00009554  20000080  0000c0c0  00020080  2**5
                  ALLOC
  5 .stack        00010004  200095d4  00015614  00020080  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  00020074  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  000200a2  2**0
                  CONTENTS, READONLY
  8 .debug_info   0005a790  00000000  00000000  000200fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00008d42  00000000  00000000  0007a88b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0001fa14  00000000  00000000  000835cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00001670  00000000  00000000  000a2fe1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001e60  00000000  00000000  000a4651  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0003b71c  00000000  00000000  000a64b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00025e59  00000000  00000000  000e1bcd  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00112fa4  00000000  00000000  00107a26  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00004570  00000000  00000000  0021a9cc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	d8 95 01 20 f1 02 00 00 ed 02 00 00 ed 02 00 00     ... ............
      10:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
      2c:	ed 02 00 00 ed 02 00 00 00 00 00 00 ed 02 00 00     ................
      3c:	5d 90 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ]...............
      4c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      5c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      6c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      7c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      8c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      9c:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      ac:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      bc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      cc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
      dc:	ed 02 00 00 ed 02 00 00 ed 02 00 00 00 00 00 00     ................
	...
      f4:	25 1f 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     %...............
     104:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     114:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     124:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     134:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     144:	ed 02 00 00 d5 22 00 00 e9 22 00 00 fd 22 00 00     ....."..."..."..
     154:	11 23 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     .#..............
     164:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     174:	ed 02 00 00 00 00 00 00 00 00 00 00 ed 02 00 00     ................
     184:	ed 02 00 00 ed 02 00 00 ed 02 00 00 8d 19 00 00     ................
     194:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1a4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1b4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1c4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1d4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     1e4:	ed 02 00 00 ed 02 00 00 99 25 00 00 ed 02 00 00     .........%......
     1f4:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     204:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     214:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     224:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     234:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     244:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................
     254:	ed 02 00 00 ed 02 00 00 ed 02 00 00 ed 02 00 00     ................

00000264 <__do_global_dtors_aux>:
     264:	b510      	push	{r4, lr}
     266:	4c05      	ldr	r4, [pc, #20]	; (27c <__do_global_dtors_aux+0x18>)
     268:	7823      	ldrb	r3, [r4, #0]
     26a:	b933      	cbnz	r3, 27a <__do_global_dtors_aux+0x16>
     26c:	4b04      	ldr	r3, [pc, #16]	; (280 <__do_global_dtors_aux+0x1c>)
     26e:	b113      	cbz	r3, 276 <__do_global_dtors_aux+0x12>
     270:	4804      	ldr	r0, [pc, #16]	; (284 <__do_global_dtors_aux+0x20>)
     272:	f3af 8000 	nop.w
     276:	2301      	movs	r3, #1
     278:	7023      	strb	r3, [r4, #0]
     27a:	bd10      	pop	{r4, pc}
     27c:	20000080 	.word	0x20000080
     280:	00000000 	.word	0x00000000
     284:	0000c030 	.word	0x0000c030

00000288 <frame_dummy>:
     288:	4b0c      	ldr	r3, [pc, #48]	; (2bc <frame_dummy+0x34>)
     28a:	b143      	cbz	r3, 29e <frame_dummy+0x16>
     28c:	480c      	ldr	r0, [pc, #48]	; (2c0 <frame_dummy+0x38>)
     28e:	490d      	ldr	r1, [pc, #52]	; (2c4 <frame_dummy+0x3c>)
     290:	b510      	push	{r4, lr}
     292:	f3af 8000 	nop.w
     296:	480c      	ldr	r0, [pc, #48]	; (2c8 <frame_dummy+0x40>)
     298:	6803      	ldr	r3, [r0, #0]
     29a:	b923      	cbnz	r3, 2a6 <frame_dummy+0x1e>
     29c:	bd10      	pop	{r4, pc}
     29e:	480a      	ldr	r0, [pc, #40]	; (2c8 <frame_dummy+0x40>)
     2a0:	6803      	ldr	r3, [r0, #0]
     2a2:	b933      	cbnz	r3, 2b2 <frame_dummy+0x2a>
     2a4:	4770      	bx	lr
     2a6:	4b09      	ldr	r3, [pc, #36]	; (2cc <frame_dummy+0x44>)
     2a8:	2b00      	cmp	r3, #0
     2aa:	d0f7      	beq.n	29c <frame_dummy+0x14>
     2ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     2b0:	4718      	bx	r3
     2b2:	4b06      	ldr	r3, [pc, #24]	; (2cc <frame_dummy+0x44>)
     2b4:	2b00      	cmp	r3, #0
     2b6:	d0f5      	beq.n	2a4 <frame_dummy+0x1c>
     2b8:	4718      	bx	r3
     2ba:	bf00      	nop
     2bc:	00000000 	.word	0x00000000
     2c0:	0000c030 	.word	0x0000c030
     2c4:	20000084 	.word	0x20000084
     2c8:	0000c030 	.word	0x0000c030
     2cc:	00000000 	.word	0x00000000

000002d0 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     2d0:	b508      	push	{r3, lr}
	system_init();
     2d2:	4b03      	ldr	r3, [pc, #12]	; (2e0 <atmel_start_init+0x10>)
     2d4:	4798      	blx	r3
	ethernet_phys_init();
     2d6:	4b03      	ldr	r3, [pc, #12]	; (2e4 <atmel_start_init+0x14>)
     2d8:	4798      	blx	r3
	stdio_redirect_init();
     2da:	4b03      	ldr	r3, [pc, #12]	; (2e8 <atmel_start_init+0x18>)
     2dc:	4798      	blx	r3
     2de:	bd08      	pop	{r3, pc}
     2e0:	00000649 	.word	0x00000649
     2e4:	00000d01 	.word	0x00000d01
     2e8:	00009769 	.word	0x00009769

000002ec <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     2ec:	e7fe      	b.n	2ec <Dummy_Handler>
	...

000002f0 <Reset_Handler>:
{
     2f0:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
     2f2:	4b1c      	ldr	r3, [pc, #112]	; (364 <Reset_Handler+0x74>)
     2f4:	4a1c      	ldr	r2, [pc, #112]	; (368 <Reset_Handler+0x78>)
     2f6:	429a      	cmp	r2, r3
     2f8:	d010      	beq.n	31c <Reset_Handler+0x2c>
                for (; pDest < &_erelocate;) {
     2fa:	4b1c      	ldr	r3, [pc, #112]	; (36c <Reset_Handler+0x7c>)
     2fc:	4a19      	ldr	r2, [pc, #100]	; (364 <Reset_Handler+0x74>)
     2fe:	429a      	cmp	r2, r3
     300:	d20c      	bcs.n	31c <Reset_Handler+0x2c>
     302:	3b01      	subs	r3, #1
     304:	1a9b      	subs	r3, r3, r2
     306:	f023 0303 	bic.w	r3, r3, #3
     30a:	3304      	adds	r3, #4
     30c:	4413      	add	r3, r2
     30e:	4916      	ldr	r1, [pc, #88]	; (368 <Reset_Handler+0x78>)
                        *pDest++ = *pSrc++;
     310:	f851 0b04 	ldr.w	r0, [r1], #4
     314:	f842 0b04 	str.w	r0, [r2], #4
                for (; pDest < &_erelocate;) {
     318:	429a      	cmp	r2, r3
     31a:	d1f9      	bne.n	310 <Reset_Handler+0x20>
        for (pDest = &_szero; pDest < &_ezero;) {
     31c:	4b14      	ldr	r3, [pc, #80]	; (370 <Reset_Handler+0x80>)
     31e:	4a15      	ldr	r2, [pc, #84]	; (374 <Reset_Handler+0x84>)
     320:	429a      	cmp	r2, r3
     322:	d20a      	bcs.n	33a <Reset_Handler+0x4a>
     324:	3b01      	subs	r3, #1
     326:	1a9b      	subs	r3, r3, r2
     328:	f023 0303 	bic.w	r3, r3, #3
     32c:	3304      	adds	r3, #4
     32e:	4413      	add	r3, r2
                *pDest++ = 0;
     330:	2100      	movs	r1, #0
     332:	f842 1b04 	str.w	r1, [r2], #4
        for (pDest = &_szero; pDest < &_ezero;) {
     336:	4293      	cmp	r3, r2
     338:	d1fb      	bne.n	332 <Reset_Handler+0x42>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     33a:	4b0f      	ldr	r3, [pc, #60]	; (378 <Reset_Handler+0x88>)
     33c:	4a0f      	ldr	r2, [pc, #60]	; (37c <Reset_Handler+0x8c>)
     33e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
     342:	609a      	str	r2, [r3, #8]
        SCB->CPACR |=  (0xFu << 20);
     344:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
     348:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
     34c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     350:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     354:	f3bf 8f6f 	isb	sy
        __libc_init_array();
     358:	4b09      	ldr	r3, [pc, #36]	; (380 <Reset_Handler+0x90>)
     35a:	4798      	blx	r3
        main();
     35c:	4b09      	ldr	r3, [pc, #36]	; (384 <Reset_Handler+0x94>)
     35e:	4798      	blx	r3
     360:	e7fe      	b.n	360 <Reset_Handler+0x70>
     362:	bf00      	nop
     364:	20000000 	.word	0x20000000
     368:	0000c030 	.word	0x0000c030
     36c:	20000074 	.word	0x20000074
     370:	200095d4 	.word	0x200095d4
     374:	20000080 	.word	0x20000080
     378:	e000ed00 	.word	0xe000ed00
     37c:	00000000 	.word	0x00000000
     380:	00009789 	.word	0x00009789
     384:	0000942d 	.word	0x0000942d

00000388 <USART_0_PORT_init>:
static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     388:	4b10      	ldr	r3, [pc, #64]	; (3cc <USART_0_PORT_init+0x44>)
     38a:	f893 215b 	ldrb.w	r2, [r3, #347]	; 0x15b
	tmp &= ~PORT_PINCFG_PMUXEN;
     38e:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     392:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     396:	f883 215b 	strb.w	r2, [r3, #347]	; 0x15b
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     39a:	f893 213d 	ldrb.w	r2, [r3, #317]	; 0x13d
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     39e:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     3a2:	f042 0220 	orr.w	r2, r2, #32
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3a6:	f883 213d 	strb.w	r2, [r3, #317]	; 0x13d
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3aa:	f893 215c 	ldrb.w	r2, [r3, #348]	; 0x15c
	tmp &= ~PORT_PINCFG_PMUXEN;
     3ae:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     3b2:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3b6:	f883 215c 	strb.w	r2, [r3, #348]	; 0x15c
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     3ba:	f893 213e 	ldrb.w	r2, [r3, #318]	; 0x13e
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     3be:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     3c2:	f042 0202 	orr.w	r2, r2, #2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3c6:	f883 213e 	strb.w	r2, [r3, #318]	; 0x13e
     3ca:	4770      	bx	lr
     3cc:	41008000 	.word	0x41008000

000003d0 <USART_0_CLOCK_init>:
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     3d0:	4b05      	ldr	r3, [pc, #20]	; (3e8 <USART_0_CLOCK_init+0x18>)
     3d2:	2242      	movs	r2, #66	; 0x42
     3d4:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
     3d8:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBAMASK_SERCOM1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM1;
     3dc:	4a03      	ldr	r2, [pc, #12]	; (3ec <USART_0_CLOCK_init+0x1c>)
     3de:	6953      	ldr	r3, [r2, #20]
     3e0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
     3e4:	6153      	str	r3, [r2, #20]
     3e6:	4770      	bx	lr
     3e8:	40001c00 	.word	0x40001c00
     3ec:	40000800 	.word	0x40000800

000003f0 <USART_0_init>:

	hri_mclk_set_APBAMASK_SERCOM1_bit(MCLK);
}

void USART_0_init(void)
{
     3f0:	b508      	push	{r3, lr}
	USART_0_CLOCK_init();
     3f2:	4b05      	ldr	r3, [pc, #20]	; (408 <USART_0_init+0x18>)
     3f4:	4798      	blx	r3
	usart_sync_init(&USART_0, SERCOM1, (void *)NULL);
     3f6:	2200      	movs	r2, #0
     3f8:	4904      	ldr	r1, [pc, #16]	; (40c <USART_0_init+0x1c>)
     3fa:	4805      	ldr	r0, [pc, #20]	; (410 <USART_0_init+0x20>)
     3fc:	4b05      	ldr	r3, [pc, #20]	; (414 <USART_0_init+0x24>)
     3fe:	4798      	blx	r3
	USART_0_PORT_init();
     400:	4b05      	ldr	r3, [pc, #20]	; (418 <USART_0_init+0x28>)
     402:	4798      	blx	r3
     404:	bd08      	pop	{r3, pc}
     406:	bf00      	nop
     408:	000003d1 	.word	0x000003d1
     40c:	40003400 	.word	0x40003400
     410:	200081f0 	.word	0x200081f0
     414:	00001659 	.word	0x00001659
     418:	00000389 	.word	0x00000389

0000041c <USART_1_CLOCK_init>:
     41c:	4b05      	ldr	r3, [pc, #20]	; (434 <USART_1_CLOCK_init+0x18>)
     41e:	2242      	movs	r2, #66	; 0x42
     420:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
     424:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}

static inline void hri_mclk_set_APBDMASK_SERCOM5_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM5;
     428:	4a03      	ldr	r2, [pc, #12]	; (438 <USART_1_CLOCK_init+0x1c>)
     42a:	6a13      	ldr	r3, [r2, #32]
     42c:	f043 0302 	orr.w	r3, r3, #2
     430:	6213      	str	r3, [r2, #32]
     432:	4770      	bx	lr
     434:	40001c00 	.word	0x40001c00
     438:	40000800 	.word	0x40000800

0000043c <USART_1_PORT_init>:
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     43c:	4b10      	ldr	r3, [pc, #64]	; (480 <USART_1_PORT_init+0x44>)
     43e:	f893 20d0 	ldrb.w	r2, [r3, #208]	; 0xd0
	tmp &= ~PORT_PINCFG_PMUXEN;
     442:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     446:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     44a:	f883 20d0 	strb.w	r2, [r3, #208]	; 0xd0
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     44e:	f893 20b8 	ldrb.w	r2, [r3, #184]	; 0xb8
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     452:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     456:	f042 0202 	orr.w	r2, r2, #2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     45a:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     45e:	f893 20d1 	ldrb.w	r2, [r3, #209]	; 0xd1
	tmp &= ~PORT_PINCFG_PMUXEN;
     462:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     466:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     46a:	f883 20d1 	strb.w	r2, [r3, #209]	; 0xd1
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     46e:	f893 20b8 	ldrb.w	r2, [r3, #184]	; 0xb8
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     472:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     476:	f042 0220 	orr.w	r2, r2, #32
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     47a:	f883 20b8 	strb.w	r2, [r3, #184]	; 0xb8
     47e:	4770      	bx	lr
     480:	41008000 	.word	0x41008000

00000484 <USART_1_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_1_init(void)
{
     484:	b510      	push	{r4, lr}
     486:	b082      	sub	sp, #8
	USART_1_CLOCK_init();
     488:	4b07      	ldr	r3, [pc, #28]	; (4a8 <USART_1_init+0x24>)
     48a:	4798      	blx	r3
	usart_async_init(&USART_1, SERCOM5, USART_1_buffer, USART_1_BUFFER_SIZE, (void *)NULL);
     48c:	2300      	movs	r3, #0
     48e:	9300      	str	r3, [sp, #0]
     490:	f44f 7380 	mov.w	r3, #256	; 0x100
     494:	4a05      	ldr	r2, [pc, #20]	; (4ac <USART_1_init+0x28>)
     496:	4906      	ldr	r1, [pc, #24]	; (4b0 <USART_1_init+0x2c>)
     498:	4806      	ldr	r0, [pc, #24]	; (4b4 <USART_1_init+0x30>)
     49a:	4c07      	ldr	r4, [pc, #28]	; (4b8 <USART_1_init+0x34>)
     49c:	47a0      	blx	r4
	USART_1_PORT_init();
     49e:	4b07      	ldr	r3, [pc, #28]	; (4bc <USART_1_init+0x38>)
     4a0:	4798      	blx	r3
}
     4a2:	b002      	add	sp, #8
     4a4:	bd10      	pop	{r4, pc}
     4a6:	bf00      	nop
     4a8:	0000041d 	.word	0x0000041d
     4ac:	2000009c 	.word	0x2000009c
     4b0:	43000400 	.word	0x43000400
     4b4:	200081fc 	.word	0x200081fc
     4b8:	0000142d 	.word	0x0000142d
     4bc:	0000043d 	.word	0x0000043d

000004c0 <ETHERNET_MAC_0_PORT_init>:
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     4c0:	4b50      	ldr	r3, [pc, #320]	; (604 <ETHERNET_MAC_0_PORT_init+0x144>)
     4c2:	f893 214b 	ldrb.w	r2, [r3, #331]	; 0x14b
	tmp &= ~PORT_PINCFG_PMUXEN;
     4c6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     4ca:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     4ce:	f883 214b 	strb.w	r2, [r3, #331]	; 0x14b
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     4d2:	f893 2135 	ldrb.w	r2, [r3, #309]	; 0x135
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     4d6:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     4da:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     4de:	f883 2135 	strb.w	r2, [r3, #309]	; 0x135
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     4e2:	f893 214c 	ldrb.w	r2, [r3, #332]	; 0x14c
	tmp &= ~PORT_PINCFG_PMUXEN;
     4e6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     4ea:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     4ee:	f883 214c 	strb.w	r2, [r3, #332]	; 0x14c
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     4f2:	f893 2136 	ldrb.w	r2, [r3, #310]	; 0x136
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     4f6:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     4fa:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     4fe:	f883 2136 	strb.w	r2, [r3, #310]	; 0x136
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     502:	f893 204d 	ldrb.w	r2, [r3, #77]	; 0x4d
	tmp &= ~PORT_PINCFG_PMUXEN;
     506:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     50a:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     50e:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     512:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     516:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     51a:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     51e:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     522:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
	tmp &= ~PORT_PINCFG_PMUXEN;
     526:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     52a:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     52e:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     532:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     536:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     53a:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     53e:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     542:	f893 2154 	ldrb.w	r2, [r3, #340]	; 0x154
	tmp &= ~PORT_PINCFG_PMUXEN;
     546:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     54a:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     54e:	f883 2154 	strb.w	r2, [r3, #340]	; 0x154
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     552:	f893 213a 	ldrb.w	r2, [r3, #314]	; 0x13a
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     556:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     55a:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     55e:	f883 213a 	strb.w	r2, [r3, #314]	; 0x13a
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     562:	f893 204f 	ldrb.w	r2, [r3, #79]	; 0x4f
	tmp &= ~PORT_PINCFG_PMUXEN;
     566:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     56a:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     56e:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     572:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     576:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     57a:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     57e:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     582:	f893 2052 	ldrb.w	r2, [r3, #82]	; 0x52
	tmp &= ~PORT_PINCFG_PMUXEN;
     586:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     58a:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     58e:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     592:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     596:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     59a:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     59e:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5a2:	f893 2053 	ldrb.w	r2, [r3, #83]	; 0x53
	tmp &= ~PORT_PINCFG_PMUXEN;
     5a6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5aa:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5ae:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5b2:	f893 2039 	ldrb.w	r2, [r3, #57]	; 0x39
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     5b6:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     5ba:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5be:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5c2:	f893 204e 	ldrb.w	r2, [r3, #78]	; 0x4e
	tmp &= ~PORT_PINCFG_PMUXEN;
     5c6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5ca:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5ce:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5d2:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     5d6:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
     5da:	f042 020b 	orr.w	r2, r2, #11
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5de:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     5e2:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
	tmp &= ~PORT_PINCFG_PMUXEN;
     5e6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     5ea:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     5ee:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     5f2:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     5f6:	f002 020f 	and.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
     5fa:	f042 02b0 	orr.w	r2, r2, #176	; 0xb0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     5fe:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
     602:	4770      	bx	lr
     604:	41008000 	.word	0x41008000

00000608 <ETHERNET_MAC_0_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_GMAC;
     608:	4b04      	ldr	r3, [pc, #16]	; (61c <ETHERNET_MAC_0_CLOCK_init+0x14>)
     60a:	691a      	ldr	r2, [r3, #16]
     60c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
     610:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_GMAC;
     612:	69da      	ldr	r2, [r3, #28]
     614:	f042 0204 	orr.w	r2, r2, #4
     618:	61da      	str	r2, [r3, #28]
     61a:	4770      	bx	lr
     61c:	40000800 	.word	0x40000800

00000620 <ETHERNET_MAC_0_init>:
	hri_mclk_set_AHBMASK_GMAC_bit(MCLK);
	hri_mclk_set_APBCMASK_GMAC_bit(MCLK);
}

void ETHERNET_MAC_0_init(void)
{
     620:	b508      	push	{r3, lr}
	ETHERNET_MAC_0_CLOCK_init();
     622:	4b04      	ldr	r3, [pc, #16]	; (634 <ETHERNET_MAC_0_init+0x14>)
     624:	4798      	blx	r3
	mac_async_init(&ETHERNET_MAC_0, GMAC);
     626:	4904      	ldr	r1, [pc, #16]	; (638 <ETHERNET_MAC_0_init+0x18>)
     628:	4804      	ldr	r0, [pc, #16]	; (63c <ETHERNET_MAC_0_init+0x1c>)
     62a:	4b05      	ldr	r3, [pc, #20]	; (640 <ETHERNET_MAC_0_init+0x20>)
     62c:	4798      	blx	r3
	ETHERNET_MAC_0_PORT_init();
     62e:	4b05      	ldr	r3, [pc, #20]	; (644 <ETHERNET_MAC_0_init+0x24>)
     630:	4798      	blx	r3
     632:	bd08      	pop	{r3, pc}
     634:	00000609 	.word	0x00000609
     638:	42000800 	.word	0x42000800
     63c:	2000824c 	.word	0x2000824c
     640:	00000e99 	.word	0x00000e99
     644:	000004c1 	.word	0x000004c1

00000648 <system_init>:
	mac_async_enable(&ETHERNET_MAC_0);
	mac_async_write(&ETHERNET_MAC_0, (uint8_t *)"Hello World!", 12);
}

void system_init(void)
{
     648:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     64c:	4bdf      	ldr	r3, [pc, #892]	; (9cc <system_init+0x384>)
     64e:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     650:	4bdf      	ldr	r3, [pc, #892]	; (9d0 <system_init+0x388>)
     652:	2210      	movs	r2, #16
     654:	615a      	str	r2, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     656:	609a      	str	r2, [r3, #8]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     658:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     65c:	629a      	str	r2, [r3, #40]	; 0x28
     65e:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
     662:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     664:	f893 1044 	ldrb.w	r1, [r3, #68]	; 0x44
	tmp &= ~PORT_PINCFG_PMUXEN;
     668:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     66c:	f883 1044 	strb.w	r1, [r3, #68]	; 0x44
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     670:	2120      	movs	r1, #32
     672:	6159      	str	r1, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     674:	6099      	str	r1, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     676:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
     67a:	6299      	str	r1, [r3, #40]	; 0x28
     67c:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     67e:	f893 1045 	ldrb.w	r1, [r3, #69]	; 0x45
	tmp &= ~PORT_PINCFG_PMUXEN;
     682:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     686:	f883 1045 	strb.w	r1, [r3, #69]	; 0x45
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     68a:	f04f 0a40 	mov.w	sl, #64	; 0x40
     68e:	f8c3 a014 	str.w	sl, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     692:	f8c3 a008 	str.w	sl, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     696:	49cf      	ldr	r1, [pc, #828]	; (9d4 <system_init+0x38c>)
     698:	6299      	str	r1, [r3, #40]	; 0x28
     69a:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     69c:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	tmp &= ~PORT_PINCFG_PMUXEN;
     6a0:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     6a4:	f883 1046 	strb.w	r1, [r3, #70]	; 0x46
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     6a8:	f04f 0980 	mov.w	r9, #128	; 0x80
     6ac:	f8c3 9014 	str.w	r9, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     6b0:	f8c3 9008 	str.w	r9, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     6b4:	49c8      	ldr	r1, [pc, #800]	; (9d8 <system_init+0x390>)
     6b6:	6299      	str	r1, [r3, #40]	; 0x28
     6b8:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     6ba:	f893 1047 	ldrb.w	r1, [r3, #71]	; 0x47
	tmp &= ~PORT_PINCFG_PMUXEN;
     6be:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     6c2:	f883 1047 	strb.w	r1, [r3, #71]	; 0x47
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     6c6:	f44f 7c80 	mov.w	ip, #256	; 0x100
     6ca:	f8c3 c014 	str.w	ip, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     6ce:	f8c3 c008 	str.w	ip, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     6d2:	49c2      	ldr	r1, [pc, #776]	; (9dc <system_init+0x394>)
     6d4:	6299      	str	r1, [r3, #40]	; 0x28
     6d6:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     6d8:	f893 1048 	ldrb.w	r1, [r3, #72]	; 0x48
	tmp &= ~PORT_PINCFG_PMUXEN;
     6dc:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     6e0:	f883 1048 	strb.w	r1, [r3, #72]	; 0x48
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     6e4:	f44f 7700 	mov.w	r7, #512	; 0x200
     6e8:	615f      	str	r7, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     6ea:	609f      	str	r7, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     6ec:	49bc      	ldr	r1, [pc, #752]	; (9e0 <system_init+0x398>)
     6ee:	6299      	str	r1, [r3, #40]	; 0x28
     6f0:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     6f2:	f893 1049 	ldrb.w	r1, [r3, #73]	; 0x49
	tmp &= ~PORT_PINCFG_PMUXEN;
     6f6:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     6fa:	f883 1049 	strb.w	r1, [r3, #73]	; 0x49
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     6fe:	f44f 6680 	mov.w	r6, #1024	; 0x400
     702:	615e      	str	r6, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     704:	609e      	str	r6, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     706:	49b7      	ldr	r1, [pc, #732]	; (9e4 <system_init+0x39c>)
     708:	6299      	str	r1, [r3, #40]	; 0x28
     70a:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     70c:	f893 104a 	ldrb.w	r1, [r3, #74]	; 0x4a
	tmp &= ~PORT_PINCFG_PMUXEN;
     710:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     714:	f883 104a 	strb.w	r1, [r3, #74]	; 0x4a
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     718:	f44f 6500 	mov.w	r5, #2048	; 0x800
     71c:	615d      	str	r5, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     71e:	609d      	str	r5, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     720:	f8df 82dc 	ldr.w	r8, [pc, #732]	; a00 <system_init+0x3b8>
     724:	f8c3 8028 	str.w	r8, [r3, #40]	; 0x28
     728:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     72a:	f893 104b 	ldrb.w	r1, [r3, #75]	; 0x4b
	tmp &= ~PORT_PINCFG_PMUXEN;
     72e:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     732:	f883 104b 	strb.w	r1, [r3, #75]	; 0x4b
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     736:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
     73a:	6159      	str	r1, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     73c:	6099      	str	r1, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     73e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
     742:	6299      	str	r1, [r3, #40]	; 0x28
     744:	48a8      	ldr	r0, [pc, #672]	; (9e8 <system_init+0x3a0>)
     746:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     748:	f893 0054 	ldrb.w	r0, [r3, #84]	; 0x54
	tmp &= ~PORT_PINCFG_PMUXEN;
     74c:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     750:	f883 0054 	strb.w	r0, [r3, #84]	; 0x54
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     754:	f44f 1e00 	mov.w	lr, #2097152	; 0x200000
     758:	f8c3 e014 	str.w	lr, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     75c:	f8c3 e008 	str.w	lr, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     760:	6299      	str	r1, [r3, #40]	; 0x28
     762:	48a2      	ldr	r0, [pc, #648]	; (9ec <system_init+0x3a4>)
     764:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     766:	f893 0055 	ldrb.w	r0, [r3, #85]	; 0x55
	tmp &= ~PORT_PINCFG_PMUXEN;
     76a:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     76e:	f883 0055 	strb.w	r0, [r3, #85]	; 0x55
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     772:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
     776:	6158      	str	r0, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     778:	6098      	str	r0, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     77a:	6299      	str	r1, [r3, #40]	; 0x28
     77c:	489c      	ldr	r0, [pc, #624]	; (9f0 <system_init+0x3a8>)
     77e:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     780:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
	tmp &= ~PORT_PINCFG_PMUXEN;
     784:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     788:	f883 0056 	strb.w	r0, [r3, #86]	; 0x56
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     78c:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
     790:	6158      	str	r0, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     792:	6098      	str	r0, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     794:	6299      	str	r1, [r3, #40]	; 0x28
     796:	4897      	ldr	r0, [pc, #604]	; (9f4 <system_init+0x3ac>)
     798:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     79a:	f893 0057 	ldrb.w	r0, [r3, #87]	; 0x57
	tmp &= ~PORT_PINCFG_PMUXEN;
     79e:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     7a2:	f883 0057 	strb.w	r0, [r3, #87]	; 0x57
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     7a6:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
     7aa:	615c      	str	r4, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     7ac:	609c      	str	r4, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     7ae:	6299      	str	r1, [r3, #40]	; 0x28
     7b0:	4891      	ldr	r0, [pc, #580]	; (9f8 <system_init+0x3b0>)
     7b2:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7b4:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
	tmp &= ~PORT_PINCFG_PMUXEN;
     7b8:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     7bc:	f883 0058 	strb.w	r0, [r3, #88]	; 0x58
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     7c0:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
     7c4:	6158      	str	r0, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     7c6:	6098      	str	r0, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     7c8:	6299      	str	r1, [r3, #40]	; 0x28
     7ca:	488c      	ldr	r0, [pc, #560]	; (9fc <system_init+0x3b4>)
     7cc:	6298      	str	r0, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7ce:	f893 b059 	ldrb.w	fp, [r3, #89]	; 0x59
	tmp &= ~PORT_PINCFG_PMUXEN;
     7d2:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     7d6:	f883 b059 	strb.w	fp, [r3, #89]	; 0x59
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     7da:	f04f 0b01 	mov.w	fp, #1
     7de:	f8c3 b094 	str.w	fp, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     7e2:	f8c3 b088 	str.w	fp, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     7e6:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
     7ea:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     7ee:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7f2:	f893 b0c0 	ldrb.w	fp, [r3, #192]	; 0xc0
	tmp &= ~PORT_PINCFG_PMUXEN;
     7f6:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     7fa:	f883 b0c0 	strb.w	fp, [r3, #192]	; 0xc0
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     7fe:	f04f 0b02 	mov.w	fp, #2
     802:	f8c3 b094 	str.w	fp, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     806:	f8c3 b088 	str.w	fp, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     80a:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
     80e:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     812:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     816:	f893 b0c1 	ldrb.w	fp, [r3, #193]	; 0xc1
	tmp &= ~PORT_PINCFG_PMUXEN;
     81a:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     81e:	f883 b0c1 	strb.w	fp, [r3, #193]	; 0xc1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     822:	f04f 0b04 	mov.w	fp, #4
     826:	f8c3 b094 	str.w	fp, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     82a:	f8c3 b088 	str.w	fp, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     82e:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
     832:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     836:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     83a:	f893 b0c2 	ldrb.w	fp, [r3, #194]	; 0xc2
	tmp &= ~PORT_PINCFG_PMUXEN;
     83e:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     842:	f883 b0c2 	strb.w	fp, [r3, #194]	; 0xc2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     846:	f04f 0b08 	mov.w	fp, #8
     84a:	f8c3 b094 	str.w	fp, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     84e:	f8c3 b088 	str.w	fp, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     852:	f10b 4b80 	add.w	fp, fp, #1073741824	; 0x40000000
     856:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     85a:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     85e:	f893 b0c3 	ldrb.w	fp, [r3, #195]	; 0xc3
	tmp &= ~PORT_PINCFG_PMUXEN;
     862:	f00b 0bfe 	and.w	fp, fp, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     866:	f883 b0c3 	strb.w	fp, [r3, #195]	; 0xc3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     86a:	f8c3 a094 	str.w	sl, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     86e:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     872:	4858      	ldr	r0, [pc, #352]	; (9d4 <system_init+0x38c>)
     874:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
     878:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     87c:	f893 a0c6 	ldrb.w	sl, [r3, #198]	; 0xc6
	tmp &= ~PORT_PINCFG_PMUXEN;
     880:	f00a 0afe 	and.w	sl, sl, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     884:	f883 a0c6 	strb.w	sl, [r3, #198]	; 0xc6
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     888:	f8c3 9094 	str.w	r9, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     88c:	f8c3 9088 	str.w	r9, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     890:	3040      	adds	r0, #64	; 0x40
     892:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
     896:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     89a:	f893 90c7 	ldrb.w	r9, [r3, #199]	; 0xc7
	tmp &= ~PORT_PINCFG_PMUXEN;
     89e:	f009 09fe 	and.w	r9, r9, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8a2:	f883 90c7 	strb.w	r9, [r3, #199]	; 0xc7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     8a6:	f8c3 c094 	str.w	ip, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     8aa:	f8c3 c088 	str.w	ip, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     8ae:	3080      	adds	r0, #128	; 0x80
     8b0:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
     8b4:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8b8:	f893 c0c8 	ldrb.w	ip, [r3, #200]	; 0xc8
	tmp &= ~PORT_PINCFG_PMUXEN;
     8bc:	f00c 0cfe 	and.w	ip, ip, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8c0:	f883 c0c8 	strb.w	ip, [r3, #200]	; 0xc8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     8c4:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     8c8:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     8cc:	f500 7080 	add.w	r0, r0, #256	; 0x100
     8d0:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
     8d4:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8d8:	f893 70c9 	ldrb.w	r7, [r3, #201]	; 0xc9
	tmp &= ~PORT_PINCFG_PMUXEN;
     8dc:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     8e0:	f883 70c9 	strb.w	r7, [r3, #201]	; 0xc9
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     8e4:	f8c3 6094 	str.w	r6, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     8e8:	f8c3 6088 	str.w	r6, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     8ec:	f500 7000 	add.w	r0, r0, #512	; 0x200
     8f0:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
     8f4:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     8f8:	f893 60ca 	ldrb.w	r6, [r3, #202]	; 0xca
	tmp &= ~PORT_PINCFG_PMUXEN;
     8fc:	f006 06fe 	and.w	r6, r6, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     900:	f883 60ca 	strb.w	r6, [r3, #202]	; 0xca
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     904:	f8c3 5094 	str.w	r5, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     908:	f8c3 5088 	str.w	r5, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     90c:	f8c3 80a8 	str.w	r8, [r3, #168]	; 0xa8
     910:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     914:	f893 50cb 	ldrb.w	r5, [r3, #203]	; 0xcb
	tmp &= ~PORT_PINCFG_PMUXEN;
     918:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     91c:	f883 50cb 	strb.w	r5, [r3, #203]	; 0xcb
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     920:	f44f 5580 	mov.w	r5, #4096	; 0x1000
     924:	f8c3 5094 	str.w	r5, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     928:	f8c3 5088 	str.w	r5, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     92c:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
     930:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     934:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     938:	f893 50cc 	ldrb.w	r5, [r3, #204]	; 0xcc
	tmp &= ~PORT_PINCFG_PMUXEN;
     93c:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     940:	f883 50cc 	strb.w	r5, [r3, #204]	; 0xcc
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     944:	f44f 5500 	mov.w	r5, #8192	; 0x2000
     948:	f8c3 5094 	str.w	r5, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     94c:	f8c3 5088 	str.w	r5, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     950:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
     954:	f8c3 50a8 	str.w	r5, [r3, #168]	; 0xa8
     958:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     95c:	f893 50cd 	ldrb.w	r5, [r3, #205]	; 0xcd
	tmp &= ~PORT_PINCFG_PMUXEN;
     960:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     964:	f883 50cd 	strb.w	r5, [r3, #205]	; 0xcd
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     968:	f44f 4780 	mov.w	r7, #16384	; 0x4000
     96c:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     970:	f8c3 7088 	str.w	r7, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     974:	f04f 2b40 	mov.w	fp, #1073758208	; 0x40004000
     978:	f8c3 b0a8 	str.w	fp, [r3, #168]	; 0xa8
     97c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     980:	f893 50ce 	ldrb.w	r5, [r3, #206]	; 0xce
	tmp &= ~PORT_PINCFG_PMUXEN;
     984:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     988:	f883 50ce 	strb.w	r5, [r3, #206]	; 0xce
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     98c:	f44f 2680 	mov.w	r6, #262144	; 0x40000
     990:	f8c3 6094 	str.w	r6, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     994:	f8c3 6088 	str.w	r6, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     998:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     99c:	f8df a064 	ldr.w	sl, [pc, #100]	; a04 <system_init+0x3bc>
     9a0:	f8c3 a0a8 	str.w	sl, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     9a4:	f893 50d2 	ldrb.w	r5, [r3, #210]	; 0xd2
	tmp &= ~PORT_PINCFG_PMUXEN;
     9a8:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     9ac:	f883 50d2 	strb.w	r5, [r3, #210]	; 0xd2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     9b0:	f44f 2500 	mov.w	r5, #524288	; 0x80000
     9b4:	f8c3 5094 	str.w	r5, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     9b8:	f8c3 5088 	str.w	r5, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     9bc:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     9c0:	f8df 9044 	ldr.w	r9, [pc, #68]	; a08 <system_init+0x3c0>
     9c4:	f8c3 90a8 	str.w	r9, [r3, #168]	; 0xa8
     9c8:	e020      	b.n	a0c <system_init+0x3c4>
     9ca:	bf00      	nop
     9cc:	000018d5 	.word	0x000018d5
     9d0:	41008000 	.word	0x41008000
     9d4:	40000040 	.word	0x40000040
     9d8:	40000080 	.word	0x40000080
     9dc:	40000100 	.word	0x40000100
     9e0:	40000200 	.word	0x40000200
     9e4:	40000400 	.word	0x40000400
     9e8:	c0000010 	.word	0xc0000010
     9ec:	c0000020 	.word	0xc0000020
     9f0:	c0000040 	.word	0xc0000040
     9f4:	c0000080 	.word	0xc0000080
     9f8:	c0000100 	.word	0xc0000100
     9fc:	c0000200 	.word	0xc0000200
     a00:	40000800 	.word	0x40000800
     a04:	c0000004 	.word	0xc0000004
     a08:	c0000008 	.word	0xc0000008
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a0c:	f893 c0d3 	ldrb.w	ip, [r3, #211]	; 0xd3
	tmp &= ~PORT_PINCFG_PMUXEN;
     a10:	f00c 0cfe 	and.w	ip, ip, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a14:	f883 c0d3 	strb.w	ip, [r3, #211]	; 0xd3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a18:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
     a1c:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a20:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a24:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     a28:	484c      	ldr	r0, [pc, #304]	; (b5c <system_init+0x514>)
     a2a:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a2e:	f893 c0d4 	ldrb.w	ip, [r3, #212]	; 0xd4
	tmp &= ~PORT_PINCFG_PMUXEN;
     a32:	f00c 0cfe 	and.w	ip, ip, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a36:	f883 c0d4 	strb.w	ip, [r3, #212]	; 0xd4
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a3a:	f8c3 e094 	str.w	lr, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a3e:	f8c3 e088 	str.w	lr, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a42:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     a46:	3010      	adds	r0, #16
     a48:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a4c:	f893 e0d5 	ldrb.w	lr, [r3, #213]	; 0xd5
	tmp &= ~PORT_PINCFG_PMUXEN;
     a50:	f00e 0efe 	and.w	lr, lr, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a54:	f883 e0d5 	strb.w	lr, [r3, #213]	; 0xd5
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a58:	f8c3 4094 	str.w	r4, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a5c:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a60:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     a64:	30e0      	adds	r0, #224	; 0xe0
     a66:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a6a:	f893 e0d8 	ldrb.w	lr, [r3, #216]	; 0xd8
	tmp &= ~PORT_PINCFG_PMUXEN;
     a6e:	f00e 0efe 	and.w	lr, lr, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a72:	f883 e0d8 	strb.w	lr, [r3, #216]	; 0xd8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     a76:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
     a7a:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a7e:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     a82:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
     a86:	4836      	ldr	r0, [pc, #216]	; (b60 <system_init+0x518>)
     a88:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     a8c:	f893 e0d9 	ldrb.w	lr, [r3, #217]	; 0xd9
	tmp &= ~PORT_PINCFG_PMUXEN;
     a90:	f00e 0efe 	and.w	lr, lr, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     a94:	f883 e0d9 	strb.w	lr, [r3, #217]	; 0xd9
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     a98:	f8c3 7118 	str.w	r7, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     a9c:	f8c3 7108 	str.w	r7, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     aa0:	f8c3 b128 	str.w	fp, [r3, #296]	; 0x128
     aa4:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     aa8:	f893 214e 	ldrb.w	r2, [r3, #334]	; 0x14e
	tmp &= ~PORT_PINCFG_PMUXEN;
     aac:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     ab0:	f883 214e 	strb.w	r2, [r3, #334]	; 0x14e
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     ab4:	f8c3 6114 	str.w	r6, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     ab8:	f8c3 6108 	str.w	r6, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     abc:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
     ac0:	f8c3 a128 	str.w	sl, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     ac4:	f893 2152 	ldrb.w	r2, [r3, #338]	; 0x152
	tmp &= ~PORT_PINCFG_PMUXEN;
     ac8:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     acc:	f883 2152 	strb.w	r2, [r3, #338]	; 0x152
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     ad0:	f8c3 5114 	str.w	r5, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     ad4:	f8c3 5108 	str.w	r5, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     ad8:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
     adc:	f8c3 9128 	str.w	r9, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     ae0:	f893 2153 	ldrb.w	r2, [r3, #339]	; 0x153
	tmp &= ~PORT_PINCFG_PMUXEN;
     ae4:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     ae8:	f883 2153 	strb.w	r2, [r3, #339]	; 0x153
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     aec:	f8c3 4114 	str.w	r4, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     af0:	f8c3 4108 	str.w	r4, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     af4:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
     af8:	4a1a      	ldr	r2, [pc, #104]	; (b64 <system_init+0x51c>)
     afa:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     afe:	f893 2158 	ldrb.w	r2, [r3, #344]	; 0x158
	tmp &= ~PORT_PINCFG_PMUXEN;
     b02:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b06:	f883 2158 	strb.w	r2, [r3, #344]	; 0x158
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     b0a:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
     b0e:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     b12:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     b16:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
     b1a:	f8c3 0128 	str.w	r0, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     b1e:	f893 2159 	ldrb.w	r2, [r3, #345]	; 0x159
	tmp &= ~PORT_PINCFG_PMUXEN;
     b22:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     b26:	f883 2159 	strb.w	r2, [r3, #345]	; 0x159
	// Set pin direction to output
	gpio_set_pin_direction(PC25, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(PC25, GPIO_PIN_FUNCTION_OFF);

	USART_0_init();
     b2a:	4b0f      	ldr	r3, [pc, #60]	; (b68 <system_init+0x520>)
     b2c:	4798      	blx	r3
	USART_1_init();
     b2e:	4b0f      	ldr	r3, [pc, #60]	; (b6c <system_init+0x524>)
     b30:	4798      	blx	r3
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC0;
     b32:	f8d8 3014 	ldr.w	r3, [r8, #20]
     b36:	433b      	orrs	r3, r7
     b38:	f8c8 3014 	str.w	r3, [r8, #20]
     b3c:	2242      	movs	r2, #66	; 0x42
     b3e:	4b0c      	ldr	r3, [pc, #48]	; (b70 <system_init+0x528>)
     b40:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
	timer_init(&TIMER_0, TC0, _tc_get_timer());
     b44:	4b0b      	ldr	r3, [pc, #44]	; (b74 <system_init+0x52c>)
     b46:	4798      	blx	r3
     b48:	4602      	mov	r2, r0
     b4a:	490b      	ldr	r1, [pc, #44]	; (b78 <system_init+0x530>)
     b4c:	480b      	ldr	r0, [pc, #44]	; (b7c <system_init+0x534>)
     b4e:	4b0c      	ldr	r3, [pc, #48]	; (b80 <system_init+0x538>)
     b50:	4798      	blx	r3

	TIMER_0_init();
	ETHERNET_MAC_0_init();
     b52:	4b0c      	ldr	r3, [pc, #48]	; (b84 <system_init+0x53c>)
     b54:	4798      	blx	r3
     b56:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
     b5a:	bf00      	nop
     b5c:	c0000010 	.word	0xc0000010
     b60:	c0000200 	.word	0xc0000200
     b64:	c0000100 	.word	0xc0000100
     b68:	000003f1 	.word	0x000003f1
     b6c:	00000485 	.word	0x00000485
     b70:	40001c00 	.word	0x40001c00
     b74:	00002553 	.word	0x00002553
     b78:	40003800 	.word	0x40003800
     b7c:	20008268 	.word	0x20008268
     b80:	0000115d 	.word	0x0000115d
     b84:	00000621 	.word	0x00000621

00000b88 <ethernet_phy_init>:
/**
 * \brief Perform a HW initialization to the PHY
 */
int32_t ethernet_phy_init(struct ethernet_phy_descriptor *const descr, struct mac_async_descriptor *const mac,
                          uint16_t addr)
{
     b88:	b570      	push	{r4, r5, r6, lr}
     b8a:	460d      	mov	r5, r1
     b8c:	4616      	mov	r6, r2
	ASSERT(descr && mac && (addr <= 0x1F));
     b8e:	4604      	mov	r4, r0
     b90:	b160      	cbz	r0, bac <ethernet_phy_init+0x24>
     b92:	b169      	cbz	r1, bb0 <ethernet_phy_init+0x28>
     b94:	2a1f      	cmp	r2, #31
     b96:	bf8c      	ite	hi
     b98:	2000      	movhi	r0, #0
     b9a:	2001      	movls	r0, #1
     b9c:	222a      	movs	r2, #42	; 0x2a
     b9e:	4905      	ldr	r1, [pc, #20]	; (bb4 <ethernet_phy_init+0x2c>)
     ba0:	4b05      	ldr	r3, [pc, #20]	; (bb8 <ethernet_phy_init+0x30>)
     ba2:	4798      	blx	r3

	descr->mac  = mac;
     ba4:	6025      	str	r5, [r4, #0]
	descr->addr = addr;
     ba6:	80a6      	strh	r6, [r4, #4]
	return ERR_NONE;
}
     ba8:	2000      	movs	r0, #0
     baa:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && mac && (addr <= 0x1F));
     bac:	2000      	movs	r0, #0
     bae:	e7f5      	b.n	b9c <ethernet_phy_init+0x14>
     bb0:	2000      	movs	r0, #0
     bb2:	e7f3      	b.n	b9c <ethernet_phy_init+0x14>
     bb4:	0000a8f8 	.word	0x0000a8f8
     bb8:	000016f5 	.word	0x000016f5

00000bbc <ethernet_phy_set_reg_bit>:

/**
 * \brief Setting bit for a PHY Register
 */
int32_t ethernet_phy_set_reg_bit(struct ethernet_phy_descriptor *const descr, uint16_t reg, uint16_t ofst)
{
     bbc:	b5f0      	push	{r4, r5, r6, r7, lr}
     bbe:	b083      	sub	sp, #12
     bc0:	460d      	mov	r5, r1
     bc2:	4616      	mov	r6, r2
	int32_t  rst;
	uint16_t val;

	ASSERT(descr && descr->mac && (reg <= 0x1F));
     bc4:	4604      	mov	r4, r0
     bc6:	b1a8      	cbz	r0, bf4 <ethernet_phy_set_reg_bit+0x38>
     bc8:	6803      	ldr	r3, [r0, #0]
     bca:	b1ab      	cbz	r3, bf8 <ethernet_phy_set_reg_bit+0x3c>
     bcc:	291f      	cmp	r1, #31
     bce:	bf8c      	ite	hi
     bd0:	2000      	movhi	r0, #0
     bd2:	2001      	movls	r0, #1
     bd4:	2257      	movs	r2, #87	; 0x57
     bd6:	490f      	ldr	r1, [pc, #60]	; (c14 <ethernet_phy_set_reg_bit+0x58>)
     bd8:	4b0f      	ldr	r3, [pc, #60]	; (c18 <ethernet_phy_set_reg_bit+0x5c>)
     bda:	4798      	blx	r3

	rst = mac_async_read_phy_reg(descr->mac, descr->addr, reg, &val);
     bdc:	f10d 0306 	add.w	r3, sp, #6
     be0:	462a      	mov	r2, r5
     be2:	88a1      	ldrh	r1, [r4, #4]
     be4:	6820      	ldr	r0, [r4, #0]
     be6:	4f0d      	ldr	r7, [pc, #52]	; (c1c <ethernet_phy_set_reg_bit+0x60>)
     be8:	47b8      	blx	r7
	if (rst == ERR_NONE) {
     bea:	4603      	mov	r3, r0
     bec:	b130      	cbz	r0, bfc <ethernet_phy_set_reg_bit+0x40>
		val |= ofst;
		rst = mac_async_write_phy_reg(descr->mac, descr->addr, reg, val);
	}
	return rst;
}
     bee:	4618      	mov	r0, r3
     bf0:	b003      	add	sp, #12
     bf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ASSERT(descr && descr->mac && (reg <= 0x1F));
     bf4:	2000      	movs	r0, #0
     bf6:	e7ed      	b.n	bd4 <ethernet_phy_set_reg_bit+0x18>
     bf8:	2000      	movs	r0, #0
     bfa:	e7eb      	b.n	bd4 <ethernet_phy_set_reg_bit+0x18>
		val |= ofst;
     bfc:	f8bd 3006 	ldrh.w	r3, [sp, #6]
     c00:	4333      	orrs	r3, r6
     c02:	f8ad 3006 	strh.w	r3, [sp, #6]
		rst = mac_async_write_phy_reg(descr->mac, descr->addr, reg, val);
     c06:	462a      	mov	r2, r5
     c08:	88a1      	ldrh	r1, [r4, #4]
     c0a:	6820      	ldr	r0, [r4, #0]
     c0c:	4c04      	ldr	r4, [pc, #16]	; (c20 <ethernet_phy_set_reg_bit+0x64>)
     c0e:	47a0      	blx	r4
     c10:	4603      	mov	r3, r0
	return rst;
     c12:	e7ec      	b.n	bee <ethernet_phy_set_reg_bit+0x32>
     c14:	0000a8f8 	.word	0x0000a8f8
     c18:	000016f5 	.word	0x000016f5
     c1c:	0000104d 	.word	0x0000104d
     c20:	00001019 	.word	0x00001019

00000c24 <ethernet_phy_restart_autoneg>:

/**
 * \brief Restart an auto negotiation of the PHY.
 */
int32_t ethernet_phy_restart_autoneg(struct ethernet_phy_descriptor *const descr)
{
     c24:	b510      	push	{r4, lr}
	ASSERT(descr);
     c26:	4604      	mov	r4, r0
     c28:	2290      	movs	r2, #144	; 0x90
     c2a:	4906      	ldr	r1, [pc, #24]	; (c44 <ethernet_phy_restart_autoneg+0x20>)
     c2c:	3000      	adds	r0, #0
     c2e:	bf18      	it	ne
     c30:	2001      	movne	r0, #1
     c32:	4b05      	ldr	r3, [pc, #20]	; (c48 <ethernet_phy_restart_autoneg+0x24>)
     c34:	4798      	blx	r3
	return ethernet_phy_set_reg_bit(descr, MDIO_REG0_BMCR, MDIO_REG0_BIT_RESTART_AUTONEG);
     c36:	f44f 7200 	mov.w	r2, #512	; 0x200
     c3a:	2100      	movs	r1, #0
     c3c:	4620      	mov	r0, r4
     c3e:	4b03      	ldr	r3, [pc, #12]	; (c4c <ethernet_phy_restart_autoneg+0x28>)
     c40:	4798      	blx	r3
}
     c42:	bd10      	pop	{r4, pc}
     c44:	0000a8f8 	.word	0x0000a8f8
     c48:	000016f5 	.word	0x000016f5
     c4c:	00000bbd 	.word	0x00000bbd

00000c50 <ethernet_phy_get_link_status>:

/**
 * \brief Get PHY link status
 */
int32_t ethernet_phy_get_link_status(struct ethernet_phy_descriptor *const descr, bool *status)
{
     c50:	b530      	push	{r4, r5, lr}
     c52:	b083      	sub	sp, #12
     c54:	460d      	mov	r5, r1
	int32_t  rst;
	uint16_t val;

	ASSERT(descr && descr->mac && status);
     c56:	4604      	mov	r4, r0
     c58:	b1c8      	cbz	r0, c8e <ethernet_phy_get_link_status+0x3e>
     c5a:	6803      	ldr	r3, [r0, #0]
     c5c:	b1cb      	cbz	r3, c92 <ethernet_phy_get_link_status+0x42>
     c5e:	1c08      	adds	r0, r1, #0
     c60:	bf18      	it	ne
     c62:	2001      	movne	r0, #1
     c64:	22a9      	movs	r2, #169	; 0xa9
     c66:	490c      	ldr	r1, [pc, #48]	; (c98 <ethernet_phy_get_link_status+0x48>)
     c68:	4b0c      	ldr	r3, [pc, #48]	; (c9c <ethernet_phy_get_link_status+0x4c>)
     c6a:	4798      	blx	r3
	rst = mac_async_read_phy_reg(descr->mac, descr->addr, MDIO_REG1_BMSR, &val);
     c6c:	f10d 0306 	add.w	r3, sp, #6
     c70:	2201      	movs	r2, #1
     c72:	88a1      	ldrh	r1, [r4, #4]
     c74:	6820      	ldr	r0, [r4, #0]
     c76:	4c0a      	ldr	r4, [pc, #40]	; (ca0 <ethernet_phy_get_link_status+0x50>)
     c78:	47a0      	blx	r4
	if (rst == ERR_NONE) {
     c7a:	4602      	mov	r2, r0
     c7c:	b920      	cbnz	r0, c88 <ethernet_phy_get_link_status+0x38>
		*status = (val & MDIO_REG1_BIT_LINK_STATUS) ? true : false;
     c7e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
     c82:	f3c3 0380 	ubfx	r3, r3, #2, #1
     c86:	702b      	strb	r3, [r5, #0]
	}
	return rst;
}
     c88:	4610      	mov	r0, r2
     c8a:	b003      	add	sp, #12
     c8c:	bd30      	pop	{r4, r5, pc}
	ASSERT(descr && descr->mac && status);
     c8e:	2000      	movs	r0, #0
     c90:	e7e8      	b.n	c64 <ethernet_phy_get_link_status+0x14>
     c92:	2000      	movs	r0, #0
     c94:	e7e6      	b.n	c64 <ethernet_phy_get_link_status+0x14>
     c96:	bf00      	nop
     c98:	0000a8f8 	.word	0x0000a8f8
     c9c:	000016f5 	.word	0x000016f5
     ca0:	0000104d 	.word	0x0000104d

00000ca4 <ETHERNET_PHY_0_init>:


struct ethernet_phy_descriptor ETHERNET_PHY_0_desc;

void ETHERNET_PHY_0_init(void)
{
     ca4:	b510      	push	{r4, lr}
	mac_async_enable(&ETHERNET_MAC_0);
     ca6:	4c05      	ldr	r4, [pc, #20]	; (cbc <ETHERNET_PHY_0_init+0x18>)
     ca8:	4620      	mov	r0, r4
     caa:	4b05      	ldr	r3, [pc, #20]	; (cc0 <ETHERNET_PHY_0_init+0x1c>)
     cac:	4798      	blx	r3
	ethernet_phy_init(&ETHERNET_PHY_0_desc, &ETHERNET_MAC_0, CONF_ETHERNET_PHY_0_IEEE8023_MII_PHY_ADDRESS);
     cae:	2200      	movs	r2, #0
     cb0:	4621      	mov	r1, r4
     cb2:	4804      	ldr	r0, [pc, #16]	; (cc4 <ETHERNET_PHY_0_init+0x20>)
     cb4:	4b04      	ldr	r3, [pc, #16]	; (cc8 <ETHERNET_PHY_0_init+0x24>)
     cb6:	4798      	blx	r3
     cb8:	bd10      	pop	{r4, pc}
     cba:	bf00      	nop
     cbc:	2000824c 	.word	0x2000824c
     cc0:	00000ec9 	.word	0x00000ec9
     cc4:	200081e8 	.word	0x200081e8
     cc8:	00000b89 	.word	0x00000b89

00000ccc <ETHERNET_PHY_0_example>:
	ethernet_phy_write_reg(&ETHERNET_PHY_0_desc, MDIO_REG0_BMCR, CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0);
#endif /* CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0_SETTING */
}

void ETHERNET_PHY_0_example(void)
{
     ccc:	b530      	push	{r4, r5, lr}
     cce:	b083      	sub	sp, #12
	bool    link_state;
	int32_t rst;
	/* Restart an auto-negotiation */
	rst = ethernet_phy_restart_autoneg(&ETHERNET_PHY_0_desc);
     cd0:	4808      	ldr	r0, [pc, #32]	; (cf4 <ETHERNET_PHY_0_example+0x28>)
     cd2:	4b09      	ldr	r3, [pc, #36]	; (cf8 <ETHERNET_PHY_0_example+0x2c>)
     cd4:	4798      	blx	r3
	while (rst != ERR_NONE) {
     cd6:	b100      	cbz	r0, cda <ETHERNET_PHY_0_example+0xe>
     cd8:	e7fe      	b.n	cd8 <ETHERNET_PHY_0_example+0xc>
	}

	/* Wait for PHY link up */
	do {
		rst = ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_state);
     cda:	4d06      	ldr	r5, [pc, #24]	; (cf4 <ETHERNET_PHY_0_example+0x28>)
     cdc:	4c07      	ldr	r4, [pc, #28]	; (cfc <ETHERNET_PHY_0_example+0x30>)
     cde:	f10d 0107 	add.w	r1, sp, #7
     ce2:	4628      	mov	r0, r5
     ce4:	47a0      	blx	r4
	} while (rst == ERR_NONE && link_state == false);  //tph true
     ce6:	b918      	cbnz	r0, cf0 <ETHERNET_PHY_0_example+0x24>
     ce8:	f89d 3007 	ldrb.w	r3, [sp, #7]
     cec:	2b00      	cmp	r3, #0
     cee:	d0f6      	beq.n	cde <ETHERNET_PHY_0_example+0x12>
}
     cf0:	b003      	add	sp, #12
     cf2:	bd30      	pop	{r4, r5, pc}
     cf4:	200081e8 	.word	0x200081e8
     cf8:	00000c25 	.word	0x00000c25
     cfc:	00000c51 	.word	0x00000c51

00000d00 <ethernet_phys_init>:

void ethernet_phys_init(void)
{
     d00:	b508      	push	{r3, lr}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     d02:	4b0d      	ldr	r3, [pc, #52]	; (d38 <ethernet_phys_init+0x38>)
     d04:	f44f 4280 	mov.w	r2, #16384	; 0x4000
     d08:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     d0c:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
     d10:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
     d14:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
     d18:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     d1c:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     d20:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     d24:	f8c3 0128 	str.w	r0, [r3, #296]	; 0x128
     d28:	f8c3 1128 	str.w	r1, [r3, #296]	; 0x128
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     d2c:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
//not needed to use as regular gpio?	gpio_set_pin_function(PA14, PINMUX_PA18L_GMAC_GTX0);

	gpio_set_pin_direction(PHY_YELLOW_LED_PIN,GPIO_DIRECTION_OUT);
	gpio_set_pin_level(PHY_YELLOW_LED_PIN,true);

	ETHERNET_PHY_0_init();
     d30:	4b02      	ldr	r3, [pc, #8]	; (d3c <ethernet_phys_init+0x3c>)
     d32:	4798      	blx	r3
     d34:	bd08      	pop	{r3, pc}
     d36:	bf00      	nop
     d38:	41008000 	.word	0x41008000
     d3c:	00000ca5 	.word	0x00000ca5

00000d40 <LWIP_MACIF_stack_init>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 * @return ERR_OK  if the loopif is initialized
 */
err_t LWIP_MACIF_stack_init(struct netif *netif)
{
     d40:	b508      	push	{r3, lr}
	LWIP_ASSERT("netif != NULL", (netif != NULL));
	LWIP_ASSERT("netif->state != NULL", (netif->state != NULL));

	netif->output     = etharp_output;
     d42:	4a0e      	ldr	r2, [pc, #56]	; (d7c <LWIP_MACIF_stack_init+0x3c>)
     d44:	6142      	str	r2, [r0, #20]
	netif->linkoutput = mac_low_level_output;
     d46:	4a0e      	ldr	r2, [pc, #56]	; (d80 <LWIP_MACIF_stack_init+0x40>)
     d48:	6182      	str	r2, [r0, #24]

	/* device capabilities */
	LWIP_MACIF_desc.flags = CONF_LWIP_MACIF_FLAG;
     d4a:	4b0e      	ldr	r3, [pc, #56]	; (d84 <LWIP_MACIF_stack_init+0x44>)
     d4c:	226a      	movs	r2, #106	; 0x6a
     d4e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
	LWIP_MACIF_desc.mtu   = CONF_LWIP_MACIF_MTU;
     d52:	f44f 62c0 	mov.w	r2, #1536	; 0x600
     d56:	859a      	strh	r2, [r3, #44]	; 0x2c

	/* set MAC hardware address length */
	memcpy(LWIP_MACIF_desc.hwaddr, LWIP_MACIF_hwaddr, NETIF_MAX_HWADDR_LEN);
     d58:	4a0b      	ldr	r2, [pc, #44]	; (d88 <LWIP_MACIF_stack_init+0x48>)
     d5a:	6811      	ldr	r1, [r2, #0]
     d5c:	f8c3 102f 	str.w	r1, [r3, #47]	; 0x2f
     d60:	8892      	ldrh	r2, [r2, #4]
     d62:	f8a3 2033 	strh.w	r2, [r3, #51]	; 0x33
	LWIP_MACIF_desc.hwaddr_len = ETHARP_HWADDR_LEN;
     d66:	2206      	movs	r2, #6
     d68:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

#if LWIP_NETIF_HOSTNAME
	/* Initialize interface hostname */
	LWIP_MACIF_desc.hostname = CONF_LWIP_MACIF_HOSTNAME;
#endif
	memcpy(LWIP_MACIF_desc.name, CONF_LWIP_MACIF_HOSTNAME_ABBR, 2);
     d6c:	f646 6265 	movw	r2, #28261	; 0x6e65
     d70:	86da      	strh	r2, [r3, #54]	; 0x36

	/* initialize the mac hardware */
	mac_low_level_init(netif);
     d72:	4b06      	ldr	r3, [pc, #24]	; (d8c <LWIP_MACIF_stack_init+0x4c>)
     d74:	4798      	blx	r3

	return ERR_OK;
}
     d76:	2000      	movs	r0, #0
     d78:	bd08      	pop	{r3, pc}
     d7a:	bf00      	nop
     d7c:	00008b45 	.word	0x00008b45
     d80:	000025e5 	.word	0x000025e5
     d84:	2000828c 	.word	0x2000828c
     d88:	20008284 	.word	0x20008284
     d8c:	000025b9 	.word	0x000025b9

00000d90 <LWIP_MACIF_init>:
void LWIP_MACIF_init(u8_t hwaddr[6])
{
     d90:	b510      	push	{r4, lr}
     d92:	b088      	sub	sp, #32
	struct ip_addr ip;
	struct ip_addr nm;
	struct ip_addr gw;
#if CONF_LWIP_MACIF_DHCP
	ip_addr_set_zero(&ip);
     d94:	2200      	movs	r2, #0
     d96:	9207      	str	r2, [sp, #28]
	ip_addr_set_zero(&nm);
     d98:	9206      	str	r2, [sp, #24]
	ip_addr_set_zero(&gw);
     d9a:	ab08      	add	r3, sp, #32
     d9c:	f843 2d0c 	str.w	r2, [r3, #-12]!
#else
	ipaddr_aton(CONF_LWIP_MACIF_IP, &ip);
	ipaddr_aton(CONF_LWIP_MACIF_NETMASK, &nm);
	ipaddr_aton(CONF_LWIP_MACIF_GATEWAY, &gw);
#endif
	memcpy(LWIP_MACIF_hwaddr, hwaddr, 6);
     da0:	4a08      	ldr	r2, [pc, #32]	; (dc4 <LWIP_MACIF_init+0x34>)
     da2:	6801      	ldr	r1, [r0, #0]
     da4:	6011      	str	r1, [r2, #0]
     da6:	8881      	ldrh	r1, [r0, #4]
     da8:	8091      	strh	r1, [r2, #4]

	netif_add(&LWIP_MACIF_desc, &ip, &nm, &gw, (void *)&ETHERNET_MAC_0, LWIP_MACIF_stack_init, ethernet_input);
     daa:	4a07      	ldr	r2, [pc, #28]	; (dc8 <LWIP_MACIF_init+0x38>)
     dac:	9202      	str	r2, [sp, #8]
     dae:	4a07      	ldr	r2, [pc, #28]	; (dcc <LWIP_MACIF_init+0x3c>)
     db0:	9201      	str	r2, [sp, #4]
     db2:	4a07      	ldr	r2, [pc, #28]	; (dd0 <LWIP_MACIF_init+0x40>)
     db4:	9200      	str	r2, [sp, #0]
     db6:	aa06      	add	r2, sp, #24
     db8:	a907      	add	r1, sp, #28
     dba:	4806      	ldr	r0, [pc, #24]	; (dd4 <LWIP_MACIF_init+0x44>)
     dbc:	4c06      	ldr	r4, [pc, #24]	; (dd8 <LWIP_MACIF_init+0x48>)
     dbe:	47a0      	blx	r4
}
     dc0:	b008      	add	sp, #32
     dc2:	bd10      	pop	{r4, pc}
     dc4:	20008284 	.word	0x20008284
     dc8:	00008c65 	.word	0x00008c65
     dcc:	00000d41 	.word	0x00000d41
     dd0:	2000824c 	.word	0x2000824c
     dd4:	2000828c 	.word	0x2000828c
     dd8:	000052ad 	.word	0x000052ad

00000ddc <eth_ipstack_init>:

void eth_ipstack_init(void)
{
     ddc:	b508      	push	{r3, lr}
	lwip_init();
     dde:	4b01      	ldr	r3, [pc, #4]	; (de4 <eth_ipstack_init+0x8>)
     de0:	4798      	blx	r3
     de2:	bd08      	pop	{r3, pc}
     de4:	00004001 	.word	0x00004001

00000de8 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
     de8:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
     dec:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
     dee:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
     df0:	f3bf 8f5f 	dmb	sy
     df4:	4770      	bx	lr

00000df6 <atomic_leave_critical>:
     df6:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
     dfa:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
     dfc:	f383 8810 	msr	PRIMASK, r3
     e00:	4770      	bx	lr
	...

00000e04 <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
     e04:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
     e06:	4b04      	ldr	r3, [pc, #16]	; (e18 <delay_ms+0x14>)
     e08:	681c      	ldr	r4, [r3, #0]
     e0a:	4b04      	ldr	r3, [pc, #16]	; (e1c <delay_ms+0x18>)
     e0c:	4798      	blx	r3
     e0e:	4601      	mov	r1, r0
     e10:	4620      	mov	r0, r4
     e12:	4b03      	ldr	r3, [pc, #12]	; (e20 <delay_ms+0x1c>)
     e14:	4798      	blx	r3
     e16:	bd10      	pop	{r4, pc}
     e18:	2000019c 	.word	0x2000019c
     e1c:	000018ad 	.word	0x000018ad
     e20:	000018cd 	.word	0x000018cd

00000e24 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     e24:	b570      	push	{r4, r5, r6, lr}
     e26:	460d      	mov	r5, r1
     e28:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
     e2a:	4604      	mov	r4, r0
     e2c:	b160      	cbz	r0, e48 <io_write+0x24>
     e2e:	1c08      	adds	r0, r1, #0
     e30:	bf18      	it	ne
     e32:	2001      	movne	r0, #1
     e34:	2234      	movs	r2, #52	; 0x34
     e36:	4905      	ldr	r1, [pc, #20]	; (e4c <io_write+0x28>)
     e38:	4b05      	ldr	r3, [pc, #20]	; (e50 <io_write+0x2c>)
     e3a:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
     e3c:	6823      	ldr	r3, [r4, #0]
     e3e:	4632      	mov	r2, r6
     e40:	4629      	mov	r1, r5
     e42:	4620      	mov	r0, r4
     e44:	4798      	blx	r3
}
     e46:	bd70      	pop	{r4, r5, r6, pc}
     e48:	2000      	movs	r0, #0
     e4a:	e7f3      	b.n	e34 <io_write+0x10>
     e4c:	0000a918 	.word	0x0000a918
     e50:	000016f5 	.word	0x000016f5

00000e54 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
     e54:	b570      	push	{r4, r5, r6, lr}
     e56:	460d      	mov	r5, r1
     e58:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
     e5a:	4604      	mov	r4, r0
     e5c:	b160      	cbz	r0, e78 <io_read+0x24>
     e5e:	1c08      	adds	r0, r1, #0
     e60:	bf18      	it	ne
     e62:	2001      	movne	r0, #1
     e64:	223d      	movs	r2, #61	; 0x3d
     e66:	4905      	ldr	r1, [pc, #20]	; (e7c <io_read+0x28>)
     e68:	4b05      	ldr	r3, [pc, #20]	; (e80 <io_read+0x2c>)
     e6a:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
     e6c:	6863      	ldr	r3, [r4, #4]
     e6e:	4632      	mov	r2, r6
     e70:	4629      	mov	r1, r5
     e72:	4620      	mov	r0, r4
     e74:	4798      	blx	r3
}
     e76:	bd70      	pop	{r4, r5, r6, pc}
     e78:	2000      	movs	r0, #0
     e7a:	e7f3      	b.n	e64 <io_read+0x10>
     e7c:	0000a918 	.word	0x0000a918
     e80:	000016f5 	.word	0x000016f5

00000e84 <mac_read_cb>:
 * \internal data receivced handler
 *
 * \param[in] dev The pointer to MAC device structure
 */
static void mac_read_cb(struct _mac_async_device *dev)
{
     e84:	b508      	push	{r3, lr}
	struct mac_async_descriptor *const descr = CONTAINER_OF(dev, struct mac_async_descriptor, dev);

	if (descr->cb.receive) {
     e86:	6943      	ldr	r3, [r0, #20]
     e88:	b103      	cbz	r3, e8c <mac_read_cb+0x8>
		descr->cb.receive(descr);
     e8a:	4798      	blx	r3
     e8c:	bd08      	pop	{r3, pc}

00000e8e <mac_write_cb>:
 * \internal data transmit handler
 *
 * \param[in] dev The pointer to MAC device structure
 */
static void mac_write_cb(struct _mac_async_device *dev)
{
     e8e:	b508      	push	{r3, lr}
	struct mac_async_descriptor *const descr = CONTAINER_OF(dev, struct mac_async_descriptor, dev);

	if (descr->cb.transmit) {
     e90:	6983      	ldr	r3, [r0, #24]
     e92:	b103      	cbz	r3, e96 <mac_write_cb+0x8>
		descr->cb.transmit(descr);
     e94:	4798      	blx	r3
     e96:	bd08      	pop	{r3, pc}

00000e98 <mac_async_init>:
{
     e98:	b538      	push	{r3, r4, r5, lr}
     e9a:	460c      	mov	r4, r1
	ASSERT(descr && hw);
     e9c:	4605      	mov	r5, r0
     e9e:	b158      	cbz	r0, eb8 <mac_async_init+0x20>
     ea0:	1c08      	adds	r0, r1, #0
     ea2:	bf18      	it	ne
     ea4:	2001      	movne	r0, #1
     ea6:	2231      	movs	r2, #49	; 0x31
     ea8:	4904      	ldr	r1, [pc, #16]	; (ebc <mac_async_init+0x24>)
     eaa:	4b05      	ldr	r3, [pc, #20]	; (ec0 <mac_async_init+0x28>)
     eac:	4798      	blx	r3
	return _mac_async_init(&descr->dev, hw);
     eae:	4621      	mov	r1, r4
     eb0:	4628      	mov	r0, r5
     eb2:	4b04      	ldr	r3, [pc, #16]	; (ec4 <mac_async_init+0x2c>)
     eb4:	4798      	blx	r3
}
     eb6:	bd38      	pop	{r3, r4, r5, pc}
     eb8:	2000      	movs	r0, #0
     eba:	e7f4      	b.n	ea6 <mac_async_init+0xe>
     ebc:	0000a92c 	.word	0x0000a92c
     ec0:	000016f5 	.word	0x000016f5
     ec4:	000019e9 	.word	0x000019e9

00000ec8 <mac_async_enable>:
{
     ec8:	b510      	push	{r4, lr}
	ASSERT(descr);
     eca:	4604      	mov	r4, r0
     ecc:	2245      	movs	r2, #69	; 0x45
     ece:	4905      	ldr	r1, [pc, #20]	; (ee4 <mac_async_enable+0x1c>)
     ed0:	3000      	adds	r0, #0
     ed2:	bf18      	it	ne
     ed4:	2001      	movne	r0, #1
     ed6:	4b04      	ldr	r3, [pc, #16]	; (ee8 <mac_async_enable+0x20>)
     ed8:	4798      	blx	r3
	return _mac_async_enable(&descr->dev);
     eda:	4620      	mov	r0, r4
     edc:	4b03      	ldr	r3, [pc, #12]	; (eec <mac_async_enable+0x24>)
     ede:	4798      	blx	r3
}
     ee0:	bd10      	pop	{r4, pc}
     ee2:	bf00      	nop
     ee4:	0000a92c 	.word	0x0000a92c
     ee8:	000016f5 	.word	0x000016f5
     eec:	00001ab1 	.word	0x00001ab1

00000ef0 <mac_async_write>:
{
     ef0:	b570      	push	{r4, r5, r6, lr}
     ef2:	460c      	mov	r4, r1
     ef4:	4615      	mov	r5, r2
	ASSERT(descr && buf && len);
     ef6:	4606      	mov	r6, r0
     ef8:	b168      	cbz	r0, f16 <mac_async_write+0x26>
     efa:	b171      	cbz	r1, f1a <mac_async_write+0x2a>
     efc:	1c10      	adds	r0, r2, #0
     efe:	bf18      	it	ne
     f00:	2001      	movne	r0, #1
     f02:	2257      	movs	r2, #87	; 0x57
     f04:	4906      	ldr	r1, [pc, #24]	; (f20 <mac_async_write+0x30>)
     f06:	4b07      	ldr	r3, [pc, #28]	; (f24 <mac_async_write+0x34>)
     f08:	4798      	blx	r3
	return _mac_async_write(&descr->dev, buf, len);
     f0a:	462a      	mov	r2, r5
     f0c:	4621      	mov	r1, r4
     f0e:	4630      	mov	r0, r6
     f10:	4b05      	ldr	r3, [pc, #20]	; (f28 <mac_async_write+0x38>)
     f12:	4798      	blx	r3
}
     f14:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && len);
     f16:	2000      	movs	r0, #0
     f18:	e7f3      	b.n	f02 <mac_async_write+0x12>
     f1a:	2000      	movs	r0, #0
     f1c:	e7f1      	b.n	f02 <mac_async_write+0x12>
     f1e:	bf00      	nop
     f20:	0000a92c 	.word	0x0000a92c
     f24:	000016f5 	.word	0x000016f5
     f28:	00001ac1 	.word	0x00001ac1

00000f2c <mac_async_read>:
{
     f2c:	b570      	push	{r4, r5, r6, lr}
     f2e:	460d      	mov	r5, r1
     f30:	4616      	mov	r6, r2
	ASSERT(descr);
     f32:	4604      	mov	r4, r0
     f34:	2261      	movs	r2, #97	; 0x61
     f36:	4906      	ldr	r1, [pc, #24]	; (f50 <mac_async_read+0x24>)
     f38:	3000      	adds	r0, #0
     f3a:	bf18      	it	ne
     f3c:	2001      	movne	r0, #1
     f3e:	4b05      	ldr	r3, [pc, #20]	; (f54 <mac_async_read+0x28>)
     f40:	4798      	blx	r3
	return _mac_async_read(&descr->dev, buf, len);
     f42:	4632      	mov	r2, r6
     f44:	4629      	mov	r1, r5
     f46:	4620      	mov	r0, r4
     f48:	4b03      	ldr	r3, [pc, #12]	; (f58 <mac_async_read+0x2c>)
     f4a:	4798      	blx	r3
}
     f4c:	bd70      	pop	{r4, r5, r6, pc}
     f4e:	bf00      	nop
     f50:	0000a92c 	.word	0x0000a92c
     f54:	000016f5 	.word	0x000016f5
     f58:	00001bf9 	.word	0x00001bf9

00000f5c <mac_async_read_len>:
{
     f5c:	b510      	push	{r4, lr}
	ASSERT(descr);
     f5e:	4604      	mov	r4, r0
     f60:	226b      	movs	r2, #107	; 0x6b
     f62:	4905      	ldr	r1, [pc, #20]	; (f78 <mac_async_read_len+0x1c>)
     f64:	3000      	adds	r0, #0
     f66:	bf18      	it	ne
     f68:	2001      	movne	r0, #1
     f6a:	4b04      	ldr	r3, [pc, #16]	; (f7c <mac_async_read_len+0x20>)
     f6c:	4798      	blx	r3
	return _mac_async_read_len(&descr->dev);
     f6e:	4620      	mov	r0, r4
     f70:	4b03      	ldr	r3, [pc, #12]	; (f80 <mac_async_read_len+0x24>)
     f72:	4798      	blx	r3
}
     f74:	bd10      	pop	{r4, pc}
     f76:	bf00      	nop
     f78:	0000a92c 	.word	0x0000a92c
     f7c:	000016f5 	.word	0x000016f5
     f80:	00001d2d 	.word	0x00001d2d

00000f84 <mac_async_register_callback>:
{
     f84:	b570      	push	{r4, r5, r6, lr}
     f86:	460c      	mov	r4, r1
     f88:	4616      	mov	r6, r2
	ASSERT(descr);
     f8a:	4605      	mov	r5, r0
     f8c:	2289      	movs	r2, #137	; 0x89
     f8e:	4910      	ldr	r1, [pc, #64]	; (fd0 <mac_async_register_callback+0x4c>)
     f90:	3000      	adds	r0, #0
     f92:	bf18      	it	ne
     f94:	2001      	movne	r0, #1
     f96:	4b0f      	ldr	r3, [pc, #60]	; (fd4 <mac_async_register_callback+0x50>)
     f98:	4798      	blx	r3
	switch (type) {
     f9a:	b124      	cbz	r4, fa6 <mac_async_register_callback+0x22>
     f9c:	2c01      	cmp	r4, #1
     f9e:	d00c      	beq.n	fba <mac_async_register_callback+0x36>
		return ERR_INVALID_ARG;
     fa0:	f06f 000c 	mvn.w	r0, #12
}
     fa4:	bd70      	pop	{r4, r5, r6, pc}
		descr->cb.receive = (mac_async_cb_t)func;
     fa6:	616e      	str	r6, [r5, #20]
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_read_cb);
     fa8:	2e00      	cmp	r6, #0
     faa:	4a0b      	ldr	r2, [pc, #44]	; (fd8 <mac_async_register_callback+0x54>)
     fac:	bf08      	it	eq
     fae:	2200      	moveq	r2, #0
     fb0:	2100      	movs	r1, #0
     fb2:	4628      	mov	r0, r5
     fb4:	4b09      	ldr	r3, [pc, #36]	; (fdc <mac_async_register_callback+0x58>)
     fb6:	4798      	blx	r3
     fb8:	bd70      	pop	{r4, r5, r6, pc}
		descr->cb.transmit = (mac_async_cb_t)func;
     fba:	61ae      	str	r6, [r5, #24]
		return _mac_async_register_callback(&descr->dev, type, (func == NULL) ? NULL : (FUNC_PTR)mac_write_cb);
     fbc:	2e00      	cmp	r6, #0
     fbe:	4a08      	ldr	r2, [pc, #32]	; (fe0 <mac_async_register_callback+0x5c>)
     fc0:	bf08      	it	eq
     fc2:	2200      	moveq	r2, #0
     fc4:	2101      	movs	r1, #1
     fc6:	4628      	mov	r0, r5
     fc8:	4b04      	ldr	r3, [pc, #16]	; (fdc <mac_async_register_callback+0x58>)
     fca:	4798      	blx	r3
     fcc:	bd70      	pop	{r4, r5, r6, pc}
     fce:	bf00      	nop
     fd0:	0000a92c 	.word	0x0000a92c
     fd4:	000016f5 	.word	0x000016f5
     fd8:	00000e85 	.word	0x00000e85
     fdc:	00001d95 	.word	0x00001d95
     fe0:	00000e8f 	.word	0x00000e8f

00000fe4 <mac_async_set_filter>:
{
     fe4:	b570      	push	{r4, r5, r6, lr}
     fe6:	460e      	mov	r6, r1
     fe8:	4614      	mov	r4, r2
	ASSERT(descr && filter);
     fea:	4605      	mov	r5, r0
     fec:	b160      	cbz	r0, 1008 <mac_async_set_filter+0x24>
     fee:	1c10      	adds	r0, r2, #0
     ff0:	bf18      	it	ne
     ff2:	2001      	movne	r0, #1
     ff4:	229b      	movs	r2, #155	; 0x9b
     ff6:	4905      	ldr	r1, [pc, #20]	; (100c <mac_async_set_filter+0x28>)
     ff8:	4b05      	ldr	r3, [pc, #20]	; (1010 <mac_async_set_filter+0x2c>)
     ffa:	4798      	blx	r3
	return _mac_async_set_filter(&descr->dev, index, filter);
     ffc:	4622      	mov	r2, r4
     ffe:	4631      	mov	r1, r6
    1000:	4628      	mov	r0, r5
    1002:	4b04      	ldr	r3, [pc, #16]	; (1014 <mac_async_set_filter+0x30>)
    1004:	4798      	blx	r3
}
    1006:	bd70      	pop	{r4, r5, r6, pc}
    1008:	2000      	movs	r0, #0
    100a:	e7f3      	b.n	ff4 <mac_async_set_filter+0x10>
    100c:	0000a92c 	.word	0x0000a92c
    1010:	000016f5 	.word	0x000016f5
    1014:	00001dc5 	.word	0x00001dc5

00001018 <mac_async_write_phy_reg>:
{
    1018:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    101a:	460d      	mov	r5, r1
    101c:	4616      	mov	r6, r2
    101e:	461f      	mov	r7, r3
	ASSERT(descr);
    1020:	4604      	mov	r4, r0
    1022:	22af      	movs	r2, #175	; 0xaf
    1024:	4906      	ldr	r1, [pc, #24]	; (1040 <mac_async_write_phy_reg+0x28>)
    1026:	3000      	adds	r0, #0
    1028:	bf18      	it	ne
    102a:	2001      	movne	r0, #1
    102c:	4b05      	ldr	r3, [pc, #20]	; (1044 <mac_async_write_phy_reg+0x2c>)
    102e:	4798      	blx	r3
	return _mac_async_write_phy_reg(&descr->dev, addr, reg, val);
    1030:	463b      	mov	r3, r7
    1032:	4632      	mov	r2, r6
    1034:	4629      	mov	r1, r5
    1036:	4620      	mov	r0, r4
    1038:	4c03      	ldr	r4, [pc, #12]	; (1048 <mac_async_write_phy_reg+0x30>)
    103a:	47a0      	blx	r4
}
    103c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    103e:	bf00      	nop
    1040:	0000a92c 	.word	0x0000a92c
    1044:	000016f5 	.word	0x000016f5
    1048:	00001e0d 	.word	0x00001e0d

0000104c <mac_async_read_phy_reg>:
{
    104c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    104e:	460e      	mov	r6, r1
    1050:	4617      	mov	r7, r2
    1052:	461c      	mov	r4, r3
	ASSERT(descr && val);
    1054:	4605      	mov	r5, r0
    1056:	b168      	cbz	r0, 1074 <mac_async_read_phy_reg+0x28>
    1058:	1c18      	adds	r0, r3, #0
    105a:	bf18      	it	ne
    105c:	2001      	movne	r0, #1
    105e:	22b8      	movs	r2, #184	; 0xb8
    1060:	4905      	ldr	r1, [pc, #20]	; (1078 <mac_async_read_phy_reg+0x2c>)
    1062:	4b06      	ldr	r3, [pc, #24]	; (107c <mac_async_read_phy_reg+0x30>)
    1064:	4798      	blx	r3
	return _mac_async_read_phy_reg(&descr->dev, addr, reg, val);
    1066:	4623      	mov	r3, r4
    1068:	463a      	mov	r2, r7
    106a:	4631      	mov	r1, r6
    106c:	4628      	mov	r0, r5
    106e:	4c04      	ldr	r4, [pc, #16]	; (1080 <mac_async_read_phy_reg+0x34>)
    1070:	47a0      	blx	r4
}
    1072:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1074:	2000      	movs	r0, #0
    1076:	e7f2      	b.n	105e <mac_async_read_phy_reg+0x12>
    1078:	0000a92c 	.word	0x0000a92c
    107c:	000016f5 	.word	0x000016f5
    1080:	00001e4d 	.word	0x00001e4d

00001084 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
    1084:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1086:	4684      	mov	ip, r0
 * \return A pointer to the head of the given list or NULL if the list is
 * empty
 */
static inline void *list_get_head(const struct list_descriptor *const list)
{
	return (void *)list->head;
    1088:	6807      	ldr	r7, [r0, #0]
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);

	if (!head) {
    108a:	b12f      	cbz	r7, 1098 <timer_add_timer_task+0x14>
		if (it->time_label <= time) {
			time_left = it->interval - (time - it->time_label);
		} else {
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
		}
		if (time_left >= new_task->interval)
    108c:	688d      	ldr	r5, [r1, #8]
    108e:	463c      	mov	r4, r7
    1090:	2600      	movs	r6, #0
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    1092:	f1c2 0e01 	rsb	lr, r2, #1
    1096:	e00b      	b.n	10b0 <timer_add_timer_task+0x2c>
		list_insert_as_head(list, new_task);
    1098:	4b0e      	ldr	r3, [pc, #56]	; (10d4 <timer_add_timer_task+0x50>)
    109a:	4798      	blx	r3
		return;
    109c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    109e:	4473      	add	r3, lr
    10a0:	68a0      	ldr	r0, [r4, #8]
    10a2:	4403      	add	r3, r0
		if (time_left >= new_task->interval)
    10a4:	42ab      	cmp	r3, r5
    10a6:	d20a      	bcs.n	10be <timer_add_timer_task+0x3a>
 * \return A pointer to the next list element or NULL if there is not next
 * element
 */
static inline void *list_get_next_element(const void *const element)
{
	return element ? ((struct list_element *)element)->next : NULL;
    10a8:	6823      	ldr	r3, [r4, #0]
    10aa:	4626      	mov	r6, r4
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
    10ac:	b153      	cbz	r3, 10c4 <timer_add_timer_task+0x40>
    10ae:	461c      	mov	r4, r3
		if (it->time_label <= time) {
    10b0:	6863      	ldr	r3, [r4, #4]
    10b2:	4293      	cmp	r3, r2
    10b4:	d8f3      	bhi.n	109e <timer_add_timer_task+0x1a>
			time_left = it->interval - (time - it->time_label);
    10b6:	68a0      	ldr	r0, [r4, #8]
    10b8:	4403      	add	r3, r0
    10ba:	1a9b      	subs	r3, r3, r2
    10bc:	e7f2      	b.n	10a4 <timer_add_timer_task+0x20>
			break;
		prev = it;
	}

	if (it == head) {
    10be:	42a7      	cmp	r7, r4
    10c0:	d004      	beq.n	10cc <timer_add_timer_task+0x48>
    10c2:	4634      	mov	r4, r6
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
    10c4:	4620      	mov	r0, r4
    10c6:	4b04      	ldr	r3, [pc, #16]	; (10d8 <timer_add_timer_task+0x54>)
    10c8:	4798      	blx	r3
    10ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		list_insert_as_head(list, new_task);
    10cc:	4660      	mov	r0, ip
    10ce:	4b01      	ldr	r3, [pc, #4]	; (10d4 <timer_add_timer_task+0x50>)
    10d0:	4798      	blx	r3
    10d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    10d4:	0000171d 	.word	0x0000171d
    10d8:	00001749 	.word	0x00001749

000010dc <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
    10dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return (void *)list->head;
    10e0:	6944      	ldr	r4, [r0, #20]
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
    10e2:	6907      	ldr	r7, [r0, #16]
    10e4:	3701      	adds	r7, #1
    10e6:	6107      	str	r7, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    10e8:	7e03      	ldrb	r3, [r0, #24]
    10ea:	f013 0f01 	tst.w	r3, #1
    10ee:	d113      	bne.n	1118 <timer_process_counted+0x3c>
    10f0:	7e03      	ldrb	r3, [r0, #24]
    10f2:	f013 0f02 	tst.w	r3, #2
    10f6:	d10f      	bne.n	1118 <timer_process_counted+0x3c>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
		return;
	}

	while (it && ((time - it->time_label) >= it->interval)) {
    10f8:	b354      	cbz	r4, 1150 <timer_process_counted+0x74>
    10fa:	6863      	ldr	r3, [r4, #4]
    10fc:	1afb      	subs	r3, r7, r3
    10fe:	68a2      	ldr	r2, [r4, #8]
    1100:	4293      	cmp	r3, r2
    1102:	d307      	bcc.n	1114 <timer_process_counted+0x38>
    1104:	4606      	mov	r6, r0
		struct timer_task *tmp = it;

		list_remove_head(&timer->tasks);
    1106:	f100 0814 	add.w	r8, r0, #20
    110a:	f8df 9048 	ldr.w	r9, [pc, #72]	; 1154 <timer_process_counted+0x78>
		if (TIMER_TASK_REPEAT == tmp->mode) {
			tmp->time_label = time;
			timer_add_timer_task(&timer->tasks, tmp, time);
    110e:	f8df a048 	ldr.w	sl, [pc, #72]	; 1158 <timer_process_counted+0x7c>
    1112:	e012      	b.n	113a <timer_process_counted+0x5e>
    1114:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
    1118:	7e03      	ldrb	r3, [r0, #24]
    111a:	f043 0302 	orr.w	r3, r3, #2
    111e:	7603      	strb	r3, [r0, #24]
		return;
    1120:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1124:	6975      	ldr	r5, [r6, #20]
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);

		tmp->cb(tmp);
    1126:	68e3      	ldr	r3, [r4, #12]
    1128:	4620      	mov	r0, r4
    112a:	4798      	blx	r3
	while (it && ((time - it->time_label) >= it->interval)) {
    112c:	b185      	cbz	r5, 1150 <timer_process_counted+0x74>
		it = (struct timer_task *)list_get_head(&timer->tasks);
    112e:	462c      	mov	r4, r5
	while (it && ((time - it->time_label) >= it->interval)) {
    1130:	686b      	ldr	r3, [r5, #4]
    1132:	1afb      	subs	r3, r7, r3
    1134:	68aa      	ldr	r2, [r5, #8]
    1136:	4293      	cmp	r3, r2
    1138:	d30a      	bcc.n	1150 <timer_process_counted+0x74>
		list_remove_head(&timer->tasks);
    113a:	4640      	mov	r0, r8
    113c:	47c8      	blx	r9
		if (TIMER_TASK_REPEAT == tmp->mode) {
    113e:	7c23      	ldrb	r3, [r4, #16]
    1140:	2b01      	cmp	r3, #1
    1142:	d1ef      	bne.n	1124 <timer_process_counted+0x48>
			tmp->time_label = time;
    1144:	6067      	str	r7, [r4, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
    1146:	463a      	mov	r2, r7
    1148:	4621      	mov	r1, r4
    114a:	4640      	mov	r0, r8
    114c:	47d0      	blx	sl
    114e:	e7e9      	b.n	1124 <timer_process_counted+0x48>
    1150:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1154:	00001751 	.word	0x00001751
    1158:	00001085 	.word	0x00001085

0000115c <timer_init>:
{
    115c:	b538      	push	{r3, r4, r5, lr}
    115e:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    1160:	4604      	mov	r4, r0
    1162:	b178      	cbz	r0, 1184 <timer_init+0x28>
    1164:	1c08      	adds	r0, r1, #0
    1166:	bf18      	it	ne
    1168:	2001      	movne	r0, #1
    116a:	223b      	movs	r2, #59	; 0x3b
    116c:	4906      	ldr	r1, [pc, #24]	; (1188 <timer_init+0x2c>)
    116e:	4b07      	ldr	r3, [pc, #28]	; (118c <timer_init+0x30>)
    1170:	4798      	blx	r3
	_timer_init(&descr->device, hw);
    1172:	4629      	mov	r1, r5
    1174:	4620      	mov	r0, r4
    1176:	4b06      	ldr	r3, [pc, #24]	; (1190 <timer_init+0x34>)
    1178:	4798      	blx	r3
	descr->time                           = 0;
    117a:	2000      	movs	r0, #0
    117c:	6120      	str	r0, [r4, #16]
	descr->device.timer_cb.period_expired = timer_process_counted;
    117e:	4b05      	ldr	r3, [pc, #20]	; (1194 <timer_init+0x38>)
    1180:	6023      	str	r3, [r4, #0]
}
    1182:	bd38      	pop	{r3, r4, r5, pc}
    1184:	2000      	movs	r0, #0
    1186:	e7f0      	b.n	116a <timer_init+0xe>
    1188:	0000a948 	.word	0x0000a948
    118c:	000016f5 	.word	0x000016f5
    1190:	00002385 	.word	0x00002385
    1194:	000010dd 	.word	0x000010dd

00001198 <timer_start>:
{
    1198:	b510      	push	{r4, lr}
	ASSERT(descr);
    119a:	4604      	mov	r4, r0
    119c:	2253      	movs	r2, #83	; 0x53
    119e:	4909      	ldr	r1, [pc, #36]	; (11c4 <timer_start+0x2c>)
    11a0:	3000      	adds	r0, #0
    11a2:	bf18      	it	ne
    11a4:	2001      	movne	r0, #1
    11a6:	4b08      	ldr	r3, [pc, #32]	; (11c8 <timer_start+0x30>)
    11a8:	4798      	blx	r3
	if (_timer_is_started(&descr->device)) {
    11aa:	4620      	mov	r0, r4
    11ac:	4b07      	ldr	r3, [pc, #28]	; (11cc <timer_start+0x34>)
    11ae:	4798      	blx	r3
    11b0:	b920      	cbnz	r0, 11bc <timer_start+0x24>
	_timer_start(&descr->device);
    11b2:	4620      	mov	r0, r4
    11b4:	4b06      	ldr	r3, [pc, #24]	; (11d0 <timer_start+0x38>)
    11b6:	4798      	blx	r3
	return ERR_NONE;
    11b8:	2000      	movs	r0, #0
    11ba:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    11bc:	f06f 0010 	mvn.w	r0, #16
}
    11c0:	bd10      	pop	{r4, pc}
    11c2:	bf00      	nop
    11c4:	0000a948 	.word	0x0000a948
    11c8:	000016f5 	.word	0x000016f5
    11cc:	00002541 	.word	0x00002541
    11d0:	0000252d 	.word	0x0000252d

000011d4 <timer_add_task>:
{
    11d4:	b570      	push	{r4, r5, r6, lr}
    11d6:	b082      	sub	sp, #8
    11d8:	460d      	mov	r5, r1
	ASSERT(descr && task);
    11da:	4604      	mov	r4, r0
    11dc:	b318      	cbz	r0, 1226 <timer_add_task+0x52>
    11de:	1c08      	adds	r0, r1, #0
    11e0:	bf18      	it	ne
    11e2:	2001      	movne	r0, #1
    11e4:	227a      	movs	r2, #122	; 0x7a
    11e6:	491e      	ldr	r1, [pc, #120]	; (1260 <timer_add_task+0x8c>)
    11e8:	4b1e      	ldr	r3, [pc, #120]	; (1264 <timer_add_task+0x90>)
    11ea:	4798      	blx	r3
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    11ec:	7e23      	ldrb	r3, [r4, #24]
    11ee:	f043 0301 	orr.w	r3, r3, #1
    11f2:	7623      	strb	r3, [r4, #24]
	if (is_list_element(&descr->tasks, task)) {
    11f4:	f104 0614 	add.w	r6, r4, #20
    11f8:	4629      	mov	r1, r5
    11fa:	4630      	mov	r0, r6
    11fc:	4b1a      	ldr	r3, [pc, #104]	; (1268 <timer_add_task+0x94>)
    11fe:	4798      	blx	r3
    1200:	b998      	cbnz	r0, 122a <timer_add_task+0x56>
	task->time_label = descr->time;
    1202:	6923      	ldr	r3, [r4, #16]
    1204:	606b      	str	r3, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    1206:	6922      	ldr	r2, [r4, #16]
    1208:	4629      	mov	r1, r5
    120a:	4630      	mov	r0, r6
    120c:	4b17      	ldr	r3, [pc, #92]	; (126c <timer_add_task+0x98>)
    120e:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    1210:	7e23      	ldrb	r3, [r4, #24]
    1212:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    1216:	7623      	strb	r3, [r4, #24]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
    1218:	7e23      	ldrb	r3, [r4, #24]
    121a:	f013 0f02 	tst.w	r3, #2
    121e:	d110      	bne.n	1242 <timer_add_task+0x6e>
	return ERR_NONE;
    1220:	2000      	movs	r0, #0
}
    1222:	b002      	add	sp, #8
    1224:	bd70      	pop	{r4, r5, r6, pc}
    1226:	2000      	movs	r0, #0
    1228:	e7dc      	b.n	11e4 <timer_add_task+0x10>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    122a:	7e23      	ldrb	r3, [r4, #24]
    122c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    1230:	7623      	strb	r3, [r4, #24]
		ASSERT(false);
    1232:	227f      	movs	r2, #127	; 0x7f
    1234:	490a      	ldr	r1, [pc, #40]	; (1260 <timer_add_task+0x8c>)
    1236:	2000      	movs	r0, #0
    1238:	4b0a      	ldr	r3, [pc, #40]	; (1264 <timer_add_task+0x90>)
    123a:	4798      	blx	r3
		return ERR_ALREADY_INITIALIZED;
    123c:	f06f 0011 	mvn.w	r0, #17
    1240:	e7ef      	b.n	1222 <timer_add_task+0x4e>
		CRITICAL_SECTION_ENTER()
    1242:	a801      	add	r0, sp, #4
    1244:	4b0a      	ldr	r3, [pc, #40]	; (1270 <timer_add_task+0x9c>)
    1246:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    1248:	7e23      	ldrb	r3, [r4, #24]
    124a:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    124e:	7623      	strb	r3, [r4, #24]
		_timer_set_irq(&descr->device);
    1250:	4620      	mov	r0, r4
    1252:	4b08      	ldr	r3, [pc, #32]	; (1274 <timer_add_task+0xa0>)
    1254:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
    1256:	a801      	add	r0, sp, #4
    1258:	4b07      	ldr	r3, [pc, #28]	; (1278 <timer_add_task+0xa4>)
    125a:	4798      	blx	r3
	return ERR_NONE;
    125c:	2000      	movs	r0, #0
    125e:	e7e0      	b.n	1222 <timer_add_task+0x4e>
    1260:	0000a948 	.word	0x0000a948
    1264:	000016f5 	.word	0x000016f5
    1268:	000016fb 	.word	0x000016fb
    126c:	00001085 	.word	0x00001085
    1270:	00000de9 	.word	0x00000de9
    1274:	00002559 	.word	0x00002559
    1278:	00000df7 	.word	0x00000df7

0000127c <usart_transmission_complete>:
 * \brief Process completion of data sending
 *
 * \param[in] device The pointer to device structure
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
    127c:	b508      	push	{r3, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
    127e:	2300      	movs	r3, #0
    1280:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.tx_done) {
    1282:	69c3      	ldr	r3, [r0, #28]
    1284:	b11b      	cbz	r3, 128e <usart_transmission_complete+0x12>
    1286:	f1a0 0208 	sub.w	r2, r0, #8
		descr->usart_cb.tx_done(descr);
    128a:	4610      	mov	r0, r2
    128c:	4798      	blx	r3
    128e:	bd08      	pop	{r3, pc}

00001290 <usart_error>:
 * \brief Process error interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_error(struct _usart_async_device *device)
{
    1290:	b508      	push	{r3, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
    1292:	2300      	movs	r3, #0
    1294:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.error) {
    1296:	6a43      	ldr	r3, [r0, #36]	; 0x24
    1298:	b11b      	cbz	r3, 12a2 <usart_error+0x12>
    129a:	f1a0 0208 	sub.w	r2, r0, #8
		descr->usart_cb.error(descr);
    129e:	4610      	mov	r0, r2
    12a0:	4798      	blx	r3
    12a2:	bd08      	pop	{r3, pc}

000012a4 <usart_fill_rx_buffer>:
{
    12a4:	b538      	push	{r3, r4, r5, lr}
    12a6:	4604      	mov	r4, r0
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
    12a8:	f1a0 0508 	sub.w	r5, r0, #8
	ringbuffer_put(&descr->rx, data);
    12ac:	302c      	adds	r0, #44	; 0x2c
    12ae:	4b03      	ldr	r3, [pc, #12]	; (12bc <usart_fill_rx_buffer+0x18>)
    12b0:	4798      	blx	r3
	if (descr->usart_cb.rx_done) {
    12b2:	6a23      	ldr	r3, [r4, #32]
    12b4:	b10b      	cbz	r3, 12ba <usart_fill_rx_buffer+0x16>
		descr->usart_cb.rx_done(descr);
    12b6:	4628      	mov	r0, r5
    12b8:	4798      	blx	r3
    12ba:	bd38      	pop	{r3, r4, r5, pc}
    12bc:	000017f1 	.word	0x000017f1

000012c0 <usart_async_write>:
{
    12c0:	b570      	push	{r4, r5, r6, lr}
    12c2:	460e      	mov	r6, r1
    12c4:	4615      	mov	r5, r2
	ASSERT(descr && buf && length);
    12c6:	4604      	mov	r4, r0
    12c8:	b1e0      	cbz	r0, 1304 <usart_async_write+0x44>
    12ca:	b1e9      	cbz	r1, 1308 <usart_async_write+0x48>
    12cc:	1c10      	adds	r0, r2, #0
    12ce:	bf18      	it	ne
    12d0:	2001      	movne	r0, #1
    12d2:	f240 123b 	movw	r2, #315	; 0x13b
    12d6:	490f      	ldr	r1, [pc, #60]	; (1314 <usart_async_write+0x54>)
    12d8:	4b0f      	ldr	r3, [pc, #60]	; (1318 <usart_async_write+0x58>)
    12da:	4798      	blx	r3
	if (descr->tx_por != descr->tx_buffer_length) {
    12dc:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
    12e0:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
    12e4:	429a      	cmp	r2, r3
    12e6:	d111      	bne.n	130c <usart_async_write+0x4c>
	descr->tx_buffer        = (uint8_t *)buf;
    12e8:	64a6      	str	r6, [r4, #72]	; 0x48
	descr->tx_buffer_length = length;
    12ea:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
	descr->tx_por           = 0;
    12ee:	2300      	movs	r3, #0
    12f0:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	descr->stat             = USART_ASYNC_STATUS_BUSY;
    12f4:	2301      	movs	r3, #1
    12f6:	6323      	str	r3, [r4, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
    12f8:	f104 0008 	add.w	r0, r4, #8
    12fc:	4b07      	ldr	r3, [pc, #28]	; (131c <usart_async_write+0x5c>)
    12fe:	4798      	blx	r3
	return (int32_t)length;
    1300:	4628      	mov	r0, r5
    1302:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && length);
    1304:	2000      	movs	r0, #0
    1306:	e7e4      	b.n	12d2 <usart_async_write+0x12>
    1308:	2000      	movs	r0, #0
    130a:	e7e2      	b.n	12d2 <usart_async_write+0x12>
		return ERR_NO_RESOURCE;
    130c:	f06f 001b 	mvn.w	r0, #27
}
    1310:	bd70      	pop	{r4, r5, r6, pc}
    1312:	bf00      	nop
    1314:	0000a960 	.word	0x0000a960
    1318:	000016f5 	.word	0x000016f5
    131c:	00002257 	.word	0x00002257

00001320 <usart_process_byte_sent>:
{
    1320:	b510      	push	{r4, lr}
    1322:	4604      	mov	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
    1324:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
    1326:	f8b0 2044 	ldrh.w	r2, [r0, #68]	; 0x44
    132a:	429a      	cmp	r2, r3
    132c:	d009      	beq.n	1342 <usart_process_byte_sent+0x22>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
    132e:	6c02      	ldr	r2, [r0, #64]	; 0x40
    1330:	1c59      	adds	r1, r3, #1
    1332:	8781      	strh	r1, [r0, #60]	; 0x3c
    1334:	5cd1      	ldrb	r1, [r2, r3]
    1336:	4b04      	ldr	r3, [pc, #16]	; (1348 <usart_process_byte_sent+0x28>)
    1338:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
    133a:	4620      	mov	r0, r4
    133c:	4b03      	ldr	r3, [pc, #12]	; (134c <usart_process_byte_sent+0x2c>)
    133e:	4798      	blx	r3
    1340:	bd10      	pop	{r4, pc}
		_usart_async_enable_tx_done_irq(&descr->device);
    1342:	4b03      	ldr	r3, [pc, #12]	; (1350 <usart_process_byte_sent+0x30>)
    1344:	4798      	blx	r3
    1346:	bd10      	pop	{r4, pc}
    1348:	0000222b 	.word	0x0000222b
    134c:	00002257 	.word	0x00002257
    1350:	0000225f 	.word	0x0000225f

00001354 <usart_async_read>:
{
    1354:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1358:	b082      	sub	sp, #8
    135a:	460f      	mov	r7, r1
    135c:	4690      	mov	r8, r2
	ASSERT(descr && buf && length);
    135e:	4606      	mov	r6, r0
    1360:	b1a0      	cbz	r0, 138c <usart_async_read+0x38>
    1362:	b199      	cbz	r1, 138c <usart_async_read+0x38>
    1364:	2a00      	cmp	r2, #0
    1366:	d12d      	bne.n	13c4 <usart_async_read+0x70>
    1368:	f44f 72ac 	mov.w	r2, #344	; 0x158
    136c:	4929      	ldr	r1, [pc, #164]	; (1414 <usart_async_read+0xc0>)
    136e:	2000      	movs	r0, #0
    1370:	4b29      	ldr	r3, [pc, #164]	; (1418 <usart_async_read+0xc4>)
    1372:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
    1374:	a801      	add	r0, sp, #4
    1376:	4b29      	ldr	r3, [pc, #164]	; (141c <usart_async_read+0xc8>)
    1378:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
    137a:	f106 0034 	add.w	r0, r6, #52	; 0x34
    137e:	4b28      	ldr	r3, [pc, #160]	; (1420 <usart_async_read+0xcc>)
    1380:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
    1382:	a801      	add	r0, sp, #4
    1384:	4b27      	ldr	r3, [pc, #156]	; (1424 <usart_async_read+0xd0>)
    1386:	4798      	blx	r3
	uint16_t                       was_read = 0;
    1388:	2500      	movs	r5, #0
	return (int32_t)was_read;
    138a:	e03e      	b.n	140a <usart_async_read+0xb6>
	ASSERT(descr && buf && length);
    138c:	f44f 72ac 	mov.w	r2, #344	; 0x158
    1390:	4920      	ldr	r1, [pc, #128]	; (1414 <usart_async_read+0xc0>)
    1392:	2000      	movs	r0, #0
    1394:	4b20      	ldr	r3, [pc, #128]	; (1418 <usart_async_read+0xc4>)
    1396:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
    1398:	a801      	add	r0, sp, #4
    139a:	4b20      	ldr	r3, [pc, #128]	; (141c <usart_async_read+0xc8>)
    139c:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
    139e:	f106 0a34 	add.w	sl, r6, #52	; 0x34
    13a2:	4650      	mov	r0, sl
    13a4:	4b1e      	ldr	r3, [pc, #120]	; (1420 <usart_async_read+0xcc>)
    13a6:	4798      	blx	r3
    13a8:	4681      	mov	r9, r0
	CRITICAL_SECTION_LEAVE()
    13aa:	a801      	add	r0, sp, #4
    13ac:	4b1d      	ldr	r3, [pc, #116]	; (1424 <usart_async_read+0xd0>)
    13ae:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
    13b0:	f1b9 0f00 	cmp.w	r9, #0
    13b4:	d004      	beq.n	13c0 <usart_async_read+0x6c>
    13b6:	f1b8 0f00 	cmp.w	r8, #0
    13ba:	d119      	bne.n	13f0 <usart_async_read+0x9c>
	uint16_t                       was_read = 0;
    13bc:	2500      	movs	r5, #0
    13be:	e024      	b.n	140a <usart_async_read+0xb6>
    13c0:	2500      	movs	r5, #0
    13c2:	e022      	b.n	140a <usart_async_read+0xb6>
	ASSERT(descr && buf && length);
    13c4:	f44f 72ac 	mov.w	r2, #344	; 0x158
    13c8:	4912      	ldr	r1, [pc, #72]	; (1414 <usart_async_read+0xc0>)
    13ca:	2001      	movs	r0, #1
    13cc:	4b12      	ldr	r3, [pc, #72]	; (1418 <usart_async_read+0xc4>)
    13ce:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
    13d0:	a801      	add	r0, sp, #4
    13d2:	4b12      	ldr	r3, [pc, #72]	; (141c <usart_async_read+0xc8>)
    13d4:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
    13d6:	f106 0a34 	add.w	sl, r6, #52	; 0x34
    13da:	4650      	mov	r0, sl
    13dc:	4b10      	ldr	r3, [pc, #64]	; (1420 <usart_async_read+0xcc>)
    13de:	4798      	blx	r3
    13e0:	4681      	mov	r9, r0
	CRITICAL_SECTION_LEAVE()
    13e2:	a801      	add	r0, sp, #4
    13e4:	4b0f      	ldr	r3, [pc, #60]	; (1424 <usart_async_read+0xd0>)
    13e6:	4798      	blx	r3
	uint16_t                       was_read = 0;
    13e8:	2500      	movs	r5, #0
	while ((was_read < num) && (was_read < length)) {
    13ea:	f1b9 0f00 	cmp.w	r9, #0
    13ee:	d00c      	beq.n	140a <usart_async_read+0xb6>
{
    13f0:	2400      	movs	r4, #0
		ringbuffer_get(&descr->rx, &buf[was_read++]);
    13f2:	4e0d      	ldr	r6, [pc, #52]	; (1428 <usart_async_read+0xd4>)
    13f4:	1c60      	adds	r0, r4, #1
    13f6:	b285      	uxth	r5, r0
    13f8:	1939      	adds	r1, r7, r4
    13fa:	4650      	mov	r0, sl
    13fc:	47b0      	blx	r6
    13fe:	3401      	adds	r4, #1
	while ((was_read < num) && (was_read < length)) {
    1400:	454c      	cmp	r4, r9
    1402:	d202      	bcs.n	140a <usart_async_read+0xb6>
    1404:	b2a3      	uxth	r3, r4
    1406:	4598      	cmp	r8, r3
    1408:	d8f4      	bhi.n	13f4 <usart_async_read+0xa0>
}
    140a:	4628      	mov	r0, r5
    140c:	b002      	add	sp, #8
    140e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1412:	bf00      	nop
    1414:	0000a960 	.word	0x0000a960
    1418:	000016f5 	.word	0x000016f5
    141c:	00000de9 	.word	0x00000de9
    1420:	00001831 	.word	0x00001831
    1424:	00000df7 	.word	0x00000df7
    1428:	000017ad 	.word	0x000017ad

0000142c <usart_async_init>:
{
    142c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    142e:	460d      	mov	r5, r1
    1430:	4616      	mov	r6, r2
    1432:	461f      	mov	r7, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
    1434:	4604      	mov	r4, r0
    1436:	b320      	cbz	r0, 1482 <usart_async_init+0x56>
    1438:	b329      	cbz	r1, 1486 <usart_async_init+0x5a>
    143a:	b332      	cbz	r2, 148a <usart_async_init+0x5e>
    143c:	1c18      	adds	r0, r3, #0
    143e:	bf18      	it	ne
    1440:	2001      	movne	r0, #1
    1442:	223a      	movs	r2, #58	; 0x3a
    1444:	4913      	ldr	r1, [pc, #76]	; (1494 <usart_async_init+0x68>)
    1446:	4b14      	ldr	r3, [pc, #80]	; (1498 <usart_async_init+0x6c>)
    1448:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
    144a:	463a      	mov	r2, r7
    144c:	4631      	mov	r1, r6
    144e:	f104 0034 	add.w	r0, r4, #52	; 0x34
    1452:	4b12      	ldr	r3, [pc, #72]	; (149c <usart_async_init+0x70>)
    1454:	4798      	blx	r3
    1456:	b9d0      	cbnz	r0, 148e <usart_async_init+0x62>
	init_status = _usart_async_init(&descr->device, hw);
    1458:	4629      	mov	r1, r5
    145a:	f104 0008 	add.w	r0, r4, #8
    145e:	4b10      	ldr	r3, [pc, #64]	; (14a0 <usart_async_init+0x74>)
    1460:	4798      	blx	r3
	if (init_status) {
    1462:	4603      	mov	r3, r0
    1464:	b958      	cbnz	r0, 147e <usart_async_init+0x52>
	descr->io.read  = usart_async_read;
    1466:	4a0f      	ldr	r2, [pc, #60]	; (14a4 <usart_async_init+0x78>)
    1468:	6062      	str	r2, [r4, #4]
	descr->io.write = usart_async_write;
    146a:	4a0f      	ldr	r2, [pc, #60]	; (14a8 <usart_async_init+0x7c>)
    146c:	6022      	str	r2, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
    146e:	4a0f      	ldr	r2, [pc, #60]	; (14ac <usart_async_init+0x80>)
    1470:	60a2      	str	r2, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
    1472:	4a0f      	ldr	r2, [pc, #60]	; (14b0 <usart_async_init+0x84>)
    1474:	60e2      	str	r2, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
    1476:	4a0f      	ldr	r2, [pc, #60]	; (14b4 <usart_async_init+0x88>)
    1478:	6122      	str	r2, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_error;
    147a:	4a0f      	ldr	r2, [pc, #60]	; (14b8 <usart_async_init+0x8c>)
    147c:	6162      	str	r2, [r4, #20]
}
    147e:	4618      	mov	r0, r3
    1480:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
    1482:	2000      	movs	r0, #0
    1484:	e7dd      	b.n	1442 <usart_async_init+0x16>
    1486:	2000      	movs	r0, #0
    1488:	e7db      	b.n	1442 <usart_async_init+0x16>
    148a:	2000      	movs	r0, #0
    148c:	e7d9      	b.n	1442 <usart_async_init+0x16>
		return ERR_INVALID_ARG;
    148e:	f06f 030c 	mvn.w	r3, #12
    1492:	e7f4      	b.n	147e <usart_async_init+0x52>
    1494:	0000a960 	.word	0x0000a960
    1498:	000016f5 	.word	0x000016f5
    149c:	0000175d 	.word	0x0000175d
    14a0:	00002179 	.word	0x00002179
    14a4:	00001355 	.word	0x00001355
    14a8:	000012c1 	.word	0x000012c1
    14ac:	00001321 	.word	0x00001321
    14b0:	000012a5 	.word	0x000012a5
    14b4:	0000127d 	.word	0x0000127d
    14b8:	00001291 	.word	0x00001291

000014bc <usart_async_enable>:
{
    14bc:	b510      	push	{r4, lr}
	ASSERT(descr);
    14be:	4604      	mov	r4, r0
    14c0:	2261      	movs	r2, #97	; 0x61
    14c2:	4906      	ldr	r1, [pc, #24]	; (14dc <usart_async_enable+0x20>)
    14c4:	3000      	adds	r0, #0
    14c6:	bf18      	it	ne
    14c8:	2001      	movne	r0, #1
    14ca:	4b05      	ldr	r3, [pc, #20]	; (14e0 <usart_async_enable+0x24>)
    14cc:	4798      	blx	r3
	_usart_async_enable(&descr->device);
    14ce:	f104 0008 	add.w	r0, r4, #8
    14d2:	4b04      	ldr	r3, [pc, #16]	; (14e4 <usart_async_enable+0x28>)
    14d4:	4798      	blx	r3
}
    14d6:	2000      	movs	r0, #0
    14d8:	bd10      	pop	{r4, pc}
    14da:	bf00      	nop
    14dc:	0000a960 	.word	0x0000a960
    14e0:	000016f5 	.word	0x000016f5
    14e4:	00002211 	.word	0x00002211

000014e8 <usart_async_get_io_descriptor>:
{
    14e8:	b538      	push	{r3, r4, r5, lr}
    14ea:	460c      	mov	r4, r1
	ASSERT(descr && io);
    14ec:	4605      	mov	r5, r0
    14ee:	b148      	cbz	r0, 1504 <usart_async_get_io_descriptor+0x1c>
    14f0:	1c08      	adds	r0, r1, #0
    14f2:	bf18      	it	ne
    14f4:	2001      	movne	r0, #1
    14f6:	2277      	movs	r2, #119	; 0x77
    14f8:	4903      	ldr	r1, [pc, #12]	; (1508 <usart_async_get_io_descriptor+0x20>)
    14fa:	4b04      	ldr	r3, [pc, #16]	; (150c <usart_async_get_io_descriptor+0x24>)
    14fc:	4798      	blx	r3
	*io = &descr->io;
    14fe:	6025      	str	r5, [r4, #0]
}
    1500:	2000      	movs	r0, #0
    1502:	bd38      	pop	{r3, r4, r5, pc}
    1504:	2000      	movs	r0, #0
    1506:	e7f6      	b.n	14f6 <usart_async_get_io_descriptor+0xe>
    1508:	0000a960 	.word	0x0000a960
    150c:	000016f5 	.word	0x000016f5

00001510 <usart_async_register_callback>:
{
    1510:	b570      	push	{r4, r5, r6, lr}
    1512:	460c      	mov	r4, r1
    1514:	4616      	mov	r6, r2
	ASSERT(descr);
    1516:	4605      	mov	r5, r0
    1518:	2283      	movs	r2, #131	; 0x83
    151a:	4917      	ldr	r1, [pc, #92]	; (1578 <usart_async_register_callback+0x68>)
    151c:	3000      	adds	r0, #0
    151e:	bf18      	it	ne
    1520:	2001      	movne	r0, #1
    1522:	4b16      	ldr	r3, [pc, #88]	; (157c <usart_async_register_callback+0x6c>)
    1524:	4798      	blx	r3
	switch (type) {
    1526:	2c01      	cmp	r4, #1
    1528:	d010      	beq.n	154c <usart_async_register_callback+0x3c>
    152a:	b124      	cbz	r4, 1536 <usart_async_register_callback+0x26>
    152c:	2c02      	cmp	r4, #2
    152e:	d018      	beq.n	1562 <usart_async_register_callback+0x52>
		return ERR_INVALID_ARG;
    1530:	f06f 000c 	mvn.w	r0, #12
}
    1534:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.rx_done = cb;
    1536:	62ae      	str	r6, [r5, #40]	; 0x28
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
    1538:	1c32      	adds	r2, r6, #0
    153a:	bf18      	it	ne
    153c:	2201      	movne	r2, #1
    153e:	2101      	movs	r1, #1
    1540:	f105 0008 	add.w	r0, r5, #8
    1544:	4b0e      	ldr	r3, [pc, #56]	; (1580 <usart_async_register_callback+0x70>)
    1546:	4798      	blx	r3
	return ERR_NONE;
    1548:	2000      	movs	r0, #0
		break;
    154a:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.tx_done = cb;
    154c:	626e      	str	r6, [r5, #36]	; 0x24
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
    154e:	1c32      	adds	r2, r6, #0
    1550:	bf18      	it	ne
    1552:	2201      	movne	r2, #1
    1554:	2102      	movs	r1, #2
    1556:	f105 0008 	add.w	r0, r5, #8
    155a:	4b09      	ldr	r3, [pc, #36]	; (1580 <usart_async_register_callback+0x70>)
    155c:	4798      	blx	r3
	return ERR_NONE;
    155e:	2000      	movs	r0, #0
		break;
    1560:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.error = cb;
    1562:	62ee      	str	r6, [r5, #44]	; 0x2c
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
    1564:	1c32      	adds	r2, r6, #0
    1566:	bf18      	it	ne
    1568:	2201      	movne	r2, #1
    156a:	2103      	movs	r1, #3
    156c:	f105 0008 	add.w	r0, r5, #8
    1570:	4b03      	ldr	r3, [pc, #12]	; (1580 <usart_async_register_callback+0x70>)
    1572:	4798      	blx	r3
	return ERR_NONE;
    1574:	2000      	movs	r0, #0
		break;
    1576:	bd70      	pop	{r4, r5, r6, pc}
    1578:	0000a960 	.word	0x0000a960
    157c:	000016f5 	.word	0x000016f5
    1580:	00002269 	.word	0x00002269

00001584 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    1584:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1588:	460f      	mov	r7, r1
    158a:	4690      	mov	r8, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    158c:	4604      	mov	r4, r0
    158e:	b328      	cbz	r0, 15dc <usart_sync_write+0x58>
    1590:	b331      	cbz	r1, 15e0 <usart_sync_write+0x5c>
    1592:	1c10      	adds	r0, r2, #0
    1594:	bf18      	it	ne
    1596:	2001      	movne	r0, #1
    1598:	22f1      	movs	r2, #241	; 0xf1
    159a:	4912      	ldr	r1, [pc, #72]	; (15e4 <usart_sync_write+0x60>)
    159c:	4b12      	ldr	r3, [pc, #72]	; (15e8 <usart_sync_write+0x64>)
    159e:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    15a0:	3408      	adds	r4, #8
    15a2:	4d12      	ldr	r5, [pc, #72]	; (15ec <usart_sync_write+0x68>)
    15a4:	4620      	mov	r0, r4
    15a6:	47a8      	blx	r5
    15a8:	2800      	cmp	r0, #0
    15aa:	d0fb      	beq.n	15a4 <usart_sync_write+0x20>
    15ac:	3f01      	subs	r7, #1
    15ae:	2600      	movs	r6, #0
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    15b0:	f8df 9040 	ldr.w	r9, [pc, #64]	; 15f4 <usart_sync_write+0x70>
		while (!_usart_sync_is_ready_to_send(&descr->device))
    15b4:	4d0d      	ldr	r5, [pc, #52]	; (15ec <usart_sync_write+0x68>)
		_usart_sync_write_byte(&descr->device, buf[offset]);
    15b6:	f817 1f01 	ldrb.w	r1, [r7, #1]!
    15ba:	4620      	mov	r0, r4
    15bc:	47c8      	blx	r9
		while (!_usart_sync_is_ready_to_send(&descr->device))
    15be:	4620      	mov	r0, r4
    15c0:	47a8      	blx	r5
    15c2:	2800      	cmp	r0, #0
    15c4:	d0fb      	beq.n	15be <usart_sync_write+0x3a>
			;
	} while (++offset < length);
    15c6:	3601      	adds	r6, #1
    15c8:	4546      	cmp	r6, r8
    15ca:	d3f4      	bcc.n	15b6 <usart_sync_write+0x32>
	while (!_usart_sync_is_transmit_done(&descr->device))
    15cc:	4d08      	ldr	r5, [pc, #32]	; (15f0 <usart_sync_write+0x6c>)
    15ce:	4620      	mov	r0, r4
    15d0:	47a8      	blx	r5
    15d2:	2800      	cmp	r0, #0
    15d4:	d0fb      	beq.n	15ce <usart_sync_write+0x4a>
		;
	return (int32_t)offset;
}
    15d6:	4630      	mov	r0, r6
    15d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    15dc:	2000      	movs	r0, #0
    15de:	e7db      	b.n	1598 <usart_sync_write+0x14>
    15e0:	2000      	movs	r0, #0
    15e2:	e7d9      	b.n	1598 <usart_sync_write+0x14>
    15e4:	0000a980 	.word	0x0000a980
    15e8:	000016f5 	.word	0x000016f5
    15ec:	00002239 	.word	0x00002239
    15f0:	00002243 	.word	0x00002243
    15f4:	00002225 	.word	0x00002225

000015f8 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    15f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    15fc:	460f      	mov	r7, r1
    15fe:	4690      	mov	r8, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    1600:	4604      	mov	r4, r0
    1602:	b1e0      	cbz	r0, 163e <usart_sync_read+0x46>
    1604:	b1e9      	cbz	r1, 1642 <usart_sync_read+0x4a>
    1606:	1c10      	adds	r0, r2, #0
    1608:	bf18      	it	ne
    160a:	2001      	movne	r0, #1
    160c:	f44f 7286 	mov.w	r2, #268	; 0x10c
    1610:	490d      	ldr	r1, [pc, #52]	; (1648 <usart_sync_read+0x50>)
    1612:	4b0e      	ldr	r3, [pc, #56]	; (164c <usart_sync_read+0x54>)
    1614:	4798      	blx	r3
    1616:	3f01      	subs	r7, #1
	uint32_t                      offset = 0;
    1618:	2600      	movs	r6, #0
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    161a:	3408      	adds	r4, #8
    161c:	4d0c      	ldr	r5, [pc, #48]	; (1650 <usart_sync_read+0x58>)
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    161e:	f8df 9034 	ldr.w	r9, [pc, #52]	; 1654 <usart_sync_read+0x5c>
		while (!_usart_sync_is_byte_received(&descr->device))
    1622:	4620      	mov	r0, r4
    1624:	47a8      	blx	r5
    1626:	2800      	cmp	r0, #0
    1628:	d0fb      	beq.n	1622 <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
    162a:	4620      	mov	r0, r4
    162c:	47c8      	blx	r9
    162e:	f807 0f01 	strb.w	r0, [r7, #1]!
	} while (++offset < length);
    1632:	3601      	adds	r6, #1
    1634:	4546      	cmp	r6, r8
    1636:	d3f4      	bcc.n	1622 <usart_sync_read+0x2a>

	return (int32_t)offset;
}
    1638:	4630      	mov	r0, r6
    163a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    163e:	2000      	movs	r0, #0
    1640:	e7e4      	b.n	160c <usart_sync_read+0x14>
    1642:	2000      	movs	r0, #0
    1644:	e7e2      	b.n	160c <usart_sync_read+0x14>
    1646:	bf00      	nop
    1648:	0000a980 	.word	0x0000a980
    164c:	000016f5 	.word	0x000016f5
    1650:	0000224d 	.word	0x0000224d
    1654:	00002231 	.word	0x00002231

00001658 <usart_sync_init>:
{
    1658:	b538      	push	{r3, r4, r5, lr}
    165a:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    165c:	4604      	mov	r4, r0
    165e:	b198      	cbz	r0, 1688 <usart_sync_init+0x30>
    1660:	1c08      	adds	r0, r1, #0
    1662:	bf18      	it	ne
    1664:	2001      	movne	r0, #1
    1666:	2234      	movs	r2, #52	; 0x34
    1668:	4908      	ldr	r1, [pc, #32]	; (168c <usart_sync_init+0x34>)
    166a:	4b09      	ldr	r3, [pc, #36]	; (1690 <usart_sync_init+0x38>)
    166c:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    166e:	4629      	mov	r1, r5
    1670:	f104 0008 	add.w	r0, r4, #8
    1674:	4b07      	ldr	r3, [pc, #28]	; (1694 <usart_sync_init+0x3c>)
    1676:	4798      	blx	r3
	if (init_status) {
    1678:	4603      	mov	r3, r0
    167a:	b918      	cbnz	r0, 1684 <usart_sync_init+0x2c>
	descr->io.read  = usart_sync_read;
    167c:	4a06      	ldr	r2, [pc, #24]	; (1698 <usart_sync_init+0x40>)
    167e:	6062      	str	r2, [r4, #4]
	descr->io.write = usart_sync_write;
    1680:	4a06      	ldr	r2, [pc, #24]	; (169c <usart_sync_init+0x44>)
    1682:	6022      	str	r2, [r4, #0]
}
    1684:	4618      	mov	r0, r3
    1686:	bd38      	pop	{r3, r4, r5, pc}
    1688:	2000      	movs	r0, #0
    168a:	e7ec      	b.n	1666 <usart_sync_init+0xe>
    168c:	0000a980 	.word	0x0000a980
    1690:	000016f5 	.word	0x000016f5
    1694:	0000214d 	.word	0x0000214d
    1698:	000015f9 	.word	0x000015f9
    169c:	00001585 	.word	0x00001585

000016a0 <usart_sync_enable>:
{
    16a0:	b510      	push	{r4, lr}
	ASSERT(descr);
    16a2:	4604      	mov	r4, r0
    16a4:	2253      	movs	r2, #83	; 0x53
    16a6:	4906      	ldr	r1, [pc, #24]	; (16c0 <usart_sync_enable+0x20>)
    16a8:	3000      	adds	r0, #0
    16aa:	bf18      	it	ne
    16ac:	2001      	movne	r0, #1
    16ae:	4b05      	ldr	r3, [pc, #20]	; (16c4 <usart_sync_enable+0x24>)
    16b0:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
    16b2:	f104 0008 	add.w	r0, r4, #8
    16b6:	4b04      	ldr	r3, [pc, #16]	; (16c8 <usart_sync_enable+0x28>)
    16b8:	4798      	blx	r3
}
    16ba:	2000      	movs	r0, #0
    16bc:	bd10      	pop	{r4, pc}
    16be:	bf00      	nop
    16c0:	0000a980 	.word	0x0000a980
    16c4:	000016f5 	.word	0x000016f5
    16c8:	000021fd 	.word	0x000021fd

000016cc <usart_sync_get_io_descriptor>:
{
    16cc:	b538      	push	{r3, r4, r5, lr}
    16ce:	460c      	mov	r4, r1
	ASSERT(descr && io);
    16d0:	4605      	mov	r5, r0
    16d2:	b148      	cbz	r0, 16e8 <usart_sync_get_io_descriptor+0x1c>
    16d4:	1c08      	adds	r0, r1, #0
    16d6:	bf18      	it	ne
    16d8:	2001      	movne	r0, #1
    16da:	2269      	movs	r2, #105	; 0x69
    16dc:	4903      	ldr	r1, [pc, #12]	; (16ec <usart_sync_get_io_descriptor+0x20>)
    16de:	4b04      	ldr	r3, [pc, #16]	; (16f0 <usart_sync_get_io_descriptor+0x24>)
    16e0:	4798      	blx	r3
	*io = &descr->io;
    16e2:	6025      	str	r5, [r4, #0]
}
    16e4:	2000      	movs	r0, #0
    16e6:	bd38      	pop	{r3, r4, r5, pc}
    16e8:	2000      	movs	r0, #0
    16ea:	e7f6      	b.n	16da <usart_sync_get_io_descriptor+0xe>
    16ec:	0000a980 	.word	0x0000a980
    16f0:	000016f5 	.word	0x000016f5

000016f4 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    16f4:	b900      	cbnz	r0, 16f8 <assert+0x4>
		__asm("BKPT #0");
    16f6:	be00      	bkpt	0x0000
    16f8:	4770      	bx	lr

000016fa <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
    16fa:	6803      	ldr	r3, [r0, #0]
    16fc:	b14b      	cbz	r3, 1712 <is_list_element+0x18>
		if (it == element) {
    16fe:	428b      	cmp	r3, r1
    1700:	d009      	beq.n	1716 <is_list_element+0x1c>
	for (it = list->head; it; it = it->next) {
    1702:	681b      	ldr	r3, [r3, #0]
    1704:	b11b      	cbz	r3, 170e <is_list_element+0x14>
		if (it == element) {
    1706:	4299      	cmp	r1, r3
    1708:	d1fb      	bne.n	1702 <is_list_element+0x8>
			return true;
    170a:	2001      	movs	r0, #1
		}
	}

	return false;
}
    170c:	4770      	bx	lr
	return false;
    170e:	2000      	movs	r0, #0
    1710:	4770      	bx	lr
    1712:	2000      	movs	r0, #0
    1714:	4770      	bx	lr
			return true;
    1716:	2001      	movs	r0, #1
    1718:	4770      	bx	lr
	...

0000171c <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
    171c:	b538      	push	{r3, r4, r5, lr}
    171e:	4604      	mov	r4, r0
    1720:	460d      	mov	r5, r1
	ASSERT(!is_list_element(list, element));
    1722:	4b06      	ldr	r3, [pc, #24]	; (173c <list_insert_as_head+0x20>)
    1724:	4798      	blx	r3
    1726:	f080 0001 	eor.w	r0, r0, #1
    172a:	2239      	movs	r2, #57	; 0x39
    172c:	4904      	ldr	r1, [pc, #16]	; (1740 <list_insert_as_head+0x24>)
    172e:	b2c0      	uxtb	r0, r0
    1730:	4b04      	ldr	r3, [pc, #16]	; (1744 <list_insert_as_head+0x28>)
    1732:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
    1734:	6823      	ldr	r3, [r4, #0]
    1736:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
    1738:	6025      	str	r5, [r4, #0]
    173a:	bd38      	pop	{r3, r4, r5, pc}
    173c:	000016fb 	.word	0x000016fb
    1740:	0000a99c 	.word	0x0000a99c
    1744:	000016f5 	.word	0x000016f5

00001748 <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
    1748:	6803      	ldr	r3, [r0, #0]
    174a:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
    174c:	6001      	str	r1, [r0, #0]
    174e:	4770      	bx	lr

00001750 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
    1750:	6803      	ldr	r3, [r0, #0]
    1752:	b10b      	cbz	r3, 1758 <list_remove_head+0x8>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
    1754:	681a      	ldr	r2, [r3, #0]
    1756:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
	}

	return NULL;
}
    1758:	4618      	mov	r0, r3
    175a:	4770      	bx	lr

0000175c <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
    175c:	b570      	push	{r4, r5, r6, lr}
    175e:	460e      	mov	r6, r1
    1760:	4615      	mov	r5, r2
	ASSERT(rb && buf && size);
    1762:	4604      	mov	r4, r0
    1764:	b178      	cbz	r0, 1786 <ringbuffer_init+0x2a>
    1766:	b181      	cbz	r1, 178a <ringbuffer_init+0x2e>
    1768:	b1a2      	cbz	r2, 1794 <ringbuffer_init+0x38>
    176a:	2001      	movs	r0, #1
    176c:	2228      	movs	r2, #40	; 0x28
    176e:	490d      	ldr	r1, [pc, #52]	; (17a4 <ringbuffer_init+0x48>)
    1770:	4b0d      	ldr	r3, [pc, #52]	; (17a8 <ringbuffer_init+0x4c>)
    1772:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
    1774:	1e6b      	subs	r3, r5, #1
    1776:	421d      	tst	r5, r3
    1778:	d109      	bne.n	178e <ringbuffer_init+0x32>
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
    177a:	6063      	str	r3, [r4, #4]
	rb->read_index  = 0;
    177c:	2000      	movs	r0, #0
    177e:	60a0      	str	r0, [r4, #8]
	rb->write_index = rb->read_index;
    1780:	60e0      	str	r0, [r4, #12]
	rb->buf         = (uint8_t *)buf;
    1782:	6026      	str	r6, [r4, #0]

	return ERR_NONE;
    1784:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
    1786:	2000      	movs	r0, #0
    1788:	e7f0      	b.n	176c <ringbuffer_init+0x10>
    178a:	2000      	movs	r0, #0
    178c:	e7ee      	b.n	176c <ringbuffer_init+0x10>
		return ERR_INVALID_ARG;
    178e:	f06f 000c 	mvn.w	r0, #12
    1792:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
    1794:	2228      	movs	r2, #40	; 0x28
    1796:	4903      	ldr	r1, [pc, #12]	; (17a4 <ringbuffer_init+0x48>)
    1798:	2000      	movs	r0, #0
    179a:	4b03      	ldr	r3, [pc, #12]	; (17a8 <ringbuffer_init+0x4c>)
    179c:	4798      	blx	r3
	if ((size & (size - 1)) != 0) {
    179e:	1e6b      	subs	r3, r5, #1
    17a0:	e7eb      	b.n	177a <ringbuffer_init+0x1e>
    17a2:	bf00      	nop
    17a4:	0000a9bc 	.word	0x0000a9bc
    17a8:	000016f5 	.word	0x000016f5

000017ac <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
    17ac:	b538      	push	{r3, r4, r5, lr}
    17ae:	460d      	mov	r5, r1
	ASSERT(rb && data);
    17b0:	4604      	mov	r4, r0
    17b2:	b1a0      	cbz	r0, 17de <ringbuffer_get+0x32>
    17b4:	1c08      	adds	r0, r1, #0
    17b6:	bf18      	it	ne
    17b8:	2001      	movne	r0, #1
    17ba:	2240      	movs	r2, #64	; 0x40
    17bc:	490a      	ldr	r1, [pc, #40]	; (17e8 <ringbuffer_get+0x3c>)
    17be:	4b0b      	ldr	r3, [pc, #44]	; (17ec <ringbuffer_get+0x40>)
    17c0:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
    17c2:	68a3      	ldr	r3, [r4, #8]
    17c4:	68e2      	ldr	r2, [r4, #12]
    17c6:	429a      	cmp	r2, r3
    17c8:	d00b      	beq.n	17e2 <ringbuffer_get+0x36>
		*data = rb->buf[rb->read_index & rb->size];
    17ca:	6862      	ldr	r2, [r4, #4]
    17cc:	4013      	ands	r3, r2
    17ce:	6822      	ldr	r2, [r4, #0]
    17d0:	5cd3      	ldrb	r3, [r2, r3]
    17d2:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
    17d4:	68a3      	ldr	r3, [r4, #8]
    17d6:	3301      	adds	r3, #1
    17d8:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
    17da:	2000      	movs	r0, #0
    17dc:	bd38      	pop	{r3, r4, r5, pc}
    17de:	2000      	movs	r0, #0
    17e0:	e7eb      	b.n	17ba <ringbuffer_get+0xe>
	}

	return ERR_NOT_FOUND;
    17e2:	f06f 0009 	mvn.w	r0, #9
}
    17e6:	bd38      	pop	{r3, r4, r5, pc}
    17e8:	0000a9bc 	.word	0x0000a9bc
    17ec:	000016f5 	.word	0x000016f5

000017f0 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
    17f0:	b538      	push	{r3, r4, r5, lr}
    17f2:	460d      	mov	r5, r1
	ASSERT(rb);
    17f4:	4604      	mov	r4, r0
    17f6:	2251      	movs	r2, #81	; 0x51
    17f8:	490b      	ldr	r1, [pc, #44]	; (1828 <ringbuffer_put+0x38>)
    17fa:	3000      	adds	r0, #0
    17fc:	bf18      	it	ne
    17fe:	2001      	movne	r0, #1
    1800:	4b0a      	ldr	r3, [pc, #40]	; (182c <ringbuffer_put+0x3c>)
    1802:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
    1804:	68e3      	ldr	r3, [r4, #12]
    1806:	6862      	ldr	r2, [r4, #4]
    1808:	4013      	ands	r3, r2
    180a:	6822      	ldr	r2, [r4, #0]
    180c:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
    180e:	68e3      	ldr	r3, [r4, #12]
    1810:	6861      	ldr	r1, [r4, #4]
    1812:	68a2      	ldr	r2, [r4, #8]
    1814:	1a9a      	subs	r2, r3, r2
    1816:	428a      	cmp	r2, r1
		rb->read_index = rb->write_index - rb->size;
    1818:	bf84      	itt	hi
    181a:	1a59      	subhi	r1, r3, r1
    181c:	60a1      	strhi	r1, [r4, #8]
	}

	rb->write_index++;
    181e:	3301      	adds	r3, #1
    1820:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
    1822:	2000      	movs	r0, #0
    1824:	bd38      	pop	{r3, r4, r5, pc}
    1826:	bf00      	nop
    1828:	0000a9bc 	.word	0x0000a9bc
    182c:	000016f5 	.word	0x000016f5

00001830 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
    1830:	b510      	push	{r4, lr}
	ASSERT(rb);
    1832:	4604      	mov	r4, r0
    1834:	2267      	movs	r2, #103	; 0x67
    1836:	4905      	ldr	r1, [pc, #20]	; (184c <ringbuffer_num+0x1c>)
    1838:	3000      	adds	r0, #0
    183a:	bf18      	it	ne
    183c:	2001      	movne	r0, #1
    183e:	4b04      	ldr	r3, [pc, #16]	; (1850 <ringbuffer_num+0x20>)
    1840:	4798      	blx	r3

	return rb->write_index - rb->read_index;
    1842:	68e0      	ldr	r0, [r4, #12]
    1844:	68a3      	ldr	r3, [r4, #8]
}
    1846:	1ac0      	subs	r0, r0, r3
    1848:	bd10      	pop	{r4, pc}
    184a:	bf00      	nop
    184c:	0000a9bc 	.word	0x0000a9bc
    1850:	000016f5 	.word	0x000016f5

00001854 <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
    1854:	4603      	mov	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    1856:	4a06      	ldr	r2, [pc, #24]	; (1870 <_sbrk+0x1c>)
    1858:	6812      	ldr	r2, [r2, #0]
    185a:	b122      	cbz	r2, 1866 <_sbrk+0x12>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
    185c:	4a04      	ldr	r2, [pc, #16]	; (1870 <_sbrk+0x1c>)
    185e:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    1860:	4403      	add	r3, r0
    1862:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
    1864:	4770      	bx	lr
		heap = (unsigned char *)&_end;
    1866:	4903      	ldr	r1, [pc, #12]	; (1874 <_sbrk+0x20>)
    1868:	4a01      	ldr	r2, [pc, #4]	; (1870 <_sbrk+0x1c>)
    186a:	6011      	str	r1, [r2, #0]
    186c:	e7f6      	b.n	185c <_sbrk+0x8>
    186e:	bf00      	nop
    1870:	200001a0 	.word	0x200001a0
    1874:	200195d8 	.word	0x200195d8

00001878 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
    1878:	f04f 30ff 	mov.w	r0, #4294967295
    187c:	4770      	bx	lr

0000187e <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
    187e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    1882:	604b      	str	r3, [r1, #4]

	return 0;
}
    1884:	2000      	movs	r0, #0
    1886:	4770      	bx	lr

00001888 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
    1888:	2001      	movs	r0, #1
    188a:	4770      	bx	lr

0000188c <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
    188c:	2000      	movs	r0, #0
    188e:	4770      	bx	lr

00001890 <_irq_set>:
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    1890:	0943      	lsrs	r3, r0, #5
    1892:	f000 001f 	and.w	r0, r0, #31
    1896:	2201      	movs	r2, #1
    1898:	fa02 f000 	lsl.w	r0, r2, r0
    189c:	3340      	adds	r3, #64	; 0x40
    189e:	4a02      	ldr	r2, [pc, #8]	; (18a8 <_irq_set+0x18>)
    18a0:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    18a4:	4770      	bx	lr
    18a6:	bf00      	nop
    18a8:	e000e100 	.word	0xe000e100

000018ac <_get_cycles_for_ms>:
 */
static inline uint32_t _get_cycles_for_ms_internal(const uint16_t ms, const uint32_t freq, const uint8_t power)
{
	switch (power) {
	case 9:
		return (ms * (freq / 1000000) + 2) / 3 * 1000;
    18ac:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
    18b0:	00c3      	lsls	r3, r0, #3
    18b2:	3302      	adds	r3, #2
    18b4:	4804      	ldr	r0, [pc, #16]	; (18c8 <_get_cycles_for_ms+0x1c>)
    18b6:	fba0 2303 	umull	r2, r3, r0, r3
    18ba:	085b      	lsrs	r3, r3, #1
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
    18bc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    18c0:	fb00 f003 	mul.w	r0, r0, r3
    18c4:	4770      	bx	lr
    18c6:	bf00      	nop
    18c8:	aaaaaaab 	.word	0xaaaaaaab

000018cc <_delay_cycles>:
{
#ifndef _UNIT_TEST_
	(void)hw;
	(void)cycles;
#if defined __GNUC__
	__asm(".syntax unified\n"
    18cc:	3901      	subs	r1, #1
    18ce:	d8fd      	bhi.n	18cc <_delay_cycles>
    18d0:	4770      	bx	lr
	...

000018d4 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    18d4:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    18d6:	4a09      	ldr	r2, [pc, #36]	; (18fc <_init_chip+0x28>)
    18d8:	8813      	ldrh	r3, [r2, #0]
    18da:	b29b      	uxth	r3, r3
    18dc:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    18de:	4b08      	ldr	r3, [pc, #32]	; (1900 <_init_chip+0x2c>)
    18e0:	4798      	blx	r3
	_oscctrl_init_sources();
    18e2:	4b08      	ldr	r3, [pc, #32]	; (1904 <_init_chip+0x30>)
    18e4:	4798      	blx	r3
	_mclk_init();
    18e6:	4b08      	ldr	r3, [pc, #32]	; (1908 <_init_chip+0x34>)
    18e8:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    18ea:	2002      	movs	r0, #2
    18ec:	4c07      	ldr	r4, [pc, #28]	; (190c <_init_chip+0x38>)
    18ee:	47a0      	blx	r4
#endif
	_oscctrl_init_referenced_generators();
    18f0:	4b07      	ldr	r3, [pc, #28]	; (1910 <_init_chip+0x3c>)
    18f2:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    18f4:	f640 70fd 	movw	r0, #4093	; 0xffd
    18f8:	47a0      	blx	r4
    18fa:	bd10      	pop	{r4, pc}
    18fc:	41004000 	.word	0x41004000
    1900:	00001e9d 	.word	0x00001e9d
    1904:	00001eb1 	.word	0x00001eb1
    1908:	00001e91 	.word	0x00001e91
    190c:	00001915 	.word	0x00001915
    1910:	00001ee1 	.word	0x00001ee1

00001914 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    1914:	f010 0f01 	tst.w	r0, #1
    1918:	d008      	beq.n	192c <_gclk_init_generators_by_fref+0x18>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    191a:	4a17      	ldr	r2, [pc, #92]	; (1978 <_gclk_init_generators_by_fref+0x64>)
    191c:	4b17      	ldr	r3, [pc, #92]	; (197c <_gclk_init_generators_by_fref+0x68>)
    191e:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1920:	4619      	mov	r1, r3
    1922:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    1926:	684b      	ldr	r3, [r1, #4]
    1928:	4213      	tst	r3, r2
    192a:	d1fc      	bne.n	1926 <_gclk_init_generators_by_fref+0x12>
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    192c:	f010 0f02 	tst.w	r0, #2
    1930:	d008      	beq.n	1944 <_gclk_init_generators_by_fref+0x30>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1932:	4a13      	ldr	r2, [pc, #76]	; (1980 <_gclk_init_generators_by_fref+0x6c>)
    1934:	4b11      	ldr	r3, [pc, #68]	; (197c <_gclk_init_generators_by_fref+0x68>)
    1936:	625a      	str	r2, [r3, #36]	; 0x24
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1938:	4619      	mov	r1, r3
    193a:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    193e:	684b      	ldr	r3, [r1, #4]
    1940:	4213      	tst	r3, r2
    1942:	d1fc      	bne.n	193e <_gclk_init_generators_by_fref+0x2a>
		        | (CONF_GCLK_GENERATOR_1_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_1_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_2_CONFIG == 1
	if (bm & (1ul << 2)) {
    1944:	f010 0f04 	tst.w	r0, #4
    1948:	d008      	beq.n	195c <_gclk_init_generators_by_fref+0x48>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    194a:	4a0e      	ldr	r2, [pc, #56]	; (1984 <_gclk_init_generators_by_fref+0x70>)
    194c:	4b0b      	ldr	r3, [pc, #44]	; (197c <_gclk_init_generators_by_fref+0x68>)
    194e:	629a      	str	r2, [r3, #40]	; 0x28
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1950:	4619      	mov	r1, r3
    1952:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    1956:	684b      	ldr	r3, [r1, #4]
    1958:	4213      	tst	r3, r2
    195a:	d1fc      	bne.n	1956 <_gclk_init_generators_by_fref+0x42>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    195c:	f010 0f08 	tst.w	r0, #8
    1960:	d008      	beq.n	1974 <_gclk_init_generators_by_fref+0x60>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1962:	4a09      	ldr	r2, [pc, #36]	; (1988 <_gclk_init_generators_by_fref+0x74>)
    1964:	4b05      	ldr	r3, [pc, #20]	; (197c <_gclk_init_generators_by_fref+0x68>)
    1966:	62da      	str	r2, [r3, #44]	; 0x2c
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1968:	4619      	mov	r1, r3
    196a:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    196e:	684b      	ldr	r3, [r1, #4]
    1970:	4213      	tst	r3, r2
    1972:	d1fc      	bne.n	196e <_gclk_init_generators_by_fref+0x5a>
    1974:	4770      	bx	lr
    1976:	bf00      	nop
    1978:	00010107 	.word	0x00010107
    197c:	40001c00 	.word	0x40001c00
    1980:	00060900 	.word	0x00060900
    1984:	00060901 	.word	0x00060901
    1988:	00010104 	.word	0x00010104

0000198c <GMAC_Handler>:

/*
 * \internal GMAC interrupt handler
 */
void GMAC_Handler(void)
{
    198c:	b500      	push	{lr}
    198e:	b083      	sub	sp, #12
	volatile uint32_t tsr;
	volatile uint32_t rsr;

	tsr = hri_gmac_read_TSR_reg(_gmac_dev->hw);
    1990:	4b14      	ldr	r3, [pc, #80]	; (19e4 <GMAC_Handler+0x58>)
    1992:	6818      	ldr	r0, [r3, #0]
    1994:	6803      	ldr	r3, [r0, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_tsr_reg_t hri_gmac_read_TSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->TSR.reg;
    1996:	695a      	ldr	r2, [r3, #20]
    1998:	9201      	str	r2, [sp, #4]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_rsr_reg_t hri_gmac_read_RSR_reg(const void *const hw)
{
	return ((Gmac *)hw)->RSR.reg;
    199a:	6a1a      	ldr	r2, [r3, #32]
	rsr = hri_gmac_read_RSR_reg(_gmac_dev->hw);
    199c:	9200      	str	r2, [sp, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_isr_reg_t hri_gmac_read_ISR_reg(const void *const hw)
{
	return ((Gmac *)hw)->ISR.reg;
    199e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	/* Must be Clear ISR (Clear on read) */
	hri_gmac_read_ISR_reg(_gmac_dev->hw);

	/* Frame transmited */
	if (tsr & GMAC_TSR_TXCOMP) {
    19a0:	9a01      	ldr	r2, [sp, #4]
    19a2:	f012 0f20 	tst.w	r2, #32
    19a6:	d00b      	beq.n	19c0 <GMAC_Handler+0x34>
		hri_gmac_write_TSR_reg(_gmac_dev->hw, tsr);
    19a8:	9a01      	ldr	r2, [sp, #4]
	((Gmac *)hw)->TSR.reg = data;
    19aa:	615a      	str	r2, [r3, #20]
		if ((_txbuf_descrs[_txbuf_index].status.bm.used) && (_gmac_dev->cb.transmited != NULL)) {
    19ac:	4b0d      	ldr	r3, [pc, #52]	; (19e4 <GMAC_Handler+0x58>)
    19ae:	685a      	ldr	r2, [r3, #4]
    19b0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    19b4:	7bdb      	ldrb	r3, [r3, #15]
    19b6:	09db      	lsrs	r3, r3, #7
    19b8:	d002      	beq.n	19c0 <GMAC_Handler+0x34>
    19ba:	6843      	ldr	r3, [r0, #4]
    19bc:	b103      	cbz	r3, 19c0 <GMAC_Handler+0x34>
			_gmac_dev->cb.transmited(_gmac_dev);
    19be:	4798      	blx	r3
		}
	}

	/* Frame received */
	if (rsr & GMAC_RSR_REC) {
    19c0:	9b00      	ldr	r3, [sp, #0]
    19c2:	f013 0f02 	tst.w	r3, #2
    19c6:	d004      	beq.n	19d2 <GMAC_Handler+0x46>
		if (_gmac_dev->cb.received != NULL) {
    19c8:	4b06      	ldr	r3, [pc, #24]	; (19e4 <GMAC_Handler+0x58>)
    19ca:	6818      	ldr	r0, [r3, #0]
    19cc:	6883      	ldr	r3, [r0, #8]
    19ce:	b103      	cbz	r3, 19d2 <GMAC_Handler+0x46>
			_gmac_dev->cb.received(_gmac_dev);
    19d0:	4798      	blx	r3
		}
	}
	hri_gmac_write_RSR_reg(_gmac_dev->hw, rsr);
    19d2:	4b04      	ldr	r3, [pc, #16]	; (19e4 <GMAC_Handler+0x58>)
    19d4:	681b      	ldr	r3, [r3, #0]
    19d6:	681b      	ldr	r3, [r3, #0]
    19d8:	9a00      	ldr	r2, [sp, #0]
	((Gmac *)hw)->RSR.reg = data;
    19da:	621a      	str	r2, [r3, #32]
}
    19dc:	b003      	add	sp, #12
    19de:	f85d fb04 	ldr.w	pc, [sp], #4
    19e2:	bf00      	nop
    19e4:	200001c0 	.word	0x200001c0

000019e8 <_mac_async_init>:

int32_t _mac_async_init(struct _mac_async_device *const dev, void *const hw)
{
    19e8:	b430      	push	{r4, r5}
	dev->hw = hw;
    19ea:	6001      	str	r1, [r0, #0]
	((Gmac *)hw)->NCR.reg = data;
    19ec:	4b29      	ldr	r3, [pc, #164]	; (1a94 <_mac_async_init+0xac>)
    19ee:	600b      	str	r3, [r1, #0]
	                       (CONF_GMAC_NCR_LBL ? GMAC_NCR_LBL : 0) | (CONF_GMAC_NCR_MPE ? GMAC_NCR_MPE : 0)
	                           | (CONF_GMAC_NCR_WESTAT ? GMAC_NCR_WESTAT : 0) | (CONF_GMAC_NCR_BP ? GMAC_NCR_BP : 0)
	                           | (CONF_GMAC_NCR_ENPBPR ? GMAC_NCR_ENPBPR : 0)
	                           | (CONF_GMAC_NCR_TXPBPF ? GMAC_NCR_TXPBPF : 0));
	hri_gmac_write_NCFGR_reg(
	    dev->hw,
    19f0:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->NCFGR.reg = data;
    19f2:	4a29      	ldr	r2, [pc, #164]	; (1a98 <_mac_async_init+0xb0>)
    19f4:	605a      	str	r2, [r3, #4]
	        | (CONF_GMAC_NCFGR_LFERD ? GMAC_NCFGR_LFERD : 0) | (CONF_GMAC_NCFGR_RFCS ? GMAC_NCFGR_RFCS : 0)
	        | GMAC_NCFGR_CLK(CONF_GMAC_NCFGR_CLK) | (CONF_GMAC_NCFGR_DCPF ? GMAC_NCFGR_DCPF : 0)
	        | (CONF_GMAC_NCFGR_RXCOEN ? GMAC_NCFGR_RXCOEN : 0) | (CONF_GMAC_NCFGR_EFRHD ? GMAC_NCFGR_EFRHD : 0)
	        | (CONF_GMAC_NCFGR_IRXFCS ? GMAC_NCFGR_IRXFCS : 0) | (CONF_GMAC_NCFGR_IPGSEN ? GMAC_NCFGR_IPGSEN : 0)
	        | (CONF_GMAC_NCFGR_RXBP ? GMAC_NCFGR_RXBP : 0) | (CONF_GMAC_NCFGR_IRXER ? GMAC_NCFGR_IRXER : 0));
	hri_gmac_write_UR_reg(dev->hw, (CONF_GMAC_UR_MII ? GMAC_UR_MII : 0));
    19f6:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->UR.reg = data;
    19f8:	2300      	movs	r3, #0
    19fa:	60d3      	str	r3, [r2, #12]
	hri_gmac_write_DCFGR_reg(
	    dev->hw,
    19fc:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->DCFGR.reg = data;
    19fe:	4927      	ldr	r1, [pc, #156]	; (1a9c <_mac_async_init+0xb4>)
    1a00:	6111      	str	r1, [r2, #16]
	    GMAC_DCFGR_FBLDO(CONF_GMAC_DCFGR_FBLDO) | (CONF_GMAC_DCFGR_ESMA ? GMAC_DCFGR_ESMA : 0)
	        | (CONF_GMAC_DCFGR_ESPA ? GMAC_DCFGR_ESPA : 0) | GMAC_DCFGR_RXBMS(CONF_GMAC_DCFGR_RXBMS)
	        | (CONF_GMAC_DCFGR_TXPBMS ? GMAC_DCFGR_TXPBMS : 0) | (CONF_GMAC_DCFGR_TXCOEN ? GMAC_DCFGR_TXCOEN : 0)
	        | GMAC_DCFGR_DRBS(CONF_GMAC_DCFGR_DRBS) | (CONF_GMAC_DCFGR_DDRP ? GMAC_DCFGR_DDRP : 0));
	hri_gmac_write_WOL_reg(dev->hw, 0);
    1a02:	6802      	ldr	r2, [r0, #0]
}

static inline void hri_gmac_write_WOL_reg(const void *const hw, hri_gmac_wol_reg_t data)
{
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->WOL.reg = data;
    1a04:	f8c2 30b8 	str.w	r3, [r2, #184]	; 0xb8
	hri_gmac_write_IPGS_reg(dev->hw, GMAC_IPGS_FL((CONF_GMAC_IPGS_FL_MUL << 8) | CONF_GMAC_IPGS_FL_DIV));
    1a08:	6802      	ldr	r2, [r0, #0]
}

static inline void hri_gmac_write_IPGS_reg(const void *const hw, hri_gmac_ipgs_reg_t data)
{
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->IPGS.reg = data;
    1a0a:	f240 1101 	movw	r1, #257	; 0x101
    1a0e:	f8c2 10bc 	str.w	r1, [r2, #188]	; 0xbc
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    1a12:	4923      	ldr	r1, [pc, #140]	; (1aa0 <_mac_async_init+0xb8>)
    1a14:	f101 0220 	add.w	r2, r1, #32
    1a18:	608a      	str	r2, [r1, #8]
		_txbuf_descrs[i].status.val     = 0;
    1a1a:	60cb      	str	r3, [r1, #12]
		_txbuf_descrs[i].status.bm.used = 1;
    1a1c:	2280      	movs	r2, #128	; 0x80
    1a1e:	73ca      	strb	r2, [r1, #15]
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    1a20:	f201 52fc 	addw	r2, r1, #1532	; 0x5fc
    1a24:	610a      	str	r2, [r1, #16]
		_txbuf_descrs[i].status.val     = 0;
    1a26:	614b      	str	r3, [r1, #20]
	_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    1a28:	22c0      	movs	r2, #192	; 0xc0
    1a2a:	75ca      	strb	r2, [r1, #23]
	_txbuf_index                                            = 0;
    1a2c:	604b      	str	r3, [r1, #4]
	_last_txbuf_index                                       = 0;
    1a2e:	f8c1 3bd8 	str.w	r3, [r1, #3032]	; 0xbd8
    1a32:	f501 633e 	add.w	r3, r1, #3040	; 0xbe0
    1a36:	4a1b      	ldr	r2, [pc, #108]	; (1aa4 <_mac_async_init+0xbc>)
    1a38:	f501 519f 	add.w	r1, r1, #5088	; 0x13e0
		_rxbuf_descrs[i].status.val  = 0;
    1a3c:	2400      	movs	r4, #0
		_rxbuf_descrs[i].address.val = (uint32_t)_rxbuf[i];
    1a3e:	f842 3c04 	str.w	r3, [r2, #-4]
		_rxbuf_descrs[i].status.val  = 0;
    1a42:	f842 4b08 	str.w	r4, [r2], #8
    1a46:	3380      	adds	r3, #128	; 0x80
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1a48:	428b      	cmp	r3, r1
    1a4a:	d1f8      	bne.n	1a3e <_mac_async_init+0x56>
	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    1a4c:	4b16      	ldr	r3, [pc, #88]	; (1aa8 <_mac_async_init+0xc0>)
    1a4e:	f893 2360 	ldrb.w	r2, [r3, #864]	; 0x360
    1a52:	f042 0202 	orr.w	r2, r2, #2
    1a56:	f883 2360 	strb.w	r2, [r3, #864]	; 0x360
	_rxbuf_index                                             = 0;
    1a5a:	2100      	movs	r1, #0
    1a5c:	f8c3 1368 	str.w	r1, [r3, #872]	; 0x368
	hri_gmac_write_TBQB_reg(dev->hw, (uint32_t)_txbuf_descrs);
    1a60:	6804      	ldr	r4, [r0, #0]
    1a62:	4a0f      	ldr	r2, [pc, #60]	; (1aa0 <_mac_async_init+0xb8>)
    1a64:	f102 0508 	add.w	r5, r2, #8
	((Gmac *)hw)->TBQB.reg = data;
    1a68:	61e5      	str	r5, [r4, #28]
	hri_gmac_write_RBQB_reg(dev->hw, (uint32_t)_rxbuf_descrs);
    1a6a:	6804      	ldr	r4, [r0, #0]
    1a6c:	f503 733a 	add.w	r3, r3, #744	; 0x2e8
	((Gmac *)hw)->RBQB.reg = data;
    1a70:	61a3      	str	r3, [r4, #24]
	_mac_init_bufdescr(dev);

	_gmac_dev = dev;
    1a72:	6010      	str	r0, [r2, #0]
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    1a74:	4b0d      	ldr	r3, [pc, #52]	; (1aac <_mac_async_init+0xc4>)
    1a76:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    1a7a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
    1a7e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1a82:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    1a86:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    1a8a:	609a      	str	r2, [r3, #8]
	NVIC_DisableIRQ(GMAC_IRQn);
	NVIC_ClearPendingIRQ(GMAC_IRQn);
	NVIC_EnableIRQ(GMAC_IRQn);

	return ERR_NONE;
}
    1a8c:	4608      	mov	r0, r1
    1a8e:	bc30      	pop	{r4, r5}
    1a90:	4770      	bx	lr
    1a92:	bf00      	nop
    1a94:	00030010 	.word	0x00030010
    1a98:	00100103 	.word	0x00100103
    1a9c:	00020704 	.word	0x00020704
    1aa0:	200001c0 	.word	0x200001c0
    1aa4:	200015a4 	.word	0x200015a4
    1aa8:	200012b8 	.word	0x200012b8
    1aac:	e000e100 	.word	0xe000e100

00001ab0 <_mac_async_enable>:
	return ERR_NONE;
}

int32_t _mac_async_enable(struct _mac_async_device *const dev)
{
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
    1ab0:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    1ab2:	6813      	ldr	r3, [r2, #0]
    1ab4:	f043 030c 	orr.w	r3, r3, #12
    1ab8:	6013      	str	r3, [r2, #0]
	return ERR_NONE;
}
    1aba:	2000      	movs	r0, #0
    1abc:	4770      	bx	lr
	...

00001ac0 <_mac_async_write>:
	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
	return ERR_NONE;
}

int32_t _mac_async_write(struct _mac_async_device *const dev, uint8_t *buf, uint32_t len)
{
    1ac0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1ac4:	4682      	mov	sl, r0
    1ac6:	4614      	mov	r4, r2
	uint32_t pos;
	uint32_t blen;
	uint32_t i;

	if (_txbuf_descrs[_last_txbuf_index].status.bm.used && !_txbuf_descrs[_last_txbuf_index].status.bm.last_buf) {
    1ac8:	4b49      	ldr	r3, [pc, #292]	; (1bf0 <_mac_async_write+0x130>)
    1aca:	f8d3 2bd8 	ldr.w	r2, [r3, #3032]	; 0xbd8
    1ace:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1ad2:	7bdb      	ldrb	r3, [r3, #15]
    1ad4:	09db      	lsrs	r3, r3, #7
    1ad6:	d016      	beq.n	1b06 <_mac_async_write+0x46>
    1ad8:	4b45      	ldr	r3, [pc, #276]	; (1bf0 <_mac_async_write+0x130>)
    1ada:	f8d3 2bd8 	ldr.w	r2, [r3, #3032]	; 0xbd8
    1ade:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1ae2:	7b5b      	ldrb	r3, [r3, #13]
    1ae4:	09db      	lsrs	r3, r3, #7
    1ae6:	d10e      	bne.n	1b06 <_mac_async_write+0x46>
		/* Set used flag from first descriptor to last descriptor,
		 * as DMA olny set the first used flag */
		for (i = 1; i < CONF_GMAC_TXDESCR_NUM; i++) {
			pos = _last_txbuf_index + i;
    1ae8:	4b41      	ldr	r3, [pc, #260]	; (1bf0 <_mac_async_write+0x130>)
    1aea:	f8d3 3bd8 	ldr.w	r3, [r3, #3032]	; 0xbd8
    1aee:	1c5a      	adds	r2, r3, #1
			if (pos >= CONF_GMAC_TXDESCR_NUM) {
    1af0:	2a01      	cmp	r2, #1
				pos -= CONF_GMAC_TXDESCR_NUM;
    1af2:	bf88      	it	hi
    1af4:	f103 32ff 	addhi.w	r2, r3, #4294967295
			}
			_txbuf_descrs[pos].status.bm.used = 1;
    1af8:	4b3d      	ldr	r3, [pc, #244]	; (1bf0 <_mac_async_write+0x130>)
    1afa:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1afe:	7bda      	ldrb	r2, [r3, #15]
    1b00:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    1b04:	73da      	strb	r2, [r3, #15]
				break;
			}
		}
	}

	if (!_txbuf_descrs[_txbuf_index].status.bm.used) {
    1b06:	4b3a      	ldr	r3, [pc, #232]	; (1bf0 <_mac_async_write+0x130>)
    1b08:	685a      	ldr	r2, [r3, #4]
    1b0a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1b0e:	7bdb      	ldrb	r3, [r3, #15]
    1b10:	09db      	lsrs	r3, r3, #7
    1b12:	d064      	beq.n	1bde <_mac_async_write+0x11e>
		return ERR_NO_RESOURCE;
	}

	/* Check if have enough buffers, the first buffer already checked */
	if (len > CONF_GMAC_TXBUF_SIZE) {
    1b14:	f240 53dc 	movw	r3, #1500	; 0x5dc
    1b18:	429c      	cmp	r4, r3
    1b1a:	d90c      	bls.n	1b36 <_mac_async_write+0x76>
		for (i = 1; i < CONF_GMAC_TXDESCR_NUM; i++) {
			pos = _txbuf_index + i;
    1b1c:	4b34      	ldr	r3, [pc, #208]	; (1bf0 <_mac_async_write+0x130>)
    1b1e:	685b      	ldr	r3, [r3, #4]
    1b20:	1c5a      	adds	r2, r3, #1
			if (pos >= CONF_GMAC_TXDESCR_NUM) {
    1b22:	2a01      	cmp	r2, #1
				pos -= CONF_GMAC_TXDESCR_NUM;
    1b24:	bf88      	it	hi
    1b26:	f103 32ff 	addhi.w	r2, r3, #4294967295
			}

			if (!_txbuf_descrs[pos].status.bm.used) {
    1b2a:	4b31      	ldr	r3, [pc, #196]	; (1bf0 <_mac_async_write+0x130>)
    1b2c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1b30:	7bdb      	ldrb	r3, [r3, #15]
    1b32:	09db      	lsrs	r3, r3, #7
    1b34:	d057      	beq.n	1be6 <_mac_async_write+0x126>
			if ((len - (CONF_GMAC_TXBUF_SIZE * i)) < CONF_GMAC_TXBUF_SIZE) {
				break;
			}
		}
	}
	_last_txbuf_index = _txbuf_index;
    1b36:	4b2e      	ldr	r3, [pc, #184]	; (1bf0 <_mac_async_write+0x130>)
    1b38:	685a      	ldr	r2, [r3, #4]
    1b3a:	f8c3 2bd8 	str.w	r2, [r3, #3032]	; 0xbd8
    1b3e:	460f      	mov	r7, r1
    1b40:	f601 38b8 	addw	r8, r1, #3000	; 0xbb8

	/* Write data to transmit buffer */
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    1b44:	461e      	mov	r6, r3
    1b46:	f103 0b20 	add.w	fp, r3, #32
    1b4a:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 1bf4 <_mac_async_write+0x134>
    1b4e:	e027      	b.n	1ba0 <_mac_async_write+0xe0>

		if (len > 0) {
			/* Here the Used flag be set to zero */
			_txbuf_descrs[_txbuf_index].status.val = blen;
		} else {
			_txbuf_descrs[_txbuf_index].status.val         = blen;
    1b50:	4b27      	ldr	r3, [pc, #156]	; (1bf0 <_mac_async_write+0x130>)
    1b52:	685a      	ldr	r2, [r3, #4]
    1b54:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    1b58:	60d5      	str	r5, [r2, #12]
			_txbuf_descrs[_txbuf_index].status.bm.last_buf = 1;
    1b5a:	685a      	ldr	r2, [r3, #4]
    1b5c:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    1b60:	7b51      	ldrb	r1, [r2, #13]
    1b62:	f041 0180 	orr.w	r1, r1, #128	; 0x80
    1b66:	7351      	strb	r1, [r2, #13]
		}
		_txbuf_index++;
    1b68:	685a      	ldr	r2, [r3, #4]
    1b6a:	3201      	adds	r2, #1
    1b6c:	605a      	str	r2, [r3, #4]
		if (_txbuf_index == CONF_GMAC_TXDESCR_NUM) {
    1b6e:	685b      	ldr	r3, [r3, #4]
    1b70:	2b02      	cmp	r3, #2
    1b72:	d106      	bne.n	1b82 <_mac_async_write+0xc2>
			_txbuf_index                                            = 0;
    1b74:	4b1e      	ldr	r3, [pc, #120]	; (1bf0 <_mac_async_write+0x130>)
    1b76:	2200      	movs	r2, #0
    1b78:	605a      	str	r2, [r3, #4]
			_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    1b7a:	7dda      	ldrb	r2, [r3, #23]
    1b7c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    1b80:	75da      	strb	r2, [r3, #23]
  __ASM volatile ("dsb 0xF":::"memory");
    1b82:	f3bf 8f4f 	dsb	sy

	/* Data synchronization barrier */
	__DSB();

	/* Active Transmit */
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_TSTART);
    1b86:	f8da 2000 	ldr.w	r2, [sl]
    1b8a:	6813      	ldr	r3, [r2, #0]
    1b8c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    1b90:	6013      	str	r3, [r2, #0]

	return ERR_NONE;
    1b92:	2000      	movs	r0, #0
    1b94:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1b98:	f207 57dc 	addw	r7, r7, #1500	; 0x5dc
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
    1b9c:	4547      	cmp	r7, r8
    1b9e:	d0f0      	beq.n	1b82 <_mac_async_write+0xc2>
		blen = min(len, CONF_GMAC_TXBUF_SIZE);
    1ba0:	f240 53dc 	movw	r3, #1500	; 0x5dc
    1ba4:	4625      	mov	r5, r4
    1ba6:	429c      	cmp	r4, r3
    1ba8:	bf28      	it	cs
    1baa:	461d      	movcs	r5, r3
		memcpy(_txbuf[_txbuf_index], buf + (i * CONF_GMAC_TXBUF_SIZE), blen);
    1bac:	6870      	ldr	r0, [r6, #4]
    1bae:	462a      	mov	r2, r5
    1bb0:	4639      	mov	r1, r7
    1bb2:	fb03 b000 	mla	r0, r3, r0, fp
    1bb6:	47c8      	blx	r9
		if (len > 0) {
    1bb8:	1b64      	subs	r4, r4, r5
    1bba:	d0c9      	beq.n	1b50 <_mac_async_write+0x90>
			_txbuf_descrs[_txbuf_index].status.val = blen;
    1bbc:	6873      	ldr	r3, [r6, #4]
    1bbe:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
    1bc2:	60dd      	str	r5, [r3, #12]
		_txbuf_index++;
    1bc4:	6873      	ldr	r3, [r6, #4]
    1bc6:	3301      	adds	r3, #1
    1bc8:	6073      	str	r3, [r6, #4]
		if (_txbuf_index == CONF_GMAC_TXDESCR_NUM) {
    1bca:	6873      	ldr	r3, [r6, #4]
    1bcc:	2b02      	cmp	r3, #2
    1bce:	d1e3      	bne.n	1b98 <_mac_async_write+0xd8>
			_txbuf_index                                            = 0;
    1bd0:	2300      	movs	r3, #0
    1bd2:	6073      	str	r3, [r6, #4]
			_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    1bd4:	7df3      	ldrb	r3, [r6, #23]
    1bd6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    1bda:	75f3      	strb	r3, [r6, #23]
    1bdc:	e7dc      	b.n	1b98 <_mac_async_write+0xd8>
		return ERR_NO_RESOURCE;
    1bde:	f06f 001b 	mvn.w	r0, #27
    1be2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				return ERR_NO_RESOURCE;
    1be6:	f06f 001b 	mvn.w	r0, #27
    1bea:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1bee:	bf00      	nop
    1bf0:	200001c0 	.word	0x200001c0
    1bf4:	000097ef 	.word	0x000097ef

00001bf8 <_mac_async_read>:
}

uint32_t _mac_async_read(struct _mac_async_device *const dev, uint8_t *buf, uint32_t len)
{
    1bf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1bfc:	b083      	sub	sp, #12
    1bfe:	9101      	str	r1, [sp, #4]
    1c00:	4691      	mov	r9, r2
	uint32_t i;
	uint32_t j;
	uint32_t pos;
	uint32_t n;
	uint32_t sof       = 0xFFFFFFFF; /* Start of Frame index */
    1c02:	f04f 37ff 	mov.w	r7, #4294967295
	uint32_t eof       = 0xFFFFFFFF; /* End of Frame index */
	uint32_t total_len = 0;          /* Total length of received package */

	(void)dev;
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1c06:	2400      	movs	r4, #0
		pos = _rxbuf_index + i;
    1c08:	4a45      	ldr	r2, [pc, #276]	; (1d20 <_mac_async_read+0x128>)
    1c0a:	e002      	b.n	1c12 <_mac_async_read+0x1a>
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1c0c:	3401      	adds	r4, #1
    1c0e:	2c10      	cmp	r4, #16
    1c10:	d074      	beq.n	1cfc <_mac_async_read+0x104>
		pos = _rxbuf_index + i;
    1c12:	f8d2 3368 	ldr.w	r3, [r2, #872]	; 0x368
    1c16:	4423      	add	r3, r4

		if (pos >= CONF_GMAC_RXDESCR_NUM) {
    1c18:	2b0f      	cmp	r3, #15
			pos -= CONF_GMAC_RXDESCR_NUM;
    1c1a:	bf88      	it	hi
    1c1c:	3b10      	subhi	r3, #16
		}

		/* No more data for Ethernet package */
		if (!_rxbuf_descrs[pos].address.bm.ownership) {
    1c1e:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    1c22:	f891 12e8 	ldrb.w	r1, [r1, #744]	; 0x2e8
    1c26:	f011 0f01 	tst.w	r1, #1
    1c2a:	d061      	beq.n	1cf0 <_mac_async_read+0xf8>
			break;
		}

		if (_rxbuf_descrs[pos].status.bm.sof) {
    1c2c:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    1c30:	f891 12ed 	ldrb.w	r1, [r1, #749]	; 0x2ed
    1c34:	f3c1 1180 	ubfx	r1, r1, #6, #1
    1c38:	2900      	cmp	r1, #0
    1c3a:	bf18      	it	ne
    1c3c:	4627      	movne	r7, r4
			sof = i;
		}

		if ((_rxbuf_descrs[pos].status.bm.eof) && (sof != 0xFFFFFFFF)) {
    1c3e:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    1c42:	f891 12ed 	ldrb.w	r1, [r1, #749]	; 0x2ed
    1c46:	09c9      	lsrs	r1, r1, #7
    1c48:	d0e0      	beq.n	1c0c <_mac_async_read+0x14>
    1c4a:	f1b7 3fff 	cmp.w	r7, #4294967295
    1c4e:	d0dd      	beq.n	1c0c <_mac_async_read+0x14>
			/* eof now indicate the number of bufs the frame used */
			eof = i;
			n   = _rxbuf_descrs[pos].status.bm.len;
    1c50:	4a33      	ldr	r2, [pc, #204]	; (1d20 <_mac_async_read+0x128>)
    1c52:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    1c56:	f8b3 32ec 	ldrh.w	r3, [r3, #748]	; 0x2ec
    1c5a:	f3c3 030c 	ubfx	r3, r3, #0, #13
			len = min(n, len);
    1c5e:	4599      	cmp	r9, r3
    1c60:	bf28      	it	cs
    1c62:	4699      	movcs	r9, r3
			/* Break process since the last data has been found */
			break;
		}
	}

	if (eof != 0xFFFFFFFF) {
    1c64:	f1b4 3fff 	cmp.w	r4, #4294967295
		j = eof + 1;
    1c68:	bf18      	it	ne
    1c6a:	f104 0801 	addne.w	r8, r4, #1
	if (eof != 0xFFFFFFFF) {
    1c6e:	d14b      	bne.n	1d08 <_mac_async_read+0x110>
    1c70:	46b8      	mov	r8, r7
    1c72:	e049      	b.n	1d08 <_mac_async_read+0x110>
			buf += n;
			total_len += n;
			len -= n;
		}

		_rxbuf_descrs[_rxbuf_index].address.bm.ownership = 0;
    1c74:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
    1c78:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
    1c7c:	f893 22e8 	ldrb.w	r2, [r3, #744]	; 0x2e8
    1c80:	f36f 0200 	bfc	r2, #0, #1
    1c84:	f883 22e8 	strb.w	r2, [r3, #744]	; 0x2e8
		_rxbuf_index++;
    1c88:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
    1c8c:	3301      	adds	r3, #1
    1c8e:	f8c5 3368 	str.w	r3, [r5, #872]	; 0x368

		if (_rxbuf_index == CONF_GMAC_RXDESCR_NUM) {
    1c92:	f8d5 3368 	ldr.w	r3, [r5, #872]	; 0x368
    1c96:	2b10      	cmp	r3, #16
			_rxbuf_index = 0;
    1c98:	bf04      	itt	eq
    1c9a:	2300      	moveq	r3, #0
    1c9c:	f8c5 3368 	streq.w	r3, [r5, #872]	; 0x368
	for (i = 0; i < j; i++) {
    1ca0:	3601      	adds	r6, #1
    1ca2:	4546      	cmp	r6, r8
    1ca4:	d020      	beq.n	1ce8 <_mac_async_read+0xf0>
		if (eof != 0xFFFFFFFF && i >= sof && i <= eof && len > 0) {
    1ca6:	f1b4 3fff 	cmp.w	r4, #4294967295
    1caa:	d0e3      	beq.n	1c74 <_mac_async_read+0x7c>
    1cac:	42be      	cmp	r6, r7
    1cae:	d3e1      	bcc.n	1c74 <_mac_async_read+0x7c>
    1cb0:	42a6      	cmp	r6, r4
    1cb2:	d8df      	bhi.n	1c74 <_mac_async_read+0x7c>
    1cb4:	f1b9 0f00 	cmp.w	r9, #0
    1cb8:	d0dc      	beq.n	1c74 <_mac_async_read+0x7c>
			n = min(len, CONF_GMAC_RXBUF_SIZE);
    1cba:	46cb      	mov	fp, r9
    1cbc:	f1b9 0f80 	cmp.w	r9, #128	; 0x80
    1cc0:	bf28      	it	cs
    1cc2:	f04f 0b80 	movcs.w	fp, #128	; 0x80
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    1cc6:	f8d5 1368 	ldr.w	r1, [r5, #872]	; 0x368
    1cca:	465a      	mov	r2, fp
    1ccc:	4b15      	ldr	r3, [pc, #84]	; (1d24 <_mac_async_read+0x12c>)
    1cce:	eb03 11c1 	add.w	r1, r3, r1, lsl #7
    1cd2:	9801      	ldr	r0, [sp, #4]
    1cd4:	4b14      	ldr	r3, [pc, #80]	; (1d28 <_mac_async_read+0x130>)
    1cd6:	4798      	blx	r3
			buf += n;
    1cd8:	9b01      	ldr	r3, [sp, #4]
    1cda:	445b      	add	r3, fp
    1cdc:	9301      	str	r3, [sp, #4]
			total_len += n;
    1cde:	44da      	add	sl, fp
			len -= n;
    1ce0:	eba9 090b 	sub.w	r9, r9, fp
    1ce4:	e7c6      	b.n	1c74 <_mac_async_read+0x7c>
	uint32_t total_len = 0;          /* Total length of received package */
    1ce6:	46c2      	mov	sl, r8
		}
	}

	return total_len;
}
    1ce8:	4650      	mov	r0, sl
    1cea:	b003      	add	sp, #12
    1cec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (sof != 0xFFFFFFFF) {
    1cf0:	f1b7 3fff 	cmp.w	r7, #4294967295
    1cf4:	d105      	bne.n	1d02 <_mac_async_read+0x10a>
    1cf6:	46a0      	mov	r8, r4
    1cf8:	463c      	mov	r4, r7
    1cfa:	e005      	b.n	1d08 <_mac_async_read+0x110>
    1cfc:	f1b7 3fff 	cmp.w	r7, #4294967295
    1d00:	d00a      	beq.n	1d18 <_mac_async_read+0x120>
		if (_rxbuf_descrs[pos].status.bm.sof) {
    1d02:	46b8      	mov	r8, r7
    1d04:	f04f 34ff 	mov.w	r4, #4294967295
	for (i = 0; i < j; i++) {
    1d08:	f1b8 0f00 	cmp.w	r8, #0
    1d0c:	d0eb      	beq.n	1ce6 <_mac_async_read+0xee>
	} else if (sof != 0xFFFFFFFF) {
    1d0e:	f04f 0a00 	mov.w	sl, #0
    1d12:	4656      	mov	r6, sl
			memcpy(buf, _rxbuf[_rxbuf_index], n);
    1d14:	4d02      	ldr	r5, [pc, #8]	; (1d20 <_mac_async_read+0x128>)
    1d16:	e7c6      	b.n	1ca6 <_mac_async_read+0xae>
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1d18:	46a0      	mov	r8, r4
	} else if (sof != 0xFFFFFFFF) {
    1d1a:	463c      	mov	r4, r7
    1d1c:	e7f7      	b.n	1d0e <_mac_async_read+0x116>
    1d1e:	bf00      	nop
    1d20:	200012b8 	.word	0x200012b8
    1d24:	20000da0 	.word	0x20000da0
    1d28:	000097ef 	.word	0x000097ef

00001d2c <_mac_async_read_len>:

uint32_t _mac_async_read_len(struct _mac_async_device *const dev)
{
    1d2c:	b470      	push	{r4, r5, r6}
	uint32_t i;
	uint32_t pos;
	bool     sof       = false; /* Start of Frame */
	uint32_t total_len = 0;     /* Total length of received package */
    1d2e:	2000      	movs	r0, #0
	bool     sof       = false; /* Start of Frame */
    1d30:	4606      	mov	r6, r0

	(void)dev;

	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1d32:	4601      	mov	r1, r0
		pos = _rxbuf_index + i;
    1d34:	4a16      	ldr	r2, [pc, #88]	; (1d90 <_mac_async_read_len+0x64>)

		if (_rxbuf_descrs[pos].status.bm.sof) {
			sof = true;
		}
		if (sof == true) {
			total_len += _rxbuf_descrs[pos].status.bm.len;
    1d36:	2501      	movs	r5, #1
    1d38:	e010      	b.n	1d5c <_mac_async_read_len+0x30>
    1d3a:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
    1d3e:	f8b4 42ec 	ldrh.w	r4, [r4, #748]	; 0x2ec
    1d42:	f3c4 040c 	ubfx	r4, r4, #0, #13
    1d46:	4420      	add	r0, r4
    1d48:	462e      	mov	r6, r5
		}

		if (_rxbuf_descrs[pos].status.bm.eof) {
    1d4a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    1d4e:	f893 32ed 	ldrb.w	r3, [r3, #749]	; 0x2ed
    1d52:	09db      	lsrs	r3, r3, #7
    1d54:	d119      	bne.n	1d8a <_mac_async_read_len+0x5e>
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    1d56:	3101      	adds	r1, #1
    1d58:	2910      	cmp	r1, #16
    1d5a:	d016      	beq.n	1d8a <_mac_async_read_len+0x5e>
		pos = _rxbuf_index + i;
    1d5c:	f8d2 3368 	ldr.w	r3, [r2, #872]	; 0x368
    1d60:	440b      	add	r3, r1
		if (pos >= CONF_GMAC_RXDESCR_NUM) {
    1d62:	2b0f      	cmp	r3, #15
			pos -= CONF_GMAC_RXDESCR_NUM;
    1d64:	bf88      	it	hi
    1d66:	3b10      	subhi	r3, #16
		if (!(_rxbuf_descrs[pos].address.bm.ownership)) {
    1d68:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
    1d6c:	f894 42e8 	ldrb.w	r4, [r4, #744]	; 0x2e8
    1d70:	f014 0f01 	tst.w	r4, #1
    1d74:	d009      	beq.n	1d8a <_mac_async_read_len+0x5e>
		if (_rxbuf_descrs[pos].status.bm.sof) {
    1d76:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
    1d7a:	f894 42ed 	ldrb.w	r4, [r4, #749]	; 0x2ed
    1d7e:	f014 0f40 	tst.w	r4, #64	; 0x40
    1d82:	d1da      	bne.n	1d3a <_mac_async_read_len+0xe>
		if (sof == true) {
    1d84:	2e00      	cmp	r6, #0
    1d86:	d0e0      	beq.n	1d4a <_mac_async_read_len+0x1e>
    1d88:	e7d7      	b.n	1d3a <_mac_async_read_len+0xe>
			break;
		}
	}

	return total_len;
}
    1d8a:	bc70      	pop	{r4, r5, r6}
    1d8c:	4770      	bx	lr
    1d8e:	bf00      	nop
    1d90:	200012b8 	.word	0x200012b8

00001d94 <_mac_async_register_callback>:
}

int32_t _mac_async_register_callback(struct _mac_async_device *const dev, const enum mac_async_cb_type type,
                                     const FUNC_PTR func)
{
	switch (type) {
    1d94:	b169      	cbz	r1, 1db2 <_mac_async_register_callback+0x1e>
    1d96:	2901      	cmp	r1, #1
    1d98:	d111      	bne.n	1dbe <_mac_async_register_callback+0x2a>
	case MAC_ASYNC_TRANSMIT_CB:
		dev->cb.transmited = (_mac_async_cb_t)func;
    1d9a:	6042      	str	r2, [r0, #4]
		if (func) {
    1d9c:	b122      	cbz	r2, 1da8 <_mac_async_register_callback+0x14>
			hri_gmac_set_IMR_TCOMP_bit(dev->hw);
    1d9e:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->IER.reg = GMAC_IMR_TCOMP;
    1da0:	2280      	movs	r2, #128	; 0x80
    1da2:	629a      	str	r2, [r3, #40]	; 0x28
		}
		break;
	default:
		return ERR_INVALID_ARG;
	}
	return ERR_NONE;
    1da4:	2000      	movs	r0, #0
    1da6:	4770      	bx	lr
			hri_gmac_clear_IMR_TCOMP_bit(dev->hw);
    1da8:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->IDR.reg = GMAC_IMR_TCOMP;
    1daa:	2280      	movs	r2, #128	; 0x80
    1dac:	62da      	str	r2, [r3, #44]	; 0x2c
	return ERR_NONE;
    1dae:	2000      	movs	r0, #0
    1db0:	4770      	bx	lr
		dev->cb.received = (_mac_async_cb_t)func;
    1db2:	6082      	str	r2, [r0, #8]
			hri_gmac_set_IMR_RCOMP_bit(dev->hw);
    1db4:	6803      	ldr	r3, [r0, #0]
	((Gmac *)hw)->IER.reg = GMAC_IMR_RCOMP;
    1db6:	2202      	movs	r2, #2
    1db8:	629a      	str	r2, [r3, #40]	; 0x28
	return ERR_NONE;
    1dba:	2000      	movs	r0, #0
    1dbc:	4770      	bx	lr
		return ERR_INVALID_ARG;
    1dbe:	f06f 000c 	mvn.w	r0, #12
}
    1dc2:	4770      	bx	lr

00001dc4 <_mac_async_set_filter>:

int32_t _mac_async_set_filter(struct _mac_async_device *const dev, uint8_t index, struct mac_async_filter *filter)
{
    1dc4:	b570      	push	{r4, r5, r6, lr}
    1dc6:	4606      	mov	r6, r0
    1dc8:	460c      	mov	r4, r1
    1dca:	4615      	mov	r5, r2
	ASSERT(index < 4);
    1dcc:	f240 12cf 	movw	r2, #463	; 0x1cf
    1dd0:	490c      	ldr	r1, [pc, #48]	; (1e04 <_mac_async_set_filter+0x40>)
    1dd2:	2c03      	cmp	r4, #3
    1dd4:	bf8c      	ite	hi
    1dd6:	2000      	movhi	r0, #0
    1dd8:	2001      	movls	r0, #1
    1dda:	4b0b      	ldr	r3, [pc, #44]	; (1e08 <_mac_async_set_filter+0x44>)
    1ddc:	4798      	blx	r3

	hri_gmac_write_SAB_reg(dev->hw, index, *((uint32_t *)(filter->mac)));
    1dde:	6833      	ldr	r3, [r6, #0]
    1de0:	6829      	ldr	r1, [r5, #0]
	((Gmac *)hw)->Sa[submodule_index].SAB.reg = data;
    1de2:	f104 0211 	add.w	r2, r4, #17
    1de6:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
	hri_gmac_write_SAT_reg(dev->hw, index, *((uint16_t *)(filter->mac + 4)));
    1dea:	6833      	ldr	r3, [r6, #0]
    1dec:	88a9      	ldrh	r1, [r5, #4]
	((Gmac *)hw)->Sa[submodule_index].SAT.reg = data;
    1dee:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    1df2:	6059      	str	r1, [r3, #4]

	hri_gmac_write_TIDM_reg(dev->hw, index, GMAC_TIDM_TID(*((uint16_t *)(filter->tid)) | filter->tid_enable << 31));
    1df4:	6833      	ldr	r3, [r6, #0]
    1df6:	88ea      	ldrh	r2, [r5, #6]
	((Gmac *)hw)->TIDM[index].reg = data;
    1df8:	342a      	adds	r4, #42	; 0x2a
    1dfa:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
	return ERR_NONE;
}
    1dfe:	2000      	movs	r0, #0
    1e00:	bd70      	pop	{r4, r5, r6, pc}
    1e02:	bf00      	nop
    1e04:	0000a9e0 	.word	0x0000a9e0
    1e08:	000016f5 	.word	0x000016f5

00001e0c <_mac_async_write_phy_reg>:

	return ERR_NONE;
}

int32_t _mac_async_write_phy_reg(struct _mac_async_device *const dev, uint16_t addr, uint16_t reg, uint16_t data)
{
    1e0c:	b430      	push	{r4, r5}
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_MPE);
    1e0e:	6805      	ldr	r5, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    1e10:	682c      	ldr	r4, [r5, #0]
    1e12:	f044 0410 	orr.w	r4, r4, #16
    1e16:	602c      	str	r4, [r5, #0]
	hri_gmac_write_MAN_reg(dev->hw,
    1e18:	6804      	ldr	r4, [r0, #0]
	                       GMAC_MAN_OP(1) |            /* 0x01 write operation */
	                           CONF_GMAC_CLTTO << 30 | /* Clause 22/45 operation */
	                           GMAC_MAN_WTN(2) |       /* Must be written to 0x2 */
	                           GMAC_MAN_PHYA(addr) | GMAC_MAN_REGA(reg) | GMAC_MAN_DATA(data));
    1e1a:	0492      	lsls	r2, r2, #18
    1e1c:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
    1e20:	f043 43a0 	orr.w	r3, r3, #1342177280	; 0x50000000
    1e24:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    1e28:	431a      	orrs	r2, r3
    1e2a:	05c9      	lsls	r1, r1, #23
    1e2c:	f001 6178 	and.w	r1, r1, #260046848	; 0xf800000
    1e30:	430a      	orrs	r2, r1
	((Gmac *)hw)->MAN.reg = data;
    1e32:	6362      	str	r2, [r4, #52]	; 0x34
	/* Wait for the write operation complete */
	while (!hri_gmac_get_NSR_IDLE_bit(dev->hw)) {
    1e34:	6802      	ldr	r2, [r0, #0]
	return (((Gmac *)hw)->NSR.reg & GMAC_NSR_IDLE) >> GMAC_NSR_IDLE_Pos;
    1e36:	6893      	ldr	r3, [r2, #8]
    1e38:	f013 0f04 	tst.w	r3, #4
    1e3c:	d0fb      	beq.n	1e36 <_mac_async_write_phy_reg+0x2a>
	((Gmac *)hw)->NCR.reg &= ~mask;
    1e3e:	6813      	ldr	r3, [r2, #0]
    1e40:	f023 0310 	bic.w	r3, r3, #16
    1e44:	6013      	str	r3, [r2, #0]
	}

	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_MPE);
	return ERR_NONE;
}
    1e46:	2000      	movs	r0, #0
    1e48:	bc30      	pop	{r4, r5}
    1e4a:	4770      	bx	lr

00001e4c <_mac_async_read_phy_reg>:

int32_t _mac_async_read_phy_reg(struct _mac_async_device *const dev, uint16_t addr, uint16_t reg, uint16_t *data)
{
    1e4c:	b430      	push	{r4, r5}
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_MPE);
    1e4e:	6805      	ldr	r5, [r0, #0]
	((Gmac *)hw)->NCR.reg |= mask;
    1e50:	682c      	ldr	r4, [r5, #0]
    1e52:	f044 0410 	orr.w	r4, r4, #16
    1e56:	602c      	str	r4, [r5, #0]
	hri_gmac_write_MAN_reg(dev->hw,
    1e58:	6804      	ldr	r4, [r0, #0]
	                       GMAC_MAN_OP(2) |            /* 0x02 read operation */
	                           CONF_GMAC_CLTTO << 30 | /* Clause 22/45 operation */
	                           GMAC_MAN_WTN(0x2) |     /* Must be written to 0x2 */
	                           GMAC_MAN_PHYA(addr) | GMAC_MAN_REGA(reg));
    1e5a:	0492      	lsls	r2, r2, #18
    1e5c:	f402 02f8 	and.w	r2, r2, #8126464	; 0x7c0000
    1e60:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
    1e64:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
    1e68:	05c9      	lsls	r1, r1, #23
    1e6a:	f001 6178 	and.w	r1, r1, #260046848	; 0xf800000
    1e6e:	430a      	orrs	r2, r1
	((Gmac *)hw)->MAN.reg = data;
    1e70:	6362      	str	r2, [r4, #52]	; 0x34

	/* Wait for the read operation complete */
	while (!hri_gmac_get_NSR_IDLE_bit(dev->hw)) {
    1e72:	6801      	ldr	r1, [r0, #0]
	return (((Gmac *)hw)->NSR.reg & GMAC_NSR_IDLE) >> GMAC_NSR_IDLE_Pos;
    1e74:	688a      	ldr	r2, [r1, #8]
    1e76:	f012 0f04 	tst.w	r2, #4
    1e7a:	d0fb      	beq.n	1e74 <_mac_async_read_phy_reg+0x28>
	return ((Gmac *)hw)->MAN.reg;
    1e7c:	6b4a      	ldr	r2, [r1, #52]	; 0x34
	}

	*data = GMAC_MAN_DATA(hri_gmac_read_MAN_reg(dev->hw));
    1e7e:	801a      	strh	r2, [r3, #0]
	hri_gmac_clear_NCR_reg(dev->hw, GMAC_NCR_MPE);
    1e80:	6802      	ldr	r2, [r0, #0]
	((Gmac *)hw)->NCR.reg &= ~mask;
    1e82:	6813      	ldr	r3, [r2, #0]
    1e84:	f023 0310 	bic.w	r3, r3, #16
    1e88:	6013      	str	r3, [r2, #0]

	return ERR_NONE;
}
    1e8a:	2000      	movs	r0, #0
    1e8c:	bc30      	pop	{r4, r5}
    1e8e:	4770      	bx	lr

00001e90 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    1e90:	2201      	movs	r2, #1
    1e92:	4b01      	ldr	r3, [pc, #4]	; (1e98 <_mclk_init+0x8>)
    1e94:	715a      	strb	r2, [r3, #5]
    1e96:	4770      	bx	lr
    1e98:	40000800 	.word	0x40000800

00001e9c <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    1e9c:	4b03      	ldr	r3, [pc, #12]	; (1eac <_osc32kctrl_init_sources+0x10>)
    1e9e:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    1ea0:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    1ea4:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    1ea6:	2201      	movs	r2, #1
    1ea8:	741a      	strb	r2, [r3, #16]
    1eaa:	4770      	bx	lr
    1eac:	40001400 	.word	0x40001400

00001eb0 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    1eb0:	4a08      	ldr	r2, [pc, #32]	; (1ed4 <_oscctrl_init_sources+0x24>)
    1eb2:	4b09      	ldr	r3, [pc, #36]	; (1ed8 <_oscctrl_init_sources+0x28>)
    1eb4:	615a      	str	r2, [r3, #20]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY0) >> OSCCTRL_STATUS_XOSCRDY0_Pos;
    1eb6:	461a      	mov	r2, r3
    1eb8:	6913      	ldr	r3, [r2, #16]
	        | (CONF_XOSC0_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC0_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC0_CONFIG == 1
#if CONF_XOSC0_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY0_bit(hw))
    1eba:	f013 0f01 	tst.w	r3, #1
    1ebe:	d0fb      	beq.n	1eb8 <_oscctrl_init_sources+0x8>
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    1ec0:	4a06      	ldr	r2, [pc, #24]	; (1edc <_oscctrl_init_sources+0x2c>)
    1ec2:	4b05      	ldr	r3, [pc, #20]	; (1ed8 <_oscctrl_init_sources+0x28>)
    1ec4:	619a      	str	r2, [r3, #24]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
    1ec6:	461a      	mov	r2, r3
    1ec8:	6913      	ldr	r3, [r2, #16]
	        | (CONF_XOSC1_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
    1eca:	f013 0f02 	tst.w	r3, #2
    1ece:	d0fb      	beq.n	1ec8 <_oscctrl_init_sources+0x18>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    1ed0:	4770      	bx	lr
    1ed2:	bf00      	nop
    1ed4:	03002602 	.word	0x03002602
    1ed8:	40001000 	.word	0x40001000
    1edc:	03002606 	.word	0x03002606

00001ee0 <_oscctrl_init_referenced_generators>:
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLRATIO.reg = data;
    1ee0:	223b      	movs	r2, #59	; 0x3b
    1ee2:	4b0e      	ldr	r3, [pc, #56]	; (1f1c <_oscctrl_init_referenced_generators+0x3c>)
    1ee4:	635a      	str	r2, [r3, #52]	; 0x34
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    1ee6:	461a      	mov	r2, r3
    1ee8:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
    1eea:	f013 0f06 	tst.w	r3, #6
    1eee:	d1fb      	bne.n	1ee8 <_oscctrl_init_referenced_generators+0x8>
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLB.reg = data;
    1ef0:	4b0a      	ldr	r3, [pc, #40]	; (1f1c <_oscctrl_init_referenced_generators+0x3c>)
    1ef2:	4a0b      	ldr	r2, [pc, #44]	; (1f20 <_oscctrl_init_referenced_generators+0x40>)
    1ef4:	639a      	str	r2, [r3, #56]	; 0x38
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLA.reg = data;
    1ef6:	2202      	movs	r2, #2
    1ef8:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    1efc:	461a      	mov	r2, r3
    1efe:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
    1f00:	f013 0f02 	tst.w	r3, #2
    1f04:	d1fb      	bne.n	1efe <_oscctrl_init_referenced_generators+0x1e>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_LOCK)
    1f06:	4b05      	ldr	r3, [pc, #20]	; (1f1c <_oscctrl_init_referenced_generators+0x3c>)
    1f08:	6c1a      	ldr	r2, [r3, #64]	; 0x40
#endif
#endif

#if CONF_FDPLL0_CONFIG == 1
#if CONF_FDPLL0_ENABLE == 1
	while (!(hri_oscctrl_get_DPLLSTATUS_LOCK_bit(hw, 0) || hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit(hw, 0)))
    1f0a:	f012 0f01 	tst.w	r2, #1
    1f0e:	d103      	bne.n	1f18 <_oscctrl_init_referenced_generators+0x38>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_CLKRDY)
    1f10:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    1f12:	f012 0f02 	tst.w	r2, #2
    1f16:	d0f7      	beq.n	1f08 <_oscctrl_init_referenced_generators+0x28>
    1f18:	4770      	bx	lr
    1f1a:	bf00      	nop
    1f1c:	40001000 	.word	0x40001000
    1f20:	00020040 	.word	0x00020040

00001f24 <RAMECC_Handler>:

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    1f24:	b500      	push	{lr}
    1f26:	b083      	sub	sp, #12
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    1f28:	4b0d      	ldr	r3, [pc, #52]	; (1f60 <RAMECC_Handler+0x3c>)
    1f2a:	789b      	ldrb	r3, [r3, #2]
    1f2c:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    1f2e:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    1f30:	9b01      	ldr	r3, [sp, #4]
    1f32:	f013 0f02 	tst.w	r3, #2
    1f36:	d006      	beq.n	1f46 <RAMECC_Handler+0x22>
    1f38:	4b0a      	ldr	r3, [pc, #40]	; (1f64 <RAMECC_Handler+0x40>)
    1f3a:	681b      	ldr	r3, [r3, #0]
    1f3c:	b11b      	cbz	r3, 1f46 <RAMECC_Handler+0x22>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    1f3e:	4a08      	ldr	r2, [pc, #32]	; (1f60 <RAMECC_Handler+0x3c>)
    1f40:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.dual_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    1f42:	4798      	blx	r3
    1f44:	e009      	b.n	1f5a <RAMECC_Handler+0x36>
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    1f46:	9b01      	ldr	r3, [sp, #4]
    1f48:	f013 0f01 	tst.w	r3, #1
    1f4c:	d005      	beq.n	1f5a <RAMECC_Handler+0x36>
    1f4e:	4b05      	ldr	r3, [pc, #20]	; (1f64 <RAMECC_Handler+0x40>)
    1f50:	685b      	ldr	r3, [r3, #4]
    1f52:	b113      	cbz	r3, 1f5a <RAMECC_Handler+0x36>
    1f54:	4a02      	ldr	r2, [pc, #8]	; (1f60 <RAMECC_Handler+0x3c>)
    1f56:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    1f58:	4798      	blx	r3
	} else {
		return;
	}
}
    1f5a:	b003      	add	sp, #12
    1f5c:	f85d fb04 	ldr.w	pc, [sp], #4
    1f60:	41020000 	.word	0x41020000
    1f64:	200082c8 	.word	0x200082c8

00001f68 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    1f68:	b470      	push	{r4, r5, r6}
    1f6a:	b089      	sub	sp, #36	; 0x24
    1f6c:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    1f6e:	466c      	mov	r4, sp
    1f70:	4d0d      	ldr	r5, [pc, #52]	; (1fa8 <_sercom_get_hardware_index+0x40>)
    1f72:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    1f74:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1f76:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    1f7a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    1f7e:	9b00      	ldr	r3, [sp, #0]
    1f80:	42b3      	cmp	r3, r6
    1f82:	d00d      	beq.n	1fa0 <_sercom_get_hardware_index+0x38>
    1f84:	4631      	mov	r1, r6
    1f86:	ab01      	add	r3, sp, #4
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    1f88:	2001      	movs	r0, #1
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    1f8a:	f853 2b04 	ldr.w	r2, [r3], #4
    1f8e:	428a      	cmp	r2, r1
    1f90:	d007      	beq.n	1fa2 <_sercom_get_hardware_index+0x3a>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    1f92:	3001      	adds	r0, #1
    1f94:	2808      	cmp	r0, #8
    1f96:	d1f8      	bne.n	1f8a <_sercom_get_hardware_index+0x22>
			return i;
		}
	}
	return 0;
    1f98:	2000      	movs	r0, #0
}
    1f9a:	b009      	add	sp, #36	; 0x24
    1f9c:	bc70      	pop	{r4, r5, r6}
    1f9e:	4770      	bx	lr
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    1fa0:	2000      	movs	r0, #0
			return i;
    1fa2:	b2c0      	uxtb	r0, r0
    1fa4:	e7f9      	b.n	1f9a <_sercom_get_hardware_index+0x32>
    1fa6:	bf00      	nop
    1fa8:	0000a9f8 	.word	0x0000a9f8

00001fac <_sercom_usart_interrupt_handler>:
 * \internal Sercom interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _sercom_usart_interrupt_handler(struct _usart_async_device *device)
{
    1fac:	b510      	push	{r4, lr}
	void *hw = device->hw;
    1fae:	6984      	ldr	r4, [r0, #24]
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    1fb0:	7e23      	ldrb	r3, [r4, #24]

	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
    1fb2:	f013 0f01 	tst.w	r3, #1
    1fb6:	d003      	beq.n	1fc0 <_sercom_usart_interrupt_handler+0x14>
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
}

static inline bool hri_sercomusart_get_INTEN_DRE_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
    1fb8:	7da3      	ldrb	r3, [r4, #22]
    1fba:	f013 0f01 	tst.w	r3, #1
    1fbe:	d112      	bne.n	1fe6 <_sercom_usart_interrupt_handler+0x3a>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    1fc0:	7e23      	ldrb	r3, [r4, #24]
		hri_sercomusart_clear_INTEN_DRE_bit(hw);
		device->usart_cb.tx_byte_sent(device);
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
    1fc2:	f013 0f02 	tst.w	r3, #2
    1fc6:	d003      	beq.n	1fd0 <_sercom_usart_interrupt_handler+0x24>
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
}

static inline bool hri_sercomusart_get_INTEN_TXC_bit(const void *const hw)
{
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
    1fc8:	7da3      	ldrb	r3, [r4, #22]
    1fca:	f013 0f02 	tst.w	r3, #2
    1fce:	d10f      	bne.n	1ff0 <_sercom_usart_interrupt_handler+0x44>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    1fd0:	7e23      	ldrb	r3, [r4, #24]
		hri_sercomusart_clear_INTEN_TXC_bit(hw);
		device->usart_cb.tx_done_cb(device);
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
    1fd2:	f013 0f04 	tst.w	r3, #4
    1fd6:	d015      	beq.n	2004 <_sercom_usart_interrupt_handler+0x58>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
    1fd8:	8b63      	ldrh	r3, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
    1fda:	f003 0337 	and.w	r3, r3, #55	; 0x37
    1fde:	b163      	cbz	r3, 1ffa <_sercom_usart_interrupt_handler+0x4e>
	((Sercom *)hw)->USART.STATUS.reg = mask;
    1fe0:	23ff      	movs	r3, #255	; 0xff
    1fe2:	8363      	strh	r3, [r4, #26]
    1fe4:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
    1fe6:	2301      	movs	r3, #1
    1fe8:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_byte_sent(device);
    1fea:	6803      	ldr	r3, [r0, #0]
    1fec:	4798      	blx	r3
    1fee:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
    1ff0:	2302      	movs	r3, #2
    1ff2:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_done_cb(device);
    1ff4:	6883      	ldr	r3, [r0, #8]
    1ff6:	4798      	blx	r3
    1ff8:	bd10      	pop	{r4, pc}
	return ((Sercom *)hw)->USART.DATA.reg;
    1ffa:	6aa1      	ldr	r1, [r4, #40]	; 0x28
		       | SERCOM_USART_STATUS_ISF | SERCOM_USART_STATUS_COLL)) {
			hri_sercomusart_clear_STATUS_reg(hw, SERCOM_USART_STATUS_MASK);
			return;
		}

		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
    1ffc:	6843      	ldr	r3, [r0, #4]
    1ffe:	b2c9      	uxtb	r1, r1
    2000:	4798      	blx	r3
    2002:	bd10      	pop	{r4, pc}
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
    2004:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
    2006:	09db      	lsrs	r3, r3, #7
    2008:	d100      	bne.n	200c <_sercom_usart_interrupt_handler+0x60>
    200a:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
    200c:	2380      	movs	r3, #128	; 0x80
    200e:	7623      	strb	r3, [r4, #24]
		uint32_t status;

		hri_sercomusart_clear_interrupt_ERROR_bit(hw);
		device->usart_cb.error_cb(device);
    2010:	68c3      	ldr	r3, [r0, #12]
    2012:	4798      	blx	r3
	return ((Sercom *)hw)->USART.STATUS.reg;
    2014:	8b63      	ldrh	r3, [r4, #26]
    2016:	b29b      	uxth	r3, r3
	((Sercom *)hw)->USART.STATUS.reg = mask;
    2018:	8363      	strh	r3, [r4, #26]
    201a:	e7f6      	b.n	200a <_sercom_usart_interrupt_handler+0x5e>

0000201c <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
    201c:	b508      	push	{r3, lr}
	return SERCOM0_0_IRQn + (_sercom_get_hardware_index(hw) << 2);
    201e:	4b03      	ldr	r3, [pc, #12]	; (202c <_sercom_get_irq_num+0x10>)
    2020:	4798      	blx	r3
    2022:	0080      	lsls	r0, r0, #2
    2024:	302e      	adds	r0, #46	; 0x2e
}
    2026:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
    202a:	bd08      	pop	{r3, pc}
    202c:	00001f69 	.word	0x00001f69

00002030 <_usart_init>:
{
    2030:	b510      	push	{r4, lr}
    2032:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    2034:	4b41      	ldr	r3, [pc, #260]	; (213c <_usart_init+0x10c>)
    2036:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
    2038:	2801      	cmp	r0, #1
    203a:	d05c      	beq.n	20f6 <_usart_init+0xc6>
    203c:	2805      	cmp	r0, #5
    203e:	d05c      	beq.n	20fa <_usart_init+0xca>
	ASSERT(false);
    2040:	f240 226b 	movw	r2, #619	; 0x26b
    2044:	493e      	ldr	r1, [pc, #248]	; (2140 <_usart_init+0x110>)
    2046:	2000      	movs	r0, #0
    2048:	4b3e      	ldr	r3, [pc, #248]	; (2144 <_usart_init+0x114>)
    204a:	4798      	blx	r3
	return 0;
    204c:	2100      	movs	r1, #0
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    204e:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    2050:	f013 0f01 	tst.w	r3, #1
    2054:	d122      	bne.n	209c <_usart_init+0x6c>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
    2056:	004b      	lsls	r3, r1, #1
    2058:	185a      	adds	r2, r3, r1
    205a:	4b3b      	ldr	r3, [pc, #236]	; (2148 <_usart_init+0x118>)
    205c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    2060:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    2062:	f002 021c 	and.w	r2, r2, #28
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2066:	69e3      	ldr	r3, [r4, #28]
    2068:	f013 0f03 	tst.w	r3, #3
    206c:	d1fb      	bne.n	2066 <_usart_init+0x36>
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    206e:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    2070:	f013 0f02 	tst.w	r3, #2
    2074:	d00b      	beq.n	208e <_usart_init+0x5e>
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    2076:	6823      	ldr	r3, [r4, #0]
    2078:	f023 0302 	bic.w	r3, r3, #2
    207c:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    207e:	69e3      	ldr	r3, [r4, #28]
    2080:	f013 0f03 	tst.w	r3, #3
    2084:	d1fb      	bne.n	207e <_usart_init+0x4e>
    2086:	69e3      	ldr	r3, [r4, #28]
    2088:	f013 0f02 	tst.w	r3, #2
    208c:	d1fb      	bne.n	2086 <_usart_init+0x56>
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
    208e:	f042 0201 	orr.w	r2, r2, #1
	((Sercom *)hw)->USART.CTRLA.reg = data;
    2092:	6022      	str	r2, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2094:	69e3      	ldr	r3, [r4, #28]
    2096:	f013 0f03 	tst.w	r3, #3
    209a:	d1fb      	bne.n	2094 <_usart_init+0x64>
    209c:	69e3      	ldr	r3, [r4, #28]
    209e:	f013 0f01 	tst.w	r3, #1
    20a2:	d1fb      	bne.n	209c <_usart_init+0x6c>
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    20a4:	460a      	mov	r2, r1
    20a6:	004b      	lsls	r3, r1, #1
    20a8:	440b      	add	r3, r1
    20aa:	4927      	ldr	r1, [pc, #156]	; (2148 <_usart_init+0x118>)
    20ac:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
    20b0:	6a48      	ldr	r0, [r1, #36]	; 0x24
	((Sercom *)hw)->USART.CTRLA.reg = data;
    20b2:	6020      	str	r0, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    20b4:	69e3      	ldr	r3, [r4, #28]
    20b6:	f013 0f03 	tst.w	r3, #3
    20ba:	d1fb      	bne.n	20b4 <_usart_init+0x84>
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    20bc:	0053      	lsls	r3, r2, #1
    20be:	1899      	adds	r1, r3, r2
    20c0:	4b21      	ldr	r3, [pc, #132]	; (2148 <_usart_init+0x118>)
    20c2:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    20c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	((Sercom *)hw)->USART.CTRLB.reg = data;
    20c8:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    20ca:	69e3      	ldr	r3, [r4, #28]
    20cc:	f013 0f1f 	tst.w	r3, #31
    20d0:	d1fb      	bne.n	20ca <_usart_init+0x9a>
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
    20d2:	0053      	lsls	r3, r2, #1
    20d4:	1899      	adds	r1, r3, r2
    20d6:	4b1c      	ldr	r3, [pc, #112]	; (2148 <_usart_init+0x118>)
    20d8:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    20dc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	((Sercom *)hw)->USART.CTRLC.reg = data;
    20de:	60a3      	str	r3, [r4, #8]
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
    20e0:	f410 4fc0 	tst.w	r0, #24576	; 0x6000
    20e4:	d10b      	bne.n	20fe <_usart_init+0xce>
		hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    20e6:	0053      	lsls	r3, r2, #1
    20e8:	1899      	adds	r1, r3, r2
    20ea:	4b17      	ldr	r3, [pc, #92]	; (2148 <_usart_init+0x118>)
    20ec:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    20f0:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
	((Sercom *)hw)->USART.BAUD.reg = data;
    20f2:	81a3      	strh	r3, [r4, #12]
    20f4:	e011      	b.n	211a <_usart_init+0xea>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    20f6:	2100      	movs	r1, #0
    20f8:	e7a9      	b.n	204e <_usart_init+0x1e>
		if (_usarts[i].number == sercom_offset) {
    20fa:	2101      	movs	r1, #1
    20fc:	e7a7      	b.n	204e <_usart_init+0x1e>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
    20fe:	4b12      	ldr	r3, [pc, #72]	; (2148 <_usart_init+0x118>)
    2100:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    2104:	8e18      	ldrh	r0, [r3, #48]	; 0x30
    2106:	89a1      	ldrh	r1, [r4, #12]
    2108:	f360 010c 	bfi	r1, r0, #0, #13
    210c:	81a1      	strh	r1, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
    210e:	f893 1032 	ldrb.w	r1, [r3, #50]	; 0x32
    2112:	89a3      	ldrh	r3, [r4, #12]
    2114:	f361 334f 	bfi	r3, r1, #13, #3
    2118:	81a3      	strh	r3, [r4, #12]
	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
    211a:	4b0b      	ldr	r3, [pc, #44]	; (2148 <_usart_init+0x118>)
    211c:	0051      	lsls	r1, r2, #1
    211e:	1888      	adds	r0, r1, r2
    2120:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    2124:	f890 0033 	ldrb.w	r0, [r0, #51]	; 0x33
	((Sercom *)hw)->USART.RXPL.reg = data;
    2128:	73a0      	strb	r0, [r4, #14]
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    212a:	440a      	add	r2, r1
    212c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    2130:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    2134:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
    2138:	2000      	movs	r0, #0
    213a:	bd10      	pop	{r4, pc}
    213c:	00001f69 	.word	0x00001f69
    2140:	0000aa60 	.word	0x0000aa60
    2144:	000016f5 	.word	0x000016f5
    2148:	0000a9f8 	.word	0x0000a9f8

0000214c <_usart_sync_init>:
{
    214c:	b538      	push	{r3, r4, r5, lr}
    214e:	460c      	mov	r4, r1
	ASSERT(device);
    2150:	4605      	mov	r5, r0
    2152:	22bd      	movs	r2, #189	; 0xbd
    2154:	4905      	ldr	r1, [pc, #20]	; (216c <_usart_sync_init+0x20>)
    2156:	3000      	adds	r0, #0
    2158:	bf18      	it	ne
    215a:	2001      	movne	r0, #1
    215c:	4b04      	ldr	r3, [pc, #16]	; (2170 <_usart_sync_init+0x24>)
    215e:	4798      	blx	r3
	device->hw = hw;
    2160:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
    2162:	4620      	mov	r0, r4
    2164:	4b03      	ldr	r3, [pc, #12]	; (2174 <_usart_sync_init+0x28>)
    2166:	4798      	blx	r3
}
    2168:	bd38      	pop	{r3, r4, r5, pc}
    216a:	bf00      	nop
    216c:	0000aa60 	.word	0x0000aa60
    2170:	000016f5 	.word	0x000016f5
    2174:	00002031 	.word	0x00002031

00002178 <_usart_async_init>:
{
    2178:	b570      	push	{r4, r5, r6, lr}
    217a:	460d      	mov	r5, r1
	ASSERT(device);
    217c:	4606      	mov	r6, r0
    217e:	22cb      	movs	r2, #203	; 0xcb
    2180:	4918      	ldr	r1, [pc, #96]	; (21e4 <_usart_async_init+0x6c>)
    2182:	3000      	adds	r0, #0
    2184:	bf18      	it	ne
    2186:	2001      	movne	r0, #1
    2188:	4b17      	ldr	r3, [pc, #92]	; (21e8 <_usart_async_init+0x70>)
    218a:	4798      	blx	r3
	init_status = _usart_init(hw);
    218c:	4628      	mov	r0, r5
    218e:	4b17      	ldr	r3, [pc, #92]	; (21ec <_usart_async_init+0x74>)
    2190:	4798      	blx	r3
	if (init_status) {
    2192:	4604      	mov	r4, r0
    2194:	b108      	cbz	r0, 219a <_usart_async_init+0x22>
}
    2196:	4620      	mov	r0, r4
    2198:	bd70      	pop	{r4, r5, r6, pc}
	device->hw = hw;
    219a:	61b5      	str	r5, [r6, #24]
	if (hw == SERCOM5) {
    219c:	4b14      	ldr	r3, [pc, #80]	; (21f0 <_usart_async_init+0x78>)
    219e:	429d      	cmp	r5, r3
		_sercom5_dev = (struct _usart_async_device *)dev;
    21a0:	bf04      	itt	eq
    21a2:	4b14      	ldreq	r3, [pc, #80]	; (21f4 <_usart_async_init+0x7c>)
    21a4:	601e      	streq	r6, [r3, #0]
	uint8_t irq = _sercom_get_irq_num(hw);
    21a6:	4628      	mov	r0, r5
    21a8:	4b13      	ldr	r3, [pc, #76]	; (21f8 <_usart_async_init+0x80>)
    21aa:	4798      	blx	r3
    21ac:	1d01      	adds	r1, r0, #4
    21ae:	b2c9      	uxtb	r1, r1
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    21b0:	2501      	movs	r5, #1
    21b2:	f000 021f 	and.w	r2, r0, #31
    21b6:	fa05 f202 	lsl.w	r2, r5, r2
    21ba:	0943      	lsrs	r3, r0, #5
    21bc:	009b      	lsls	r3, r3, #2
    21be:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    21c2:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    21c6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    21ca:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    21ce:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    21d2:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    21d6:	601a      	str	r2, [r3, #0]
		irq++;
    21d8:	3001      	adds	r0, #1
    21da:	b2c0      	uxtb	r0, r0
	for (uint32_t i = 0; i < 4; i++) {
    21dc:	4281      	cmp	r1, r0
    21de:	d1e8      	bne.n	21b2 <_usart_async_init+0x3a>
    21e0:	e7d9      	b.n	2196 <_usart_async_init+0x1e>
    21e2:	bf00      	nop
    21e4:	0000aa60 	.word	0x0000aa60
    21e8:	000016f5 	.word	0x000016f5
    21ec:	00002031 	.word	0x00002031
    21f0:	43000400 	.word	0x43000400
    21f4:	20001624 	.word	0x20001624
    21f8:	0000201d 	.word	0x0000201d

000021fc <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    21fc:	6802      	ldr	r2, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    21fe:	6813      	ldr	r3, [r2, #0]
    2200:	f043 0302 	orr.w	r3, r3, #2
    2204:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2206:	69d3      	ldr	r3, [r2, #28]
    2208:	f013 0f03 	tst.w	r3, #3
    220c:	d1fb      	bne.n	2206 <_usart_sync_enable+0xa>
}
    220e:	4770      	bx	lr

00002210 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    2210:	6982      	ldr	r2, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    2212:	6813      	ldr	r3, [r2, #0]
    2214:	f043 0302 	orr.w	r3, r3, #2
    2218:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    221a:	69d3      	ldr	r3, [r2, #28]
    221c:	f013 0f03 	tst.w	r3, #3
    2220:	d1fb      	bne.n	221a <_usart_async_enable+0xa>
}
    2222:	4770      	bx	lr

00002224 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    2224:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
    2226:	6299      	str	r1, [r3, #40]	; 0x28
    2228:	4770      	bx	lr

0000222a <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    222a:	6983      	ldr	r3, [r0, #24]
    222c:	6299      	str	r1, [r3, #40]	; 0x28
    222e:	4770      	bx	lr

00002230 <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
    2230:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
    2232:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
    2234:	b2c0      	uxtb	r0, r0
    2236:	4770      	bx	lr

00002238 <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    2238:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    223a:	7e18      	ldrb	r0, [r3, #24]
}
    223c:	f000 0001 	and.w	r0, r0, #1
    2240:	4770      	bx	lr

00002242 <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    2242:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    2244:	7e18      	ldrb	r0, [r3, #24]
}
    2246:	f3c0 0040 	ubfx	r0, r0, #1, #1
    224a:	4770      	bx	lr

0000224c <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    224c:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    224e:	7e18      	ldrb	r0, [r3, #24]
}
    2250:	f3c0 0080 	ubfx	r0, r0, #2, #1
    2254:	4770      	bx	lr

00002256 <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
    2256:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
    2258:	2201      	movs	r2, #1
    225a:	759a      	strb	r2, [r3, #22]
    225c:	4770      	bx	lr

0000225e <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
    225e:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
    2260:	2202      	movs	r2, #2
    2262:	759a      	strb	r2, [r3, #22]
    2264:	4770      	bx	lr
	...

00002268 <_usart_async_set_irq_state>:
{
    2268:	b570      	push	{r4, r5, r6, lr}
    226a:	460c      	mov	r4, r1
    226c:	4616      	mov	r6, r2
	ASSERT(device);
    226e:	4605      	mov	r5, r0
    2270:	f240 222b 	movw	r2, #555	; 0x22b
    2274:	4915      	ldr	r1, [pc, #84]	; (22cc <_usart_async_set_irq_state+0x64>)
    2276:	3000      	adds	r0, #0
    2278:	bf18      	it	ne
    227a:	2001      	movne	r0, #1
    227c:	4b14      	ldr	r3, [pc, #80]	; (22d0 <_usart_async_set_irq_state+0x68>)
    227e:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
    2280:	f014 0ffd 	tst.w	r4, #253	; 0xfd
    2284:	d10d      	bne.n	22a2 <_usart_async_set_irq_state+0x3a>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
    2286:	69ab      	ldr	r3, [r5, #24]
	if (value == 0x0) {
    2288:	b92e      	cbnz	r6, 2296 <_usart_async_set_irq_state+0x2e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
    228a:	2201      	movs	r2, #1
    228c:	751a      	strb	r2, [r3, #20]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
    228e:	69ab      	ldr	r3, [r5, #24]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
    2290:	2202      	movs	r2, #2
    2292:	751a      	strb	r2, [r3, #20]
    2294:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
    2296:	2201      	movs	r2, #1
    2298:	759a      	strb	r2, [r3, #22]
    229a:	69ab      	ldr	r3, [r5, #24]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
    229c:	2202      	movs	r2, #2
    229e:	759a      	strb	r2, [r3, #22]
    22a0:	bd70      	pop	{r4, r5, r6, pc}
	} else if (USART_ASYNC_RX_DONE == type) {
    22a2:	2c01      	cmp	r4, #1
    22a4:	d002      	beq.n	22ac <_usart_async_set_irq_state+0x44>
	} else if (USART_ASYNC_ERROR == type) {
    22a6:	2c03      	cmp	r4, #3
    22a8:	d008      	beq.n	22bc <_usart_async_set_irq_state+0x54>
    22aa:	bd70      	pop	{r4, r5, r6, pc}
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
    22ac:	69ab      	ldr	r3, [r5, #24]
	if (value == 0x0) {
    22ae:	b916      	cbnz	r6, 22b6 <_usart_async_set_irq_state+0x4e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_RXC;
    22b0:	2204      	movs	r2, #4
    22b2:	751a      	strb	r2, [r3, #20]
    22b4:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
    22b6:	2204      	movs	r2, #4
    22b8:	759a      	strb	r2, [r3, #22]
    22ba:	bd70      	pop	{r4, r5, r6, pc}
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
    22bc:	69ab      	ldr	r3, [r5, #24]
	if (value == 0x0) {
    22be:	b116      	cbz	r6, 22c6 <_usart_async_set_irq_state+0x5e>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
    22c0:	2280      	movs	r2, #128	; 0x80
    22c2:	759a      	strb	r2, [r3, #22]
}
    22c4:	e7f1      	b.n	22aa <_usart_async_set_irq_state+0x42>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
    22c6:	2280      	movs	r2, #128	; 0x80
    22c8:	751a      	strb	r2, [r3, #20]
    22ca:	bd70      	pop	{r4, r5, r6, pc}
    22cc:	0000aa60 	.word	0x0000aa60
    22d0:	000016f5 	.word	0x000016f5

000022d4 <SERCOM5_0_Handler>:

/**
 * \internal Sercom interrupt handler
 */
void SERCOM5_0_Handler(void)
{
    22d4:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom5_dev);
    22d6:	4b02      	ldr	r3, [pc, #8]	; (22e0 <SERCOM5_0_Handler+0xc>)
    22d8:	6818      	ldr	r0, [r3, #0]
    22da:	4b02      	ldr	r3, [pc, #8]	; (22e4 <SERCOM5_0_Handler+0x10>)
    22dc:	4798      	blx	r3
    22de:	bd08      	pop	{r3, pc}
    22e0:	20001624 	.word	0x20001624
    22e4:	00001fad 	.word	0x00001fad

000022e8 <SERCOM5_1_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM5_1_Handler(void)
{
    22e8:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom5_dev);
    22ea:	4b02      	ldr	r3, [pc, #8]	; (22f4 <SERCOM5_1_Handler+0xc>)
    22ec:	6818      	ldr	r0, [r3, #0]
    22ee:	4b02      	ldr	r3, [pc, #8]	; (22f8 <SERCOM5_1_Handler+0x10>)
    22f0:	4798      	blx	r3
    22f2:	bd08      	pop	{r3, pc}
    22f4:	20001624 	.word	0x20001624
    22f8:	00001fad 	.word	0x00001fad

000022fc <SERCOM5_2_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM5_2_Handler(void)
{
    22fc:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom5_dev);
    22fe:	4b02      	ldr	r3, [pc, #8]	; (2308 <SERCOM5_2_Handler+0xc>)
    2300:	6818      	ldr	r0, [r3, #0]
    2302:	4b02      	ldr	r3, [pc, #8]	; (230c <SERCOM5_2_Handler+0x10>)
    2304:	4798      	blx	r3
    2306:	bd08      	pop	{r3, pc}
    2308:	20001624 	.word	0x20001624
    230c:	00001fad 	.word	0x00001fad

00002310 <SERCOM5_3_Handler>:
}
/**
 * \internal Sercom interrupt handler
 */
void SERCOM5_3_Handler(void)
{
    2310:	b508      	push	{r3, lr}
	_sercom_usart_interrupt_handler(_sercom5_dev);
    2312:	4b02      	ldr	r3, [pc, #8]	; (231c <SERCOM5_3_Handler+0xc>)
    2314:	6818      	ldr	r0, [r3, #0]
    2316:	4b02      	ldr	r3, [pc, #8]	; (2320 <SERCOM5_3_Handler+0x10>)
    2318:	4798      	blx	r3
    231a:	bd08      	pop	{r3, pc}
    231c:	20001624 	.word	0x20001624
    2320:	00001fad 	.word	0x00001fad

00002324 <get_tc_index>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The index of TC configuration
 */
static int8_t get_tc_index(const void *const hw)
{
    2324:	b570      	push	{r4, r5, r6, lr}
    2326:	b088      	sub	sp, #32
    2328:	4606      	mov	r6, r0
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
    232a:	466c      	mov	r4, sp
    232c:	4d12      	ldr	r5, [pc, #72]	; (2378 <get_tc_index+0x54>)
    232e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    2330:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    2332:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    2336:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
    233a:	9b00      	ldr	r3, [sp, #0]
    233c:	42b3      	cmp	r3, r6
    233e:	d00b      	beq.n	2358 <get_tc_index+0x34>
    2340:	4630      	mov	r0, r6
    2342:	aa01      	add	r2, sp, #4
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    2344:	2301      	movs	r3, #1
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
    2346:	f852 1b04 	ldr.w	r1, [r2], #4
    234a:	4281      	cmp	r1, r0
    234c:	d005      	beq.n	235a <get_tc_index+0x36>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    234e:	3301      	adds	r3, #1
    2350:	2b08      	cmp	r3, #8
    2352:	d1f8      	bne.n	2346 <get_tc_index+0x22>
			return i;
    2354:	2000      	movs	r0, #0
    2356:	e00b      	b.n	2370 <get_tc_index+0x4c>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    2358:	2300      	movs	r3, #0
		if (_tcs[i].number == index) {
    235a:	f013 0fff 	tst.w	r3, #255	; 0xff
    235e:	d009      	beq.n	2374 <get_tc_index+0x50>
	ASSERT(false);
    2360:	f44f 729e 	mov.w	r2, #316	; 0x13c
    2364:	4905      	ldr	r1, [pc, #20]	; (237c <get_tc_index+0x58>)
    2366:	2000      	movs	r0, #0
    2368:	4b05      	ldr	r3, [pc, #20]	; (2380 <get_tc_index+0x5c>)
    236a:	4798      	blx	r3
	return -1;
    236c:	f04f 30ff 	mov.w	r0, #4294967295
}
    2370:	b008      	add	sp, #32
    2372:	bd70      	pop	{r4, r5, r6, pc}
			return i;
    2374:	2000      	movs	r0, #0
    2376:	e7fb      	b.n	2370 <get_tc_index+0x4c>
    2378:	0000aa7c 	.word	0x0000aa7c
    237c:	0000aab0 	.word	0x0000aab0
    2380:	000016f5 	.word	0x000016f5

00002384 <_timer_init>:
{
    2384:	b570      	push	{r4, r5, r6, lr}
    2386:	4606      	mov	r6, r0
    2388:	460c      	mov	r4, r1
	int8_t i = get_tc_index(hw);
    238a:	4608      	mov	r0, r1
    238c:	4b60      	ldr	r3, [pc, #384]	; (2510 <_timer_init+0x18c>)
    238e:	4798      	blx	r3
    2390:	4605      	mov	r5, r0
	device->hw = hw;
    2392:	60f4      	str	r4, [r6, #12]
	ASSERT(ARRAY_SIZE(_tcs));
    2394:	228d      	movs	r2, #141	; 0x8d
    2396:	495f      	ldr	r1, [pc, #380]	; (2514 <_timer_init+0x190>)
    2398:	2001      	movs	r0, #1
    239a:	4b5f      	ldr	r3, [pc, #380]	; (2518 <_timer_init+0x194>)
    239c:	4798      	blx	r3
	};
}

static inline bool hri_tc_is_syncing(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
    239e:	6923      	ldr	r3, [r4, #16]
	if (!hri_tc_is_syncing(hw, TC_SYNCBUSY_SWRST)) {
    23a0:	f013 0f01 	tst.w	r3, #1
    23a4:	d119      	bne.n	23da <_timer_init+0x56>
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    23a6:	6923      	ldr	r3, [r4, #16]
    23a8:	f013 0f03 	tst.w	r3, #3
    23ac:	d1fb      	bne.n	23a6 <_timer_init+0x22>

static inline hri_tc_ctrla_reg_t hri_tc_get_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    23ae:	6823      	ldr	r3, [r4, #0]
		if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
    23b0:	f013 0f02 	tst.w	r3, #2
    23b4:	d00b      	beq.n	23ce <_timer_init+0x4a>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
    23b6:	6823      	ldr	r3, [r4, #0]
    23b8:	f023 0302 	bic.w	r3, r3, #2
    23bc:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    23be:	6923      	ldr	r3, [r4, #16]
    23c0:	f013 0f03 	tst.w	r3, #3
    23c4:	d1fb      	bne.n	23be <_timer_init+0x3a>
    23c6:	6923      	ldr	r3, [r4, #16]
    23c8:	f013 0f02 	tst.w	r3, #2
    23cc:	d1fb      	bne.n	23c6 <_timer_init+0x42>
}

static inline void hri_tc_write_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    23ce:	2301      	movs	r3, #1
    23d0:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    23d2:	6923      	ldr	r3, [r4, #16]
    23d4:	f013 0f03 	tst.w	r3, #3
    23d8:	d1fb      	bne.n	23d2 <_timer_init+0x4e>
    23da:	6923      	ldr	r3, [r4, #16]
    23dc:	f013 0f01 	tst.w	r3, #1
    23e0:	d1fb      	bne.n	23da <_timer_init+0x56>
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
    23e2:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    23e6:	4a4d      	ldr	r2, [pc, #308]	; (251c <_timer_init+0x198>)
    23e8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    23ec:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    23ee:	6022      	str	r2, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    23f0:	6923      	ldr	r3, [r4, #16]
    23f2:	f013 0f03 	tst.w	r3, #3
    23f6:	d1fb      	bne.n	23f0 <_timer_init+0x6c>
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
    23f8:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    23fc:	4947      	ldr	r1, [pc, #284]	; (251c <_timer_init+0x198>)
    23fe:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    2402:	f893 102a 	ldrb.w	r1, [r3, #42]	; 0x2a
}

static inline void hri_tc_write_DBGCTRL_reg(const void *const hw, hri_tc_dbgctrl_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
    2406:	73e1      	strb	r1, [r4, #15]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
    2408:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
    240a:	80e3      	strh	r3, [r4, #6]
	((Tc *)hw)->COUNT16.WAVE.reg = data;
    240c:	2301      	movs	r3, #1
    240e:	7323      	strb	r3, [r4, #12]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
    2410:	f002 020c 	and.w	r2, r2, #12
    2414:	2a08      	cmp	r2, #8
    2416:	d048      	beq.n	24aa <_timer_init+0x126>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
    2418:	2a00      	cmp	r2, #0
    241a:	d158      	bne.n	24ce <_timer_init+0x14a>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
    241c:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2420:	4a3e      	ldr	r2, [pc, #248]	; (251c <_timer_init+0x198>)
    2422:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2426:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
}

static inline void hri_tccount16_write_CC_reg(const void *const hw, uint8_t index, hri_tccount16_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    2428:	83a3      	strh	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    242a:	6923      	ldr	r3, [r4, #16]
    242c:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    2430:	d1fb      	bne.n	242a <_timer_init+0xa6>
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    2432:	2300      	movs	r3, #0
    2434:	83e3      	strh	r3, [r4, #30]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2436:	6923      	ldr	r3, [r4, #16]
    2438:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    243c:	d1fb      	bne.n	2436 <_timer_init+0xb2>
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_OVF;
    243e:	2301      	movs	r3, #1
    2440:	7263      	strb	r3, [r4, #9]
	if (hw == TC0) {
    2442:	4b37      	ldr	r3, [pc, #220]	; (2520 <_timer_init+0x19c>)
    2444:	429c      	cmp	r4, r3
		_tc0_dev = (struct _timer_device *)dev;
    2446:	bf04      	itt	eq
    2448:	4b36      	ldreq	r3, [pc, #216]	; (2524 <_timer_init+0x1a0>)
    244a:	601e      	streq	r6, [r3, #0]
	NVIC_DisableIRQ(_tcs[i].irq);
    244c:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    2450:	4a32      	ldr	r2, [pc, #200]	; (251c <_timer_init+0x198>)
    2452:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2456:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
    245a:	2b00      	cmp	r3, #0
    245c:	db23      	blt.n	24a6 <_timer_init+0x122>
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    245e:	095a      	lsrs	r2, r3, #5
    2460:	f003 031f 	and.w	r3, r3, #31
    2464:	2101      	movs	r1, #1
    2466:	fa01 f303 	lsl.w	r3, r1, r3
    246a:	3220      	adds	r2, #32
    246c:	492e      	ldr	r1, [pc, #184]	; (2528 <_timer_init+0x1a4>)
    246e:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    2472:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2476:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(_tcs[i].irq);
    247a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    247e:	4b27      	ldr	r3, [pc, #156]	; (251c <_timer_init+0x198>)
    2480:	eb03 0585 	add.w	r5, r3, r5, lsl #2
    2484:	f9b5 3022 	ldrsh.w	r3, [r5, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
    2488:	2b00      	cmp	r3, #0
    248a:	db0c      	blt.n	24a6 <_timer_init+0x122>
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    248c:	0959      	lsrs	r1, r3, #5
    248e:	f003 031f 	and.w	r3, r3, #31
    2492:	2201      	movs	r2, #1
    2494:	fa02 f303 	lsl.w	r3, r2, r3
    2498:	4a23      	ldr	r2, [pc, #140]	; (2528 <_timer_init+0x1a4>)
    249a:	f101 0060 	add.w	r0, r1, #96	; 0x60
    249e:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    24a2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
    24a6:	2000      	movs	r0, #0
    24a8:	bd70      	pop	{r4, r5, r6, pc}
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
    24aa:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    24ae:	4a1b      	ldr	r2, [pc, #108]	; (251c <_timer_init+0x198>)
    24b0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    24b4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}

static inline void hri_tccount32_write_CC_reg(const void *const hw, uint8_t index, hri_tccount32_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    24b6:	61e3      	str	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    24b8:	6923      	ldr	r3, [r4, #16]
    24ba:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    24be:	d1fb      	bne.n	24b8 <_timer_init+0x134>
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    24c0:	2300      	movs	r3, #0
    24c2:	6223      	str	r3, [r4, #32]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    24c4:	6923      	ldr	r3, [r4, #16]
    24c6:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    24ca:	d1fb      	bne.n	24c4 <_timer_init+0x140>
    24cc:	e7b7      	b.n	243e <_timer_init+0xba>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT8) {
    24ce:	2a04      	cmp	r2, #4
    24d0:	d1b5      	bne.n	243e <_timer_init+0xba>
		hri_tccount8_write_CC_reg(hw, 0, (uint8_t)_tcs[i].cc0);
    24d2:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    24d6:	4a11      	ldr	r2, [pc, #68]	; (251c <_timer_init+0x198>)
    24d8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    24dc:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
	((Tc *)hw)->COUNT8.CC[index].reg = data;
    24e0:	7723      	strb	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    24e2:	6923      	ldr	r3, [r4, #16]
    24e4:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    24e8:	d1fb      	bne.n	24e2 <_timer_init+0x15e>
	((Tc *)hw)->COUNT8.CC[index].reg = data;
    24ea:	2300      	movs	r3, #0
    24ec:	7763      	strb	r3, [r4, #29]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    24ee:	6923      	ldr	r3, [r4, #16]
    24f0:	f013 0fc0 	tst.w	r3, #192	; 0xc0
    24f4:	d1fb      	bne.n	24ee <_timer_init+0x16a>
		hri_tccount8_write_PER_reg(hw, _tcs[i].per);
    24f6:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    24fa:	4a08      	ldr	r2, [pc, #32]	; (251c <_timer_init+0x198>)
    24fc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2500:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
	((Tc *)hw)->COUNT8.PER.reg = data;
    2504:	76e3      	strb	r3, [r4, #27]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2506:	6923      	ldr	r3, [r4, #16]
    2508:	f013 0f20 	tst.w	r3, #32
    250c:	d1fb      	bne.n	2506 <_timer_init+0x182>
    250e:	e796      	b.n	243e <_timer_init+0xba>
    2510:	00002325 	.word	0x00002325
    2514:	0000aab0 	.word	0x0000aab0
    2518:	000016f5 	.word	0x000016f5
    251c:	0000aa7c 	.word	0x0000aa7c
    2520:	40003800 	.word	0x40003800
    2524:	20001628 	.word	0x20001628
    2528:	e000e100 	.word	0xe000e100

0000252c <_timer_start>:
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
    252c:	68c2      	ldr	r2, [r0, #12]
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
    252e:	6813      	ldr	r3, [r2, #0]
    2530:	f043 0302 	orr.w	r3, r3, #2
    2534:	6013      	str	r3, [r2, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    2536:	6913      	ldr	r3, [r2, #16]
    2538:	f013 0f03 	tst.w	r3, #3
    253c:	d1fb      	bne.n	2536 <_timer_start+0xa>
}
    253e:	4770      	bx	lr

00002540 <_timer_is_started>:
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
    2540:	68c2      	ldr	r2, [r0, #12]
    2542:	6913      	ldr	r3, [r2, #16]
    2544:	f013 0f03 	tst.w	r3, #3
    2548:	d1fb      	bne.n	2542 <_timer_is_started+0x2>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    254a:	6810      	ldr	r0, [r2, #0]
}
    254c:	f3c0 0040 	ubfx	r0, r0, #1, #1
    2550:	4770      	bx	lr

00002552 <_tc_get_timer>:
}
    2552:	2000      	movs	r0, #0
    2554:	4770      	bx	lr
	...

00002558 <_timer_set_irq>:
{
    2558:	b510      	push	{r4, lr}
	int8_t      i  = get_tc_index(hw);
    255a:	68c0      	ldr	r0, [r0, #12]
    255c:	4b09      	ldr	r3, [pc, #36]	; (2584 <_timer_set_irq+0x2c>)
    255e:	4798      	blx	r3
    2560:	4604      	mov	r4, r0
	ASSERT(ARRAY_SIZE(_tcs));
    2562:	f240 120f 	movw	r2, #271	; 0x10f
    2566:	4908      	ldr	r1, [pc, #32]	; (2588 <_timer_set_irq+0x30>)
    2568:	2001      	movs	r0, #1
    256a:	4b08      	ldr	r3, [pc, #32]	; (258c <_timer_set_irq+0x34>)
    256c:	4798      	blx	r3
	_irq_set(_tcs[i].irq);
    256e:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    2572:	4b07      	ldr	r3, [pc, #28]	; (2590 <_timer_set_irq+0x38>)
    2574:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    2578:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
    257c:	4b05      	ldr	r3, [pc, #20]	; (2594 <_timer_set_irq+0x3c>)
    257e:	4798      	blx	r3
    2580:	bd10      	pop	{r4, pc}
    2582:	bf00      	nop
    2584:	00002325 	.word	0x00002325
    2588:	0000aab0 	.word	0x0000aab0
    258c:	000016f5 	.word	0x000016f5
    2590:	0000aa7c 	.word	0x0000aa7c
    2594:	00001891 	.word	0x00001891

00002598 <TC0_Handler>:
{
    2598:	b508      	push	{r3, lr}
	tc_interrupt_handler(_tc0_dev);
    259a:	4b06      	ldr	r3, [pc, #24]	; (25b4 <TC0_Handler+0x1c>)
    259c:	6818      	ldr	r0, [r3, #0]
	void *const hw = device->hw;
    259e:	68c3      	ldr	r3, [r0, #12]
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
    25a0:	7a9a      	ldrb	r2, [r3, #10]
	if (hri_tc_get_interrupt_OVF_bit(hw)) {
    25a2:	f012 0f01 	tst.w	r2, #1
    25a6:	d100      	bne.n	25aa <TC0_Handler+0x12>
    25a8:	bd08      	pop	{r3, pc}
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
    25aa:	2201      	movs	r2, #1
    25ac:	729a      	strb	r2, [r3, #10]
		device->timer_cb.period_expired(device);
    25ae:	6803      	ldr	r3, [r0, #0]
    25b0:	4798      	blx	r3
}
    25b2:	e7f9      	b.n	25a8 <TC0_Handler+0x10>
    25b4:	20001628 	.word	0x20001628

000025b8 <mac_low_level_init>:

/**
 * \brief Initialize the MAC hardware
 */
void mac_low_level_init(struct netif *netif)
{
    25b8:	b510      	push	{r4, lr}
    25ba:	b084      	sub	sp, #16
	struct mac_async_descriptor *mac;
	struct mac_async_filter      filter;

	mac = (struct mac_async_descriptor *)(netif->state);
    25bc:	6a44      	ldr	r4, [r0, #36]	; 0x24

	/* set MAC hardware address */
	memcpy(filter.mac, netif->hwaddr, NETIF_MAX_HWADDR_LEN);
    25be:	4603      	mov	r3, r0
    25c0:	f853 0f2f 	ldr.w	r0, [r3, #47]!
    25c4:	9001      	str	r0, [sp, #4]
    25c6:	889b      	ldrh	r3, [r3, #4]
    25c8:	f8ad 3008 	strh.w	r3, [sp, #8]
	filter.tid_enable = false; //true; //tph false;
    25cc:	2100      	movs	r1, #0
    25ce:	f88d 100c 	strb.w	r1, [sp, #12]
	mac_async_set_filter(mac, 0, &filter);
    25d2:	aa01      	add	r2, sp, #4
    25d4:	4620      	mov	r0, r4
    25d6:	4b02      	ldr	r3, [pc, #8]	; (25e0 <mac_low_level_init+0x28>)
    25d8:	4798      	blx	r3
}
    25da:	b004      	add	sp, #16
    25dc:	bd10      	pop	{r4, pc}
    25de:	bf00      	nop
    25e0:	00000fe5 	.word	0x00000fe5

000025e4 <mac_low_level_output>:

/**
 * \berif Transmission packet though the MAC hardware.
 */
err_t mac_low_level_output(struct netif *netif, struct pbuf *p)
{
    25e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    25e8:	460f      	mov	r7, r1
	struct mac_async_descriptor *mac;
	struct pbuf *                q;
	void *                       tbuf;
	uint8_t *                    pos;

	mac = (struct mac_async_descriptor *)(netif->state);
    25ea:	f8d0 8024 	ldr.w	r8, [r0, #36]	; 0x24

#if ETH_PAD_SIZE
	pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
#endif

	if (p->tot_len == p->len) {
    25ee:	890a      	ldrh	r2, [r1, #8]
    25f0:	894b      	ldrh	r3, [r1, #10]
    25f2:	4293      	cmp	r3, r2
    25f4:	d01f      	beq.n	2636 <mac_low_level_output+0x52>
		mac_async_write(mac, p->payload, p->tot_len);
	} else {
		tbuf = mem_malloc(LWIP_MEM_ALIGN_SIZE(p->tot_len));
    25f6:	3203      	adds	r2, #3
    25f8:	f64f 70fc 	movw	r0, #65532	; 0xfffc
    25fc:	4010      	ands	r0, r2
    25fe:	4b13      	ldr	r3, [pc, #76]	; (264c <mac_low_level_output+0x68>)
    2600:	4798      	blx	r3
		pos  = tbuf;
		if (tbuf == NULL) {
    2602:	4681      	mov	r9, r0
    2604:	b1f0      	cbz	r0, 2644 <mac_low_level_output+0x60>
			return ERR_MEM;
		}
		for (q = p; q != NULL; q = q->next) {
    2606:	b15f      	cbz	r7, 2620 <mac_low_level_output+0x3c>
    2608:	4605      	mov	r5, r0
    260a:	463c      	mov	r4, r7
			memcpy(pos, q->payload, q->len);
    260c:	4e10      	ldr	r6, [pc, #64]	; (2650 <mac_low_level_output+0x6c>)
    260e:	8962      	ldrh	r2, [r4, #10]
    2610:	6861      	ldr	r1, [r4, #4]
    2612:	4628      	mov	r0, r5
    2614:	47b0      	blx	r6
			pos += q->len;
    2616:	8963      	ldrh	r3, [r4, #10]
    2618:	441d      	add	r5, r3
		for (q = p; q != NULL; q = q->next) {
    261a:	6824      	ldr	r4, [r4, #0]
    261c:	2c00      	cmp	r4, #0
    261e:	d1f6      	bne.n	260e <mac_low_level_output+0x2a>
		}
		mac_async_write(mac, tbuf, p->tot_len);
    2620:	893a      	ldrh	r2, [r7, #8]
    2622:	4649      	mov	r1, r9
    2624:	4640      	mov	r0, r8
    2626:	4b0b      	ldr	r3, [pc, #44]	; (2654 <mac_low_level_output+0x70>)
    2628:	4798      	blx	r3
		mem_free(tbuf);
    262a:	4648      	mov	r0, r9
    262c:	4b0a      	ldr	r3, [pc, #40]	; (2658 <mac_low_level_output+0x74>)
    262e:	4798      	blx	r3
	pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
#endif

	LINK_STATS_INC(link.xmit);

	return ERR_OK;
    2630:	2000      	movs	r0, #0
    2632:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		mac_async_write(mac, p->payload, p->tot_len);
    2636:	6849      	ldr	r1, [r1, #4]
    2638:	4640      	mov	r0, r8
    263a:	4b06      	ldr	r3, [pc, #24]	; (2654 <mac_low_level_output+0x70>)
    263c:	4798      	blx	r3
	return ERR_OK;
    263e:	2000      	movs	r0, #0
    2640:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			return ERR_MEM;
    2644:	f04f 30ff 	mov.w	r0, #4294967295
}
    2648:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    264c:	0000506d 	.word	0x0000506d
    2650:	000097ef 	.word	0x000097ef
    2654:	00000ef1 	.word	0x00000ef1
    2658:	00004f19 	.word	0x00004f19

0000265c <ethernetif_mac_input>:

/**
 * \brief Process incoming ethernet packet.
 */
void ethernetif_mac_input(struct netif *netif)
{
    265c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    2660:	4606      	mov	r6, r0
	len = mac_async_read_len(mac); /* Obtain the size of the packet */
    2662:	4f1b      	ldr	r7, [pc, #108]	; (26d0 <ethernetif_mac_input+0x74>)
	p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
    2664:	f8df 9078 	ldr.w	r9, [pc, #120]	; 26e0 <ethernetif_mac_input+0x84>
		mac_async_read(mac, p->payload, p->len);
    2668:	f8df 8068 	ldr.w	r8, [pc, #104]	; 26d4 <ethernetif_mac_input+0x78>
    266c:	e00b      	b.n	2686 <ethernetif_mac_input+0x2a>
		mac_async_read(mac, NULL, 0);
    266e:	2200      	movs	r2, #0
    2670:	4611      	mov	r1, r2
    2672:	4628      	mov	r0, r5
    2674:	4b17      	ldr	r3, [pc, #92]	; (26d4 <ethernetif_mac_input+0x78>)
    2676:	4798      	blx	r3
    2678:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			/* PPPoE packet? */
		case ETHTYPE_PPPOEDISC:
		case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
			/* full packet send to tcpip_thread to process */
			if (netif->input(p, netif) != ERR_OK) {
    267c:	6933      	ldr	r3, [r6, #16]
    267e:	4631      	mov	r1, r6
    2680:	4620      	mov	r0, r4
    2682:	4798      	blx	r3
    2684:	b9e8      	cbnz	r0, 26c2 <ethernetif_mac_input+0x66>
	mac = (struct mac_async_descriptor *)(netif->state);
    2686:	6a75      	ldr	r5, [r6, #36]	; 0x24
	len = mac_async_read_len(mac); /* Obtain the size of the packet */
    2688:	4628      	mov	r0, r5
    268a:	47b8      	blx	r7
    268c:	b281      	uxth	r1, r0
	if (len == 0) {
    268e:	b1e1      	cbz	r1, 26ca <ethernetif_mac_input+0x6e>
	p = pbuf_alloc(PBUF_RAW, len, PBUF_RAM);
    2690:	2200      	movs	r2, #0
    2692:	2003      	movs	r0, #3
    2694:	47c8      	blx	r9
	if (p != NULL) {
    2696:	4604      	mov	r4, r0
    2698:	2800      	cmp	r0, #0
    269a:	d0e8      	beq.n	266e <ethernetif_mac_input+0x12>
		mac_async_read(mac, p->payload, p->len);
    269c:	8942      	ldrh	r2, [r0, #10]
    269e:	6841      	ldr	r1, [r0, #4]
    26a0:	4628      	mov	r0, r5
    26a2:	47c0      	blx	r8
		switch (htons(ethhdr->type)) {
    26a4:	6863      	ldr	r3, [r4, #4]
    26a6:	8998      	ldrh	r0, [r3, #12]
    26a8:	4b0b      	ldr	r3, [pc, #44]	; (26d8 <ethernetif_mac_input+0x7c>)
    26aa:	4798      	blx	r3
    26ac:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
    26b0:	d0e4      	beq.n	267c <ethernetif_mac_input+0x20>
    26b2:	f640 0306 	movw	r3, #2054	; 0x806
    26b6:	4298      	cmp	r0, r3
    26b8:	d0e0      	beq.n	267c <ethernetif_mac_input+0x20>
				p = NULL;
			}
			break;

		default:
			pbuf_free(p);
    26ba:	4620      	mov	r0, r4
    26bc:	4b07      	ldr	r3, [pc, #28]	; (26dc <ethernetif_mac_input+0x80>)
    26be:	4798      	blx	r3
			p = NULL;
			break;
    26c0:	e7e1      	b.n	2686 <ethernetif_mac_input+0x2a>
				pbuf_free(p);
    26c2:	4620      	mov	r0, r4
    26c4:	4b05      	ldr	r3, [pc, #20]	; (26dc <ethernetif_mac_input+0x80>)
    26c6:	4798      	blx	r3
    26c8:	e7dd      	b.n	2686 <ethernetif_mac_input+0x2a>
    26ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    26ce:	bf00      	nop
    26d0:	00000f5d 	.word	0x00000f5d
    26d4:	00000f2d 	.word	0x00000f2d
    26d8:	000026e5 	.word	0x000026e5
    26dc:	000054c9 	.word	0x000054c9
    26e0:	00005531 	.word	0x00005531

000026e4 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t lwip_htons(u16_t n)
{
	return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
    26e4:	0a03      	lsrs	r3, r0, #8
    26e6:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
}
    26ea:	b280      	uxth	r0, r0
    26ec:	4770      	bx	lr

000026ee <lwip_ntohs>:
	return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
    26ee:	0a03      	lsrs	r3, r0, #8
    26f0:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 * @return n in host byte order
 */
u16_t lwip_ntohs(u16_t n)
{
	return lwip_htons(n);
}
    26f4:	b280      	uxth	r0, r0
    26f6:	4770      	bx	lr

000026f8 <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t lwip_htonl(u32_t n)
{
	return ((n & 0xff) << 24) | ((n & 0xff00) << 8) | ((n & 0xff0000UL) >> 8) | ((n & 0xff000000UL) >> 24);
    26f8:	0e03      	lsrs	r3, r0, #24
    26fa:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
    26fe:	0202      	lsls	r2, r0, #8
    2700:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
    2704:	4313      	orrs	r3, r2
    2706:	0a00      	lsrs	r0, r0, #8
    2708:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
}
    270c:	4318      	orrs	r0, r3
    270e:	4770      	bx	lr

00002710 <lwip_ntohl>:
 *
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t lwip_ntohl(u32_t n)
{
    2710:	b508      	push	{r3, lr}
	return lwip_htonl(n);
    2712:	4b01      	ldr	r3, [pc, #4]	; (2718 <lwip_ntohl+0x8>)
    2714:	4798      	blx	r3
}
    2716:	bd08      	pop	{r3, pc}
    2718:	000026f9 	.word	0x000026f9

0000271c <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
	if (new_state != dhcp->state) {
    271c:	7b03      	ldrb	r3, [r0, #12]
    271e:	428b      	cmp	r3, r1
    2720:	d003      	beq.n	272a <dhcp_set_state+0xe>
		dhcp->state           = new_state;
    2722:	7301      	strb	r1, [r0, #12]
		dhcp->tries           = 0;
    2724:	2300      	movs	r3, #0
    2726:	7343      	strb	r3, [r0, #13]
		dhcp->request_timeout = 0;
    2728:	8343      	strh	r3, [r0, #26]
    272a:	4770      	bx	lr

0000272c <dhcp_option>:
 * Concatenate an option type and length field to the outgoing
 * DHCP message.
 *
 */
static void dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
    272c:	b430      	push	{r4, r5}
	LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    272e:	6943      	ldr	r3, [r0, #20]
    2730:	8b04      	ldrh	r4, [r0, #24]
    2732:	1c65      	adds	r5, r4, #1
    2734:	8305      	strh	r5, [r0, #24]
    2736:	4423      	add	r3, r4
    2738:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    273c:	6943      	ldr	r3, [r0, #20]
    273e:	8b01      	ldrh	r1, [r0, #24]
    2740:	1c4c      	adds	r4, r1, #1
    2742:	8304      	strh	r4, [r0, #24]
    2744:	440b      	add	r3, r1
    2746:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
}
    274a:	bc30      	pop	{r4, r5}
    274c:	4770      	bx	lr

0000274e <dhcp_option_byte>:
/*
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
    274e:	b410      	push	{r4}
	LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = value;
    2750:	6943      	ldr	r3, [r0, #20]
    2752:	8b02      	ldrh	r2, [r0, #24]
    2754:	1c54      	adds	r4, r2, #1
    2756:	8304      	strh	r4, [r0, #24]
    2758:	4413      	add	r3, r2
    275a:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    275e:	f85d 4b04 	ldr.w	r4, [sp], #4
    2762:	4770      	bx	lr

00002764 <dhcp_option_short>:

static void dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
    2764:	b410      	push	{r4}
	LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    2766:	6943      	ldr	r3, [r0, #20]
    2768:	8b02      	ldrh	r2, [r0, #24]
    276a:	1c54      	adds	r4, r2, #1
    276c:	8304      	strh	r4, [r0, #24]
    276e:	4413      	add	r3, r2
    2770:	0a0a      	lsrs	r2, r1, #8
    2772:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)(value & 0x00ffU);
    2776:	6943      	ldr	r3, [r0, #20]
    2778:	8b02      	ldrh	r2, [r0, #24]
    277a:	1c54      	adds	r4, r2, #1
    277c:	8304      	strh	r4, [r0, #24]
    277e:	4413      	add	r3, r2
    2780:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    2784:	f85d 4b04 	ldr.w	r4, [sp], #4
    2788:	4770      	bx	lr

0000278a <dhcp_option_long>:

static void dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
    278a:	b410      	push	{r4}
	LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN",
	            dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
    278c:	6943      	ldr	r3, [r0, #20]
    278e:	8b02      	ldrh	r2, [r0, #24]
    2790:	1c54      	adds	r4, r2, #1
    2792:	8304      	strh	r4, [r0, #24]
    2794:	4413      	add	r3, r2
    2796:	0e0a      	lsrs	r2, r1, #24
    2798:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
    279c:	6943      	ldr	r3, [r0, #20]
    279e:	8b02      	ldrh	r2, [r0, #24]
    27a0:	1c54      	adds	r4, r2, #1
    27a2:	8304      	strh	r4, [r0, #24]
    27a4:	4413      	add	r3, r2
    27a6:	0c0a      	lsrs	r2, r1, #16
    27a8:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    27ac:	6943      	ldr	r3, [r0, #20]
    27ae:	8b02      	ldrh	r2, [r0, #24]
    27b0:	1c54      	adds	r4, r2, #1
    27b2:	8304      	strh	r4, [r0, #24]
    27b4:	4413      	add	r3, r2
    27b6:	0a0a      	lsrs	r2, r1, #8
    27b8:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    27bc:	6943      	ldr	r3, [r0, #20]
    27be:	8b02      	ldrh	r2, [r0, #24]
    27c0:	1c54      	adds	r4, r2, #1
    27c2:	8304      	strh	r4, [r0, #24]
    27c4:	4413      	add	r3, r2
    27c6:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
}
    27ca:	f85d 4b04 	ldr.w	r4, [sp], #4
    27ce:	4770      	bx	lr

000027d0 <dhcp_option_trailer>:
 * necessary, up to three padding bytes.
 *
 * @param dhcp DHCP state structure
 */
static void dhcp_option_trailer(struct dhcp *dhcp)
{
    27d0:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    27d2:	b150      	cbz	r0, 27ea <dhcp_option_trailer+0x1a>
    27d4:	4601      	mov	r1, r0
	LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
	LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n",
	            dhcp->options_out_len < DHCP_OPTIONS_LEN);
	dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
    27d6:	6943      	ldr	r3, [r0, #20]
    27d8:	8b02      	ldrh	r2, [r0, #24]
    27da:	1c50      	adds	r0, r2, #1
    27dc:	8308      	strh	r0, [r1, #24]
    27de:	4413      	add	r3, r2
    27e0:	22ff      	movs	r2, #255	; 0xff
    27e2:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
	/* packet is too small, or not 4 byte aligned? */
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
	       && (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
		/* add a fill/padding byte */
		dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    27e6:	2400      	movs	r4, #0
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
    27e8:	e00d      	b.n	2806 <dhcp_option_trailer+0x36>
	LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    27ea:	4b09      	ldr	r3, [pc, #36]	; (2810 <dhcp_option_trailer+0x40>)
    27ec:	f240 62e7 	movw	r2, #1767	; 0x6e7
    27f0:	4908      	ldr	r1, [pc, #32]	; (2814 <dhcp_option_trailer+0x44>)
    27f2:	4809      	ldr	r0, [pc, #36]	; (2818 <dhcp_option_trailer+0x48>)
    27f4:	4c09      	ldr	r4, [pc, #36]	; (281c <dhcp_option_trailer+0x4c>)
    27f6:	47a0      	blx	r4
    27f8:	e7fe      	b.n	27f8 <dhcp_option_trailer+0x28>
		dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    27fa:	694a      	ldr	r2, [r1, #20]
    27fc:	1c58      	adds	r0, r3, #1
    27fe:	8308      	strh	r0, [r1, #24]
    2800:	4413      	add	r3, r2
    2802:	f883 40f0 	strb.w	r4, [r3, #240]	; 0xf0
	while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3))
    2806:	8b0b      	ldrh	r3, [r1, #24]
    2808:	2b43      	cmp	r3, #67	; 0x43
    280a:	d9f6      	bls.n	27fa <dhcp_option_trailer+0x2a>
	}
}
    280c:	bd10      	pop	{r4, pc}
    280e:	bf00      	nop
    2810:	0000aac4 	.word	0x0000aac4
    2814:	0000aae8 	.word	0x0000aae8
    2818:	0000ab0c 	.word	0x0000ab0c
    281c:	00009815 	.word	0x00009815

00002820 <dhcp_create_msg>:
{
    2820:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
    2824:	2800      	cmp	r0, #0
    2826:	f000 809f 	beq.w	2968 <dhcp_create_msg+0x148>
    282a:	460c      	mov	r4, r1
    282c:	4615      	mov	r5, r2
    282e:	4606      	mov	r6, r0
	LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    2830:	2900      	cmp	r1, #0
    2832:	f000 80a1 	beq.w	2978 <dhcp_create_msg+0x158>
	dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
    2836:	2200      	movs	r2, #0
    2838:	f44f 719a 	mov.w	r1, #308	; 0x134
    283c:	4610      	mov	r0, r2
    283e:	4b56      	ldr	r3, [pc, #344]	; (2998 <dhcp_create_msg+0x178>)
    2840:	4798      	blx	r3
    2842:	6120      	str	r0, [r4, #16]
	if (dhcp->p_out == NULL) {
    2844:	2800      	cmp	r0, #0
    2846:	f000 809f 	beq.w	2988 <dhcp_create_msg+0x168>
	if (dhcp->tries == 0) {
    284a:	7b63      	ldrb	r3, [r4, #13]
    284c:	b91b      	cbnz	r3, 2856 <dhcp_create_msg+0x36>
		xid++;
    284e:	4a53      	ldr	r2, [pc, #332]	; (299c <dhcp_create_msg+0x17c>)
    2850:	6813      	ldr	r3, [r2, #0]
    2852:	3301      	adds	r3, #1
    2854:	6013      	str	r3, [r2, #0]
	dhcp->xid = xid;
    2856:	4b51      	ldr	r3, [pc, #324]	; (299c <dhcp_create_msg+0x17c>)
    2858:	6819      	ldr	r1, [r3, #0]
    285a:	6021      	str	r1, [r4, #0]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("transaction id xid(%" X32_F ")\n", xid));
    285c:	4850      	ldr	r0, [pc, #320]	; (29a0 <dhcp_create_msg+0x180>)
    285e:	4b51      	ldr	r3, [pc, #324]	; (29a4 <dhcp_create_msg+0x184>)
    2860:	4798      	blx	r3
	dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    2862:	6923      	ldr	r3, [r4, #16]
    2864:	685a      	ldr	r2, [r3, #4]
    2866:	6162      	str	r2, [r4, #20]
	dhcp->msg_out->op = DHCP_BOOTREQUEST;
    2868:	2301      	movs	r3, #1
    286a:	7013      	strb	r3, [r2, #0]
	dhcp->msg_out->htype = DHCP_HTYPE_ETH;
    286c:	6962      	ldr	r2, [r4, #20]
    286e:	7053      	strb	r3, [r2, #1]
	dhcp->msg_out->hlen  = netif->hwaddr_len;
    2870:	6963      	ldr	r3, [r4, #20]
    2872:	f896 202e 	ldrb.w	r2, [r6, #46]	; 0x2e
    2876:	709a      	strb	r2, [r3, #2]
	dhcp->msg_out->hops  = 0;
    2878:	6963      	ldr	r3, [r4, #20]
    287a:	2700      	movs	r7, #0
    287c:	70df      	strb	r7, [r3, #3]
	dhcp->msg_out->xid   = htonl(dhcp->xid);
    287e:	f8d4 8014 	ldr.w	r8, [r4, #20]
    2882:	6820      	ldr	r0, [r4, #0]
    2884:	4b48      	ldr	r3, [pc, #288]	; (29a8 <dhcp_create_msg+0x188>)
    2886:	4798      	blx	r3
    2888:	f8c8 0004 	str.w	r0, [r8, #4]
	dhcp->msg_out->secs  = 0;
    288c:	6963      	ldr	r3, [r4, #20]
    288e:	721f      	strb	r7, [r3, #8]
    2890:	725f      	strb	r7, [r3, #9]
	dhcp->msg_out->flags = 0;
    2892:	6963      	ldr	r3, [r4, #20]
    2894:	729f      	strb	r7, [r3, #10]
    2896:	72df      	strb	r7, [r3, #11]
	ip_addr_set_zero(&dhcp->msg_out->ciaddr);
    2898:	6963      	ldr	r3, [r4, #20]
    289a:	731f      	strb	r7, [r3, #12]
    289c:	735f      	strb	r7, [r3, #13]
    289e:	739f      	strb	r7, [r3, #14]
    28a0:	73df      	strb	r7, [r3, #15]
	if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE)
    28a2:	2d08      	cmp	r5, #8
    28a4:	d008      	beq.n	28b8 <dhcp_create_msg+0x98>
    28a6:	2d04      	cmp	r5, #4
    28a8:	d006      	beq.n	28b8 <dhcp_create_msg+0x98>
	    || ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    28aa:	2d03      	cmp	r5, #3
    28ac:	d107      	bne.n	28be <dhcp_create_msg+0x9e>
	        ((dhcp->state == DHCP_RENEWING) || dhcp->state == DHCP_REBINDING))) {
    28ae:	7b23      	ldrb	r3, [r4, #12]
    28b0:	3b04      	subs	r3, #4
	    || ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    28b2:	b2db      	uxtb	r3, r3
    28b4:	2b01      	cmp	r3, #1
    28b6:	d802      	bhi.n	28be <dhcp_create_msg+0x9e>
		ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
    28b8:	6963      	ldr	r3, [r4, #20]
    28ba:	6872      	ldr	r2, [r6, #4]
    28bc:	60da      	str	r2, [r3, #12]
	ip_addr_set_zero(&dhcp->msg_out->yiaddr);
    28be:	6962      	ldr	r2, [r4, #20]
    28c0:	2300      	movs	r3, #0
    28c2:	7413      	strb	r3, [r2, #16]
    28c4:	7453      	strb	r3, [r2, #17]
    28c6:	7493      	strb	r3, [r2, #18]
    28c8:	74d3      	strb	r3, [r2, #19]
	ip_addr_set_zero(&dhcp->msg_out->siaddr);
    28ca:	6962      	ldr	r2, [r4, #20]
    28cc:	7513      	strb	r3, [r2, #20]
    28ce:	7553      	strb	r3, [r2, #21]
    28d0:	7593      	strb	r3, [r2, #22]
    28d2:	75d3      	strb	r3, [r2, #23]
	ip_addr_set_zero(&dhcp->msg_out->giaddr);
    28d4:	6962      	ldr	r2, [r4, #20]
    28d6:	7613      	strb	r3, [r2, #24]
    28d8:	7653      	strb	r3, [r2, #25]
    28da:	7693      	strb	r3, [r2, #26]
    28dc:	76d3      	strb	r3, [r2, #27]
    28de:	f106 012f 	add.w	r1, r6, #47	; 0x2f
		dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0 /* pad byte*/;
    28e2:	469c      	mov	ip, r3
    28e4:	6962      	ldr	r2, [r4, #20]
    28e6:	f896 e02e 	ldrb.w	lr, [r6, #46]	; 0x2e
    28ea:	b29f      	uxth	r7, r3
    28ec:	45be      	cmp	lr, r7
    28ee:	bf8c      	ite	hi
    28f0:	780f      	ldrbhi	r7, [r1, #0]
    28f2:	4667      	movls	r7, ip
    28f4:	441a      	add	r2, r3
    28f6:	7717      	strb	r7, [r2, #28]
    28f8:	3301      	adds	r3, #1
    28fa:	3101      	adds	r1, #1
	for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    28fc:	2b10      	cmp	r3, #16
    28fe:	d1f1      	bne.n	28e4 <dhcp_create_msg+0xc4>
    2900:	2300      	movs	r3, #0
		dhcp->msg_out->sname[i] = 0;
    2902:	4619      	mov	r1, r3
    2904:	6962      	ldr	r2, [r4, #20]
    2906:	441a      	add	r2, r3
    2908:	f882 102c 	strb.w	r1, [r2, #44]	; 0x2c
    290c:	3301      	adds	r3, #1
	for (i = 0; i < DHCP_SNAME_LEN; i++) {
    290e:	2b40      	cmp	r3, #64	; 0x40
    2910:	d1f8      	bne.n	2904 <dhcp_create_msg+0xe4>
    2912:	2300      	movs	r3, #0
		dhcp->msg_out->file[i] = 0;
    2914:	4619      	mov	r1, r3
    2916:	6962      	ldr	r2, [r4, #20]
    2918:	441a      	add	r2, r3
    291a:	f882 106c 	strb.w	r1, [r2, #108]	; 0x6c
    291e:	3301      	adds	r3, #1
	for (i = 0; i < DHCP_FILE_LEN; i++) {
    2920:	2b80      	cmp	r3, #128	; 0x80
    2922:	d1f8      	bne.n	2916 <dhcp_create_msg+0xf6>
	dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
    2924:	6962      	ldr	r2, [r4, #20]
    2926:	2300      	movs	r3, #0
    2928:	2163      	movs	r1, #99	; 0x63
    292a:	f882 10ec 	strb.w	r1, [r2, #236]	; 0xec
    292e:	f06f 007d 	mvn.w	r0, #125	; 0x7d
    2932:	f882 00ed 	strb.w	r0, [r2, #237]	; 0xed
    2936:	2053      	movs	r0, #83	; 0x53
    2938:	f882 00ee 	strb.w	r0, [r2, #238]	; 0xee
    293c:	f882 10ef 	strb.w	r1, [r2, #239]	; 0xef
	dhcp->options_out_len = 0;
    2940:	8323      	strh	r3, [r4, #24]
		dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
    2942:	6962      	ldr	r2, [r4, #20]
    2944:	441a      	add	r2, r3
    2946:	f882 30f0 	strb.w	r3, [r2, #240]	; 0xf0
    294a:	3301      	adds	r3, #1
	for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    294c:	2b44      	cmp	r3, #68	; 0x44
    294e:	d1f8      	bne.n	2942 <dhcp_create_msg+0x122>
	dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    2950:	2201      	movs	r2, #1
    2952:	2135      	movs	r1, #53	; 0x35
    2954:	4620      	mov	r0, r4
    2956:	4b15      	ldr	r3, [pc, #84]	; (29ac <dhcp_create_msg+0x18c>)
    2958:	4798      	blx	r3
	dhcp_option_byte(dhcp, message_type);
    295a:	4629      	mov	r1, r5
    295c:	4620      	mov	r0, r4
    295e:	4b14      	ldr	r3, [pc, #80]	; (29b0 <dhcp_create_msg+0x190>)
    2960:	4798      	blx	r3
	return ERR_OK;
    2962:	2000      	movs	r0, #0
}
    2964:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
    2968:	4b12      	ldr	r3, [pc, #72]	; (29b4 <dhcp_create_msg+0x194>)
    296a:	f44f 62d1 	mov.w	r2, #1672	; 0x688
    296e:	4912      	ldr	r1, [pc, #72]	; (29b8 <dhcp_create_msg+0x198>)
    2970:	4812      	ldr	r0, [pc, #72]	; (29bc <dhcp_create_msg+0x19c>)
    2972:	4c0c      	ldr	r4, [pc, #48]	; (29a4 <dhcp_create_msg+0x184>)
    2974:	47a0      	blx	r4
    2976:	e7fe      	b.n	2976 <dhcp_create_msg+0x156>
	LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    2978:	4b0e      	ldr	r3, [pc, #56]	; (29b4 <dhcp_create_msg+0x194>)
    297a:	f240 6289 	movw	r2, #1673	; 0x689
    297e:	4910      	ldr	r1, [pc, #64]	; (29c0 <dhcp_create_msg+0x1a0>)
    2980:	480e      	ldr	r0, [pc, #56]	; (29bc <dhcp_create_msg+0x19c>)
    2982:	4c08      	ldr	r4, [pc, #32]	; (29a4 <dhcp_create_msg+0x184>)
    2984:	47a0      	blx	r4
    2986:	e7fe      	b.n	2986 <dhcp_create_msg+0x166>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    2988:	480e      	ldr	r0, [pc, #56]	; (29c4 <dhcp_create_msg+0x1a4>)
    298a:	4b0f      	ldr	r3, [pc, #60]	; (29c8 <dhcp_create_msg+0x1a8>)
    298c:	4798      	blx	r3
		return ERR_MEM;
    298e:	f04f 30ff 	mov.w	r0, #4294967295
    2992:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2996:	bf00      	nop
    2998:	00005531 	.word	0x00005531
    299c:	20000000 	.word	0x20000000
    29a0:	0000aba0 	.word	0x0000aba0
    29a4:	00009815 	.word	0x00009815
    29a8:	000026f9 	.word	0x000026f9
    29ac:	0000272d 	.word	0x0000272d
    29b0:	0000274f 	.word	0x0000274f
    29b4:	0000aac4 	.word	0x0000aac4
    29b8:	0000ab34 	.word	0x0000ab34
    29bc:	0000ab0c 	.word	0x0000ab0c
    29c0:	0000ab54 	.word	0x0000ab54
    29c4:	0000ab74 	.word	0x0000ab74
    29c8:	000098fd 	.word	0x000098fd

000029cc <dhcp_delete_msg>:
{
    29cc:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
    29ce:	b140      	cbz	r0, 29e2 <dhcp_delete_msg+0x16>
    29d0:	4604      	mov	r4, r0
	if (dhcp->p_out != NULL) {
    29d2:	6900      	ldr	r0, [r0, #16]
    29d4:	b108      	cbz	r0, 29da <dhcp_delete_msg+0xe>
		pbuf_free(dhcp->p_out);
    29d6:	4b07      	ldr	r3, [pc, #28]	; (29f4 <dhcp_delete_msg+0x28>)
    29d8:	4798      	blx	r3
	dhcp->p_out   = NULL;
    29da:	2300      	movs	r3, #0
    29dc:	6123      	str	r3, [r4, #16]
	dhcp->msg_out = NULL;
    29de:	6163      	str	r3, [r4, #20]
    29e0:	bd10      	pop	{r4, pc}
	LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
    29e2:	4b05      	ldr	r3, [pc, #20]	; (29f8 <dhcp_delete_msg+0x2c>)
    29e4:	f240 62d3 	movw	r2, #1747	; 0x6d3
    29e8:	4904      	ldr	r1, [pc, #16]	; (29fc <dhcp_delete_msg+0x30>)
    29ea:	4805      	ldr	r0, [pc, #20]	; (2a00 <dhcp_delete_msg+0x34>)
    29ec:	4c05      	ldr	r4, [pc, #20]	; (2a04 <dhcp_delete_msg+0x38>)
    29ee:	47a0      	blx	r4
    29f0:	e7fe      	b.n	29f0 <dhcp_delete_msg+0x24>
    29f2:	bf00      	nop
    29f4:	000054c9 	.word	0x000054c9
    29f8:	0000aac4 	.word	0x0000aac4
    29fc:	0000abb8 	.word	0x0000abb8
    2a00:	0000ab0c 	.word	0x0000ab0c
    2a04:	00009815 	.word	0x00009815

00002a08 <dhcp_rebind>:
{
    2a08:	b570      	push	{r4, r5, r6, lr}
    2a0a:	b082      	sub	sp, #8
    2a0c:	4606      	mov	r6, r0
	struct dhcp *dhcp = netif->dhcp;
    2a0e:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
    2a10:	4827      	ldr	r0, [pc, #156]	; (2ab0 <dhcp_rebind+0xa8>)
    2a12:	4b28      	ldr	r3, [pc, #160]	; (2ab4 <dhcp_rebind+0xac>)
    2a14:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_REBINDING);
    2a16:	2104      	movs	r1, #4
    2a18:	4620      	mov	r0, r4
    2a1a:	4b27      	ldr	r3, [pc, #156]	; (2ab8 <dhcp_rebind+0xb0>)
    2a1c:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    2a1e:	2203      	movs	r2, #3
    2a20:	4621      	mov	r1, r4
    2a22:	4630      	mov	r0, r6
    2a24:	4b25      	ldr	r3, [pc, #148]	; (2abc <dhcp_rebind+0xb4>)
    2a26:	4798      	blx	r3
	if (result == ERR_OK) {
    2a28:	4605      	mov	r5, r0
    2a2a:	2800      	cmp	r0, #0
    2a2c:	d139      	bne.n	2aa2 <dhcp_rebind+0x9a>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    2a2e:	2202      	movs	r2, #2
    2a30:	2139      	movs	r1, #57	; 0x39
    2a32:	4620      	mov	r0, r4
    2a34:	4b22      	ldr	r3, [pc, #136]	; (2ac0 <dhcp_rebind+0xb8>)
    2a36:	4798      	blx	r3
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    2a38:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
    2a3a:	4620      	mov	r0, r4
    2a3c:	4b21      	ldr	r3, [pc, #132]	; (2ac4 <dhcp_rebind+0xbc>)
    2a3e:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    2a40:	4620      	mov	r0, r4
    2a42:	4b21      	ldr	r3, [pc, #132]	; (2ac8 <dhcp_rebind+0xc0>)
    2a44:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    2a46:	8b21      	ldrh	r1, [r4, #24]
    2a48:	31f0      	adds	r1, #240	; 0xf0
    2a4a:	b289      	uxth	r1, r1
    2a4c:	6920      	ldr	r0, [r4, #16]
    2a4e:	4b1f      	ldr	r3, [pc, #124]	; (2acc <dhcp_rebind+0xc4>)
    2a50:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2a52:	6921      	ldr	r1, [r4, #16]
    2a54:	6860      	ldr	r0, [r4, #4]
    2a56:	9600      	str	r6, [sp, #0]
    2a58:	2343      	movs	r3, #67	; 0x43
    2a5a:	4a1d      	ldr	r2, [pc, #116]	; (2ad0 <dhcp_rebind+0xc8>)
    2a5c:	4e1d      	ldr	r6, [pc, #116]	; (2ad4 <dhcp_rebind+0xcc>)
    2a5e:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    2a60:	4620      	mov	r0, r4
    2a62:	4b1d      	ldr	r3, [pc, #116]	; (2ad8 <dhcp_rebind+0xd0>)
    2a64:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
    2a66:	481d      	ldr	r0, [pc, #116]	; (2adc <dhcp_rebind+0xd4>)
    2a68:	4b12      	ldr	r3, [pc, #72]	; (2ab4 <dhcp_rebind+0xac>)
    2a6a:	4798      	blx	r3
	dhcp->tries++;
    2a6c:	7b61      	ldrb	r1, [r4, #13]
    2a6e:	3101      	adds	r1, #1
    2a70:	b2c9      	uxtb	r1, r1
    2a72:	7361      	strb	r1, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    2a74:	2909      	cmp	r1, #9
    2a76:	d818      	bhi.n	2aaa <dhcp_rebind+0xa2>
    2a78:	ebc1 1341 	rsb	r3, r1, r1, lsl #5
    2a7c:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    2a80:	00c9      	lsls	r1, r1, #3
    2a82:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2a84:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    2a88:	4a15      	ldr	r2, [pc, #84]	; (2ae0 <dhcp_rebind+0xd8>)
    2a8a:	fb82 0203 	smull	r0, r2, r2, r3
    2a8e:	17db      	asrs	r3, r3, #31
    2a90:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    2a94:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    2a96:	4813      	ldr	r0, [pc, #76]	; (2ae4 <dhcp_rebind+0xdc>)
    2a98:	4b13      	ldr	r3, [pc, #76]	; (2ae8 <dhcp_rebind+0xe0>)
    2a9a:	4798      	blx	r3
}
    2a9c:	4628      	mov	r0, r5
    2a9e:	b002      	add	sp, #8
    2aa0:	bd70      	pop	{r4, r5, r6, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    2aa2:	4812      	ldr	r0, [pc, #72]	; (2aec <dhcp_rebind+0xe4>)
    2aa4:	4b03      	ldr	r3, [pc, #12]	; (2ab4 <dhcp_rebind+0xac>)
    2aa6:	4798      	blx	r3
    2aa8:	e7e0      	b.n	2a6c <dhcp_rebind+0x64>
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    2aaa:	f242 7110 	movw	r1, #10000	; 0x2710
    2aae:	e7e9      	b.n	2a84 <dhcp_rebind+0x7c>
    2ab0:	0000abd8 	.word	0x0000abd8
    2ab4:	000098fd 	.word	0x000098fd
    2ab8:	0000271d 	.word	0x0000271d
    2abc:	00002821 	.word	0x00002821
    2ac0:	0000272d 	.word	0x0000272d
    2ac4:	00002765 	.word	0x00002765
    2ac8:	000027d1 	.word	0x000027d1
    2acc:	0000566d 	.word	0x0000566d
    2ad0:	0000babc 	.word	0x0000babc
    2ad4:	000084f1 	.word	0x000084f1
    2ad8:	000029cd 	.word	0x000029cd
    2adc:	0000abe8 	.word	0x0000abe8
    2ae0:	10624dd3 	.word	0x10624dd3
    2ae4:	0000ac30 	.word	0x0000ac30
    2ae8:	00009815 	.word	0x00009815
    2aec:	0000ac00 	.word	0x0000ac00

00002af0 <dhcp_discover>:
{
    2af0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2af4:	b082      	sub	sp, #8
    2af6:	4606      	mov	r6, r0
	struct dhcp *dhcp   = netif->dhcp;
    2af8:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
    2afa:	4836      	ldr	r0, [pc, #216]	; (2bd4 <dhcp_discover+0xe4>)
    2afc:	4b36      	ldr	r3, [pc, #216]	; (2bd8 <dhcp_discover+0xe8>)
    2afe:	4798      	blx	r3
	ip_addr_set_any(&dhcp->offered_ip_addr);
    2b00:	2300      	movs	r3, #0
    2b02:	6263      	str	r3, [r4, #36]	; 0x24
	dhcp_set_state(dhcp, DHCP_SELECTING);
    2b04:	2106      	movs	r1, #6
    2b06:	4620      	mov	r0, r4
    2b08:	4b34      	ldr	r3, [pc, #208]	; (2bdc <dhcp_discover+0xec>)
    2b0a:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
    2b0c:	2201      	movs	r2, #1
    2b0e:	4621      	mov	r1, r4
    2b10:	4630      	mov	r0, r6
    2b12:	4b33      	ldr	r3, [pc, #204]	; (2be0 <dhcp_discover+0xf0>)
    2b14:	4798      	blx	r3
	if (result == ERR_OK) {
    2b16:	4605      	mov	r5, r0
    2b18:	2800      	cmp	r0, #0
    2b1a:	d156      	bne.n	2bca <dhcp_discover+0xda>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    2b1c:	4831      	ldr	r0, [pc, #196]	; (2be4 <dhcp_discover+0xf4>)
    2b1e:	4f2e      	ldr	r7, [pc, #184]	; (2bd8 <dhcp_discover+0xe8>)
    2b20:	47b8      	blx	r7
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    2b22:	2202      	movs	r2, #2
    2b24:	2139      	movs	r1, #57	; 0x39
    2b26:	4620      	mov	r0, r4
    2b28:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 2c20 <dhcp_discover+0x130>
    2b2c:	47c0      	blx	r8
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    2b2e:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
    2b30:	4620      	mov	r0, r4
    2b32:	4b2d      	ldr	r3, [pc, #180]	; (2be8 <dhcp_discover+0xf8>)
    2b34:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4 /*num options*/);
    2b36:	2204      	movs	r2, #4
    2b38:	2137      	movs	r1, #55	; 0x37
    2b3a:	4620      	mov	r0, r4
    2b3c:	47c0      	blx	r8
		dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    2b3e:	2101      	movs	r1, #1
    2b40:	4620      	mov	r0, r4
    2b42:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 2c24 <dhcp_discover+0x134>
    2b46:	47c0      	blx	r8
		dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    2b48:	2103      	movs	r1, #3
    2b4a:	4620      	mov	r0, r4
    2b4c:	47c0      	blx	r8
		dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    2b4e:	211c      	movs	r1, #28
    2b50:	4620      	mov	r0, r4
    2b52:	47c0      	blx	r8
		dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    2b54:	2106      	movs	r1, #6
    2b56:	4620      	mov	r0, r4
    2b58:	47c0      	blx	r8
		dhcp_option_trailer(dhcp);
    2b5a:	4620      	mov	r0, r4
    2b5c:	4b23      	ldr	r3, [pc, #140]	; (2bec <dhcp_discover+0xfc>)
    2b5e:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    2b60:	4823      	ldr	r0, [pc, #140]	; (2bf0 <dhcp_discover+0x100>)
    2b62:	47b8      	blx	r7
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    2b64:	8b21      	ldrh	r1, [r4, #24]
    2b66:	31f0      	adds	r1, #240	; 0xf0
    2b68:	b289      	uxth	r1, r1
    2b6a:	6920      	ldr	r0, [r4, #16]
    2b6c:	4b21      	ldr	r3, [pc, #132]	; (2bf4 <dhcp_discover+0x104>)
    2b6e:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    2b70:	4821      	ldr	r0, [pc, #132]	; (2bf8 <dhcp_discover+0x108>)
    2b72:	47b8      	blx	r7
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2b74:	6921      	ldr	r1, [r4, #16]
    2b76:	6860      	ldr	r0, [r4, #4]
    2b78:	9600      	str	r6, [sp, #0]
    2b7a:	2343      	movs	r3, #67	; 0x43
    2b7c:	4a1f      	ldr	r2, [pc, #124]	; (2bfc <dhcp_discover+0x10c>)
    2b7e:	4e20      	ldr	r6, [pc, #128]	; (2c00 <dhcp_discover+0x110>)
    2b80:	47b0      	blx	r6
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    2b82:	4820      	ldr	r0, [pc, #128]	; (2c04 <dhcp_discover+0x114>)
    2b84:	47b8      	blx	r7
		dhcp_delete_msg(dhcp);
    2b86:	4620      	mov	r0, r4
    2b88:	4b1f      	ldr	r3, [pc, #124]	; (2c08 <dhcp_discover+0x118>)
    2b8a:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    2b8c:	481f      	ldr	r0, [pc, #124]	; (2c0c <dhcp_discover+0x11c>)
    2b8e:	47b8      	blx	r7
	dhcp->tries++;
    2b90:	7b61      	ldrb	r1, [r4, #13]
    2b92:	3101      	adds	r1, #1
    2b94:	b2c9      	uxtb	r1, r1
    2b96:	7361      	strb	r1, [r4, #13]
	msecs                 = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    2b98:	2905      	cmp	r1, #5
    2b9a:	bf9a      	itte	ls
    2b9c:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
    2ba0:	fa03 f101 	lslls.w	r1, r3, r1
    2ba4:	f64e 2160 	movwhi	r1, #60000	; 0xea60
    2ba8:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2baa:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    2bae:	4a18      	ldr	r2, [pc, #96]	; (2c10 <dhcp_discover+0x120>)
    2bb0:	fb82 0203 	smull	r0, r2, r2, r3
    2bb4:	17db      	asrs	r3, r3, #31
    2bb6:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    2bba:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    2bbc:	4815      	ldr	r0, [pc, #84]	; (2c14 <dhcp_discover+0x124>)
    2bbe:	4b16      	ldr	r3, [pc, #88]	; (2c18 <dhcp_discover+0x128>)
    2bc0:	4798      	blx	r3
}
    2bc2:	4628      	mov	r0, r5
    2bc4:	b002      	add	sp, #8
    2bc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    2bca:	4814      	ldr	r0, [pc, #80]	; (2c1c <dhcp_discover+0x12c>)
    2bcc:	4b02      	ldr	r3, [pc, #8]	; (2bd8 <dhcp_discover+0xe8>)
    2bce:	4798      	blx	r3
    2bd0:	e7de      	b.n	2b90 <dhcp_discover+0xa0>
    2bd2:	bf00      	nop
    2bd4:	0000ac60 	.word	0x0000ac60
    2bd8:	000098fd 	.word	0x000098fd
    2bdc:	0000271d 	.word	0x0000271d
    2be0:	00002821 	.word	0x00002821
    2be4:	0000ac70 	.word	0x0000ac70
    2be8:	00002765 	.word	0x00002765
    2bec:	000027d1 	.word	0x000027d1
    2bf0:	0000ac90 	.word	0x0000ac90
    2bf4:	0000566d 	.word	0x0000566d
    2bf8:	0000acac 	.word	0x0000acac
    2bfc:	0000babc 	.word	0x0000babc
    2c00:	000084f1 	.word	0x000084f1
    2c04:	0000acf4 	.word	0x0000acf4
    2c08:	000029cd 	.word	0x000029cd
    2c0c:	0000ad14 	.word	0x0000ad14
    2c10:	10624dd3 	.word	0x10624dd3
    2c14:	0000ad60 	.word	0x0000ad60
    2c18:	00009815 	.word	0x00009815
    2c1c:	0000ad30 	.word	0x0000ad30
    2c20:	0000272d 	.word	0x0000272d
    2c24:	0000274f 	.word	0x0000274f

00002c28 <dhcp_select>:
{
    2c28:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2c2c:	b083      	sub	sp, #12
    2c2e:	4605      	mov	r5, r0
	struct dhcp *dhcp = netif->dhcp;
    2c30:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(
    2c32:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    2c36:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
    2c3a:	f890 1038 	ldrb.w	r1, [r0, #56]	; 0x38
    2c3e:	9100      	str	r1, [sp, #0]
    2c40:	4601      	mov	r1, r0
    2c42:	483a      	ldr	r0, [pc, #232]	; (2d2c <dhcp_select+0x104>)
    2c44:	4e3a      	ldr	r6, [pc, #232]	; (2d30 <dhcp_select+0x108>)
    2c46:	47b0      	blx	r6
	dhcp_set_state(dhcp, DHCP_REQUESTING);
    2c48:	2101      	movs	r1, #1
    2c4a:	4620      	mov	r0, r4
    2c4c:	4b39      	ldr	r3, [pc, #228]	; (2d34 <dhcp_select+0x10c>)
    2c4e:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    2c50:	2203      	movs	r2, #3
    2c52:	4621      	mov	r1, r4
    2c54:	4628      	mov	r0, r5
    2c56:	4b38      	ldr	r3, [pc, #224]	; (2d38 <dhcp_select+0x110>)
    2c58:	4798      	blx	r3
	if (result == ERR_OK) {
    2c5a:	4681      	mov	r9, r0
    2c5c:	2800      	cmp	r0, #0
    2c5e:	d161      	bne.n	2d24 <dhcp_select+0xfc>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    2c60:	2202      	movs	r2, #2
    2c62:	2139      	movs	r1, #57	; 0x39
    2c64:	4620      	mov	r0, r4
    2c66:	4f35      	ldr	r7, [pc, #212]	; (2d3c <dhcp_select+0x114>)
    2c68:	47b8      	blx	r7
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    2c6a:	8da9      	ldrh	r1, [r5, #44]	; 0x2c
    2c6c:	4620      	mov	r0, r4
    2c6e:	4b34      	ldr	r3, [pc, #208]	; (2d40 <dhcp_select+0x118>)
    2c70:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    2c72:	2204      	movs	r2, #4
    2c74:	2132      	movs	r1, #50	; 0x32
    2c76:	4620      	mov	r0, r4
    2c78:	47b8      	blx	r7
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    2c7a:	6a60      	ldr	r0, [r4, #36]	; 0x24
    2c7c:	4e31      	ldr	r6, [pc, #196]	; (2d44 <dhcp_select+0x11c>)
    2c7e:	47b0      	blx	r6
    2c80:	4601      	mov	r1, r0
    2c82:	4620      	mov	r0, r4
    2c84:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 2d74 <dhcp_select+0x14c>
    2c88:	47c0      	blx	r8
		dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    2c8a:	2204      	movs	r2, #4
    2c8c:	2136      	movs	r1, #54	; 0x36
    2c8e:	4620      	mov	r0, r4
    2c90:	47b8      	blx	r7
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
    2c92:	6a20      	ldr	r0, [r4, #32]
    2c94:	47b0      	blx	r6
    2c96:	4601      	mov	r1, r0
    2c98:	4620      	mov	r0, r4
    2c9a:	47c0      	blx	r8
		dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4 /*num options*/);
    2c9c:	2204      	movs	r2, #4
    2c9e:	2137      	movs	r1, #55	; 0x37
    2ca0:	4620      	mov	r0, r4
    2ca2:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    2ca4:	2101      	movs	r1, #1
    2ca6:	4620      	mov	r0, r4
    2ca8:	4f27      	ldr	r7, [pc, #156]	; (2d48 <dhcp_select+0x120>)
    2caa:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    2cac:	2103      	movs	r1, #3
    2cae:	4620      	mov	r0, r4
    2cb0:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    2cb2:	211c      	movs	r1, #28
    2cb4:	4620      	mov	r0, r4
    2cb6:	47b8      	blx	r7
		dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    2cb8:	2106      	movs	r1, #6
    2cba:	4620      	mov	r0, r4
    2cbc:	47b8      	blx	r7
		dhcp_option_trailer(dhcp);
    2cbe:	4620      	mov	r0, r4
    2cc0:	4b22      	ldr	r3, [pc, #136]	; (2d4c <dhcp_select+0x124>)
    2cc2:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    2cc4:	8b21      	ldrh	r1, [r4, #24]
    2cc6:	31f0      	adds	r1, #240	; 0xf0
    2cc8:	b289      	uxth	r1, r1
    2cca:	6920      	ldr	r0, [r4, #16]
    2ccc:	4b20      	ldr	r3, [pc, #128]	; (2d50 <dhcp_select+0x128>)
    2cce:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2cd0:	6921      	ldr	r1, [r4, #16]
    2cd2:	6860      	ldr	r0, [r4, #4]
    2cd4:	9500      	str	r5, [sp, #0]
    2cd6:	2343      	movs	r3, #67	; 0x43
    2cd8:	4a1e      	ldr	r2, [pc, #120]	; (2d54 <dhcp_select+0x12c>)
    2cda:	4d1f      	ldr	r5, [pc, #124]	; (2d58 <dhcp_select+0x130>)
    2cdc:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    2cde:	4620      	mov	r0, r4
    2ce0:	4b1e      	ldr	r3, [pc, #120]	; (2d5c <dhcp_select+0x134>)
    2ce2:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    2ce4:	481e      	ldr	r0, [pc, #120]	; (2d60 <dhcp_select+0x138>)
    2ce6:	4b1f      	ldr	r3, [pc, #124]	; (2d64 <dhcp_select+0x13c>)
    2ce8:	4798      	blx	r3
	dhcp->tries++;
    2cea:	7b61      	ldrb	r1, [r4, #13]
    2cec:	3101      	adds	r1, #1
    2cee:	b2c9      	uxtb	r1, r1
    2cf0:	7361      	strb	r1, [r4, #13]
	msecs                 = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    2cf2:	2905      	cmp	r1, #5
    2cf4:	bf9a      	itte	ls
    2cf6:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
    2cfa:	fa03 f101 	lslls.w	r1, r3, r1
    2cfe:	f64e 2160 	movwhi	r1, #60000	; 0xea60
    2d02:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2d04:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    2d08:	4a17      	ldr	r2, [pc, #92]	; (2d68 <dhcp_select+0x140>)
    2d0a:	fb82 0203 	smull	r0, r2, r2, r3
    2d0e:	17db      	asrs	r3, r3, #31
    2d10:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    2d14:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %" U16_F " msecs\n", msecs));
    2d16:	4815      	ldr	r0, [pc, #84]	; (2d6c <dhcp_select+0x144>)
    2d18:	4b05      	ldr	r3, [pc, #20]	; (2d30 <dhcp_select+0x108>)
    2d1a:	4798      	blx	r3
}
    2d1c:	4648      	mov	r0, r9
    2d1e:	b003      	add	sp, #12
    2d20:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    2d24:	4812      	ldr	r0, [pc, #72]	; (2d70 <dhcp_select+0x148>)
    2d26:	4b0f      	ldr	r3, [pc, #60]	; (2d64 <dhcp_select+0x13c>)
    2d28:	4798      	blx	r3
    2d2a:	e7de      	b.n	2cea <dhcp_select+0xc2>
    2d2c:	0000ad90 	.word	0x0000ad90
    2d30:	00009815 	.word	0x00009815
    2d34:	0000271d 	.word	0x0000271d
    2d38:	00002821 	.word	0x00002821
    2d3c:	0000272d 	.word	0x0000272d
    2d40:	00002765 	.word	0x00002765
    2d44:	00002711 	.word	0x00002711
    2d48:	0000274f 	.word	0x0000274f
    2d4c:	000027d1 	.word	0x000027d1
    2d50:	0000566d 	.word	0x0000566d
    2d54:	0000babc 	.word	0x0000babc
    2d58:	000084f1 	.word	0x000084f1
    2d5c:	000029cd 	.word	0x000029cd
    2d60:	0000adb0 	.word	0x0000adb0
    2d64:	000098fd 	.word	0x000098fd
    2d68:	10624dd3 	.word	0x10624dd3
    2d6c:	0000adf8 	.word	0x0000adf8
    2d70:	0000adc8 	.word	0x0000adc8
    2d74:	0000278b 	.word	0x0000278b

00002d78 <dhcp_reboot>:
{
    2d78:	b5f0      	push	{r4, r5, r6, r7, lr}
    2d7a:	b083      	sub	sp, #12
    2d7c:	4606      	mov	r6, r0
	struct dhcp *dhcp = netif->dhcp;
    2d7e:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
    2d80:	482d      	ldr	r0, [pc, #180]	; (2e38 <dhcp_reboot+0xc0>)
    2d82:	4b2e      	ldr	r3, [pc, #184]	; (2e3c <dhcp_reboot+0xc4>)
    2d84:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_REBOOTING);
    2d86:	2103      	movs	r1, #3
    2d88:	4620      	mov	r0, r4
    2d8a:	4b2d      	ldr	r3, [pc, #180]	; (2e40 <dhcp_reboot+0xc8>)
    2d8c:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    2d8e:	2203      	movs	r2, #3
    2d90:	4621      	mov	r1, r4
    2d92:	4630      	mov	r0, r6
    2d94:	4b2b      	ldr	r3, [pc, #172]	; (2e44 <dhcp_reboot+0xcc>)
    2d96:	4798      	blx	r3
	if (result == ERR_OK) {
    2d98:	4605      	mov	r5, r0
    2d9a:	2800      	cmp	r0, #0
    2d9c:	d145      	bne.n	2e2a <dhcp_reboot+0xb2>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    2d9e:	2202      	movs	r2, #2
    2da0:	2139      	movs	r1, #57	; 0x39
    2da2:	4620      	mov	r0, r4
    2da4:	4f28      	ldr	r7, [pc, #160]	; (2e48 <dhcp_reboot+0xd0>)
    2da6:	47b8      	blx	r7
		dhcp_option_short(dhcp, 576);
    2da8:	f44f 7110 	mov.w	r1, #576	; 0x240
    2dac:	4620      	mov	r0, r4
    2dae:	4b27      	ldr	r3, [pc, #156]	; (2e4c <dhcp_reboot+0xd4>)
    2db0:	4798      	blx	r3
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    2db2:	2204      	movs	r2, #4
    2db4:	2132      	movs	r1, #50	; 0x32
    2db6:	4620      	mov	r0, r4
    2db8:	47b8      	blx	r7
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    2dba:	6a60      	ldr	r0, [r4, #36]	; 0x24
    2dbc:	4b24      	ldr	r3, [pc, #144]	; (2e50 <dhcp_reboot+0xd8>)
    2dbe:	4798      	blx	r3
    2dc0:	4601      	mov	r1, r0
    2dc2:	4620      	mov	r0, r4
    2dc4:	4b23      	ldr	r3, [pc, #140]	; (2e54 <dhcp_reboot+0xdc>)
    2dc6:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    2dc8:	4620      	mov	r0, r4
    2dca:	4b23      	ldr	r3, [pc, #140]	; (2e58 <dhcp_reboot+0xe0>)
    2dcc:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    2dce:	8b21      	ldrh	r1, [r4, #24]
    2dd0:	31f0      	adds	r1, #240	; 0xf0
    2dd2:	b289      	uxth	r1, r1
    2dd4:	6920      	ldr	r0, [r4, #16]
    2dd6:	4b21      	ldr	r3, [pc, #132]	; (2e5c <dhcp_reboot+0xe4>)
    2dd8:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2dda:	6921      	ldr	r1, [r4, #16]
    2ddc:	6860      	ldr	r0, [r4, #4]
    2dde:	9600      	str	r6, [sp, #0]
    2de0:	2343      	movs	r3, #67	; 0x43
    2de2:	4a1f      	ldr	r2, [pc, #124]	; (2e60 <dhcp_reboot+0xe8>)
    2de4:	4e1f      	ldr	r6, [pc, #124]	; (2e64 <dhcp_reboot+0xec>)
    2de6:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    2de8:	4620      	mov	r0, r4
    2dea:	4b1f      	ldr	r3, [pc, #124]	; (2e68 <dhcp_reboot+0xf0>)
    2dec:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
    2dee:	481f      	ldr	r0, [pc, #124]	; (2e6c <dhcp_reboot+0xf4>)
    2df0:	4b12      	ldr	r3, [pc, #72]	; (2e3c <dhcp_reboot+0xc4>)
    2df2:	4798      	blx	r3
	dhcp->tries++;
    2df4:	7b61      	ldrb	r1, [r4, #13]
    2df6:	3101      	adds	r1, #1
    2df8:	b2c9      	uxtb	r1, r1
    2dfa:	7361      	strb	r1, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    2dfc:	2909      	cmp	r1, #9
    2dfe:	d818      	bhi.n	2e32 <dhcp_reboot+0xba>
    2e00:	ebc1 1341 	rsb	r3, r1, r1, lsl #5
    2e04:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    2e08:	00c9      	lsls	r1, r1, #3
    2e0a:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2e0c:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    2e10:	4a17      	ldr	r2, [pc, #92]	; (2e70 <dhcp_reboot+0xf8>)
    2e12:	fb82 0203 	smull	r0, r2, r2, r3
    2e16:	17db      	asrs	r3, r3, #31
    2e18:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    2e1c:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    2e1e:	4815      	ldr	r0, [pc, #84]	; (2e74 <dhcp_reboot+0xfc>)
    2e20:	4b15      	ldr	r3, [pc, #84]	; (2e78 <dhcp_reboot+0x100>)
    2e22:	4798      	blx	r3
}
    2e24:	4628      	mov	r0, r5
    2e26:	b003      	add	sp, #12
    2e28:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    2e2a:	4814      	ldr	r0, [pc, #80]	; (2e7c <dhcp_reboot+0x104>)
    2e2c:	4b03      	ldr	r3, [pc, #12]	; (2e3c <dhcp_reboot+0xc4>)
    2e2e:	4798      	blx	r3
    2e30:	e7e0      	b.n	2df4 <dhcp_reboot+0x7c>
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    2e32:	f242 7110 	movw	r1, #10000	; 0x2710
    2e36:	e7e9      	b.n	2e0c <dhcp_reboot+0x94>
    2e38:	0000ae28 	.word	0x0000ae28
    2e3c:	000098fd 	.word	0x000098fd
    2e40:	0000271d 	.word	0x0000271d
    2e44:	00002821 	.word	0x00002821
    2e48:	0000272d 	.word	0x0000272d
    2e4c:	00002765 	.word	0x00002765
    2e50:	00002711 	.word	0x00002711
    2e54:	0000278b 	.word	0x0000278b
    2e58:	000027d1 	.word	0x000027d1
    2e5c:	0000566d 	.word	0x0000566d
    2e60:	0000babc 	.word	0x0000babc
    2e64:	000084f1 	.word	0x000084f1
    2e68:	000029cd 	.word	0x000029cd
    2e6c:	0000ae38 	.word	0x0000ae38
    2e70:	10624dd3 	.word	0x10624dd3
    2e74:	0000ae80 	.word	0x0000ae80
    2e78:	00009815 	.word	0x00009815
    2e7c:	0000ae50 	.word	0x0000ae50

00002e80 <dhcp_check>:
{
    2e80:	b570      	push	{r4, r5, r6, lr}
    2e82:	4605      	mov	r5, r0
	struct dhcp *dhcp = netif->dhcp;
    2e84:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    2e86:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    2e8a:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
    2e8e:	4601      	mov	r1, r0
    2e90:	480e      	ldr	r0, [pc, #56]	; (2ecc <dhcp_check+0x4c>)
    2e92:	4e0f      	ldr	r6, [pc, #60]	; (2ed0 <dhcp_check+0x50>)
    2e94:	47b0      	blx	r6
	dhcp_set_state(dhcp, DHCP_CHECKING);
    2e96:	2108      	movs	r1, #8
    2e98:	4620      	mov	r0, r4
    2e9a:	4b0e      	ldr	r3, [pc, #56]	; (2ed4 <dhcp_check+0x54>)
    2e9c:	4798      	blx	r3
	result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
    2e9e:	2200      	movs	r2, #0
    2ea0:	f104 0124 	add.w	r1, r4, #36	; 0x24
    2ea4:	4628      	mov	r0, r5
    2ea6:	4b0c      	ldr	r3, [pc, #48]	; (2ed8 <dhcp_check+0x58>)
    2ea8:	4798      	blx	r3
	if (result != ERR_OK) {
    2eaa:	b950      	cbnz	r0, 2ec2 <dhcp_check+0x42>
	dhcp->tries++;
    2eac:	7b63      	ldrb	r3, [r4, #13]
    2eae:	3301      	adds	r3, #1
    2eb0:	7363      	strb	r3, [r4, #13]
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2eb2:	2301      	movs	r3, #1
    2eb4:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    2eb6:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    2eba:	4808      	ldr	r0, [pc, #32]	; (2edc <dhcp_check+0x5c>)
    2ebc:	4b04      	ldr	r3, [pc, #16]	; (2ed0 <dhcp_check+0x50>)
    2ebe:	4798      	blx	r3
    2ec0:	bd70      	pop	{r4, r5, r6, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    2ec2:	4807      	ldr	r0, [pc, #28]	; (2ee0 <dhcp_check+0x60>)
    2ec4:	4b07      	ldr	r3, [pc, #28]	; (2ee4 <dhcp_check+0x64>)
    2ec6:	4798      	blx	r3
    2ec8:	e7f0      	b.n	2eac <dhcp_check+0x2c>
    2eca:	bf00      	nop
    2ecc:	0000aeb0 	.word	0x0000aeb0
    2ed0:	00009815 	.word	0x00009815
    2ed4:	0000271d 	.word	0x0000271d
    2ed8:	000089ed 	.word	0x000089ed
    2edc:	0000aef4 	.word	0x0000aef4
    2ee0:	0000aecc 	.word	0x0000aecc
    2ee4:	000098fd 	.word	0x000098fd

00002ee8 <dhcp_bind>:
{
    2ee8:	b5f0      	push	{r4, r5, r6, r7, lr}
    2eea:	b085      	sub	sp, #20
	LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    2eec:	2800      	cmp	r0, #0
    2eee:	f000 8085 	beq.w	2ffc <dhcp_bind+0x114>
    2ef2:	4605      	mov	r5, r0
	dhcp = netif->dhcp;
    2ef4:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    2ef6:	2c00      	cmp	r4, #0
    2ef8:	f000 8088 	beq.w	300c <dhcp_bind+0x124>
	LWIP_DEBUGF(
    2efc:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    2f00:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
    2f04:	f890 1038 	ldrb.w	r1, [r0, #56]	; 0x38
    2f08:	9100      	str	r1, [sp, #0]
    2f0a:	4601      	mov	r1, r0
    2f0c:	484e      	ldr	r0, [pc, #312]	; (3048 <dhcp_bind+0x160>)
    2f0e:	4e4f      	ldr	r6, [pc, #316]	; (304c <dhcp_bind+0x164>)
    2f10:	47b0      	blx	r6
	if (dhcp->offered_t1_renew != 0xffffffffUL) {
    2f12:	6b61      	ldr	r1, [r4, #52]	; 0x34
    2f14:	f1b1 3fff 	cmp.w	r1, #4294967295
    2f18:	d018      	beq.n	2f4c <dhcp_bind+0x64>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    2f1a:	484d      	ldr	r0, [pc, #308]	; (3050 <dhcp_bind+0x168>)
    2f1c:	47b0      	blx	r6
		timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    2f1e:	6b62      	ldr	r2, [r4, #52]	; 0x34
    2f20:	f102 031e 	add.w	r3, r2, #30
    2f24:	494b      	ldr	r1, [pc, #300]	; (3054 <dhcp_bind+0x16c>)
    2f26:	fba1 1303 	umull	r1, r3, r1, r3
    2f2a:	095b      	lsrs	r3, r3, #5
		dhcp->t1_timeout = (u16_t)timeout;
    2f2c:	f64f 71ff 	movw	r1, #65535	; 0xffff
    2f30:	428b      	cmp	r3, r1
    2f32:	bf28      	it	cs
    2f34:	460b      	movcs	r3, r1
    2f36:	b29b      	uxth	r3, r3
		if (dhcp->t1_timeout == 0) {
    2f38:	2b00      	cmp	r3, #0
    2f3a:	d06f      	beq.n	301c <dhcp_bind+0x134>
		dhcp->t1_timeout = (u16_t)timeout;
    2f3c:	83a3      	strh	r3, [r4, #28]
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    2f3e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    2f42:	fb01 f102 	mul.w	r1, r1, r2
    2f46:	4844      	ldr	r0, [pc, #272]	; (3058 <dhcp_bind+0x170>)
    2f48:	4b40      	ldr	r3, [pc, #256]	; (304c <dhcp_bind+0x164>)
    2f4a:	4798      	blx	r3
	if (dhcp->offered_t2_rebind != 0xffffffffUL) {
    2f4c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    2f4e:	f1b1 3fff 	cmp.w	r1, #4294967295
    2f52:	d019      	beq.n	2f88 <dhcp_bind+0xa0>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    2f54:	4841      	ldr	r0, [pc, #260]	; (305c <dhcp_bind+0x174>)
    2f56:	4b3d      	ldr	r3, [pc, #244]	; (304c <dhcp_bind+0x164>)
    2f58:	4798      	blx	r3
		timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    2f5a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    2f5c:	f102 031e 	add.w	r3, r2, #30
    2f60:	493c      	ldr	r1, [pc, #240]	; (3054 <dhcp_bind+0x16c>)
    2f62:	fba1 1303 	umull	r1, r3, r1, r3
    2f66:	095b      	lsrs	r3, r3, #5
		dhcp->t2_timeout = (u16_t)timeout;
    2f68:	f64f 71ff 	movw	r1, #65535	; 0xffff
    2f6c:	428b      	cmp	r3, r1
    2f6e:	bf28      	it	cs
    2f70:	460b      	movcs	r3, r1
    2f72:	b29b      	uxth	r3, r3
		if (dhcp->t2_timeout == 0) {
    2f74:	2b00      	cmp	r3, #0
    2f76:	d054      	beq.n	3022 <dhcp_bind+0x13a>
		dhcp->t2_timeout = (u16_t)timeout;
    2f78:	83e3      	strh	r3, [r4, #30]
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    2f7a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    2f7e:	fb01 f102 	mul.w	r1, r1, r2
    2f82:	4835      	ldr	r0, [pc, #212]	; (3058 <dhcp_bind+0x170>)
    2f84:	4b31      	ldr	r3, [pc, #196]	; (304c <dhcp_bind+0x164>)
    2f86:	4798      	blx	r3
	if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
    2f88:	8be3      	ldrh	r3, [r4, #30]
    2f8a:	8ba2      	ldrh	r2, [r4, #28]
    2f8c:	429a      	cmp	r2, r3
    2f8e:	d302      	bcc.n	2f96 <dhcp_bind+0xae>
    2f90:	b10b      	cbz	r3, 2f96 <dhcp_bind+0xae>
		dhcp->t1_timeout = 0;
    2f92:	2300      	movs	r3, #0
    2f94:	83a3      	strh	r3, [r4, #28]
	if (dhcp->subnet_mask_given) {
    2f96:	7ba3      	ldrb	r3, [r4, #14]
    2f98:	2b00      	cmp	r3, #0
    2f9a:	d045      	beq.n	3028 <dhcp_bind+0x140>
		ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
    2f9c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2f9e:	9303      	str	r3, [sp, #12]
	ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
    2fa0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2fa2:	9302      	str	r3, [sp, #8]
	if (ip_addr_isany(&gw_addr)) {
    2fa4:	b92b      	cbnz	r3, 2fb2 <dhcp_bind+0xca>
		ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
    2fa6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2fa8:	9a03      	ldr	r2, [sp, #12]
    2faa:	4013      	ands	r3, r2
		ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
    2fac:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    2fb0:	9302      	str	r3, [sp, #8]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE,
    2fb2:	4626      	mov	r6, r4
    2fb4:	f856 1f24 	ldr.w	r1, [r6, #36]!
    2fb8:	4829      	ldr	r0, [pc, #164]	; (3060 <dhcp_bind+0x178>)
    2fba:	4f24      	ldr	r7, [pc, #144]	; (304c <dhcp_bind+0x164>)
    2fbc:	47b8      	blx	r7
	netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
    2fbe:	4631      	mov	r1, r6
    2fc0:	4628      	mov	r0, r5
    2fc2:	4b28      	ldr	r3, [pc, #160]	; (3064 <dhcp_bind+0x17c>)
    2fc4:	4798      	blx	r3
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08" X32_F "\n", ip4_addr_get_u32(&sn_mask)));
    2fc6:	ae04      	add	r6, sp, #16
    2fc8:	f856 1d04 	ldr.w	r1, [r6, #-4]!
    2fcc:	4826      	ldr	r0, [pc, #152]	; (3068 <dhcp_bind+0x180>)
    2fce:	47b8      	blx	r7
	netif_set_netmask(netif, &sn_mask);
    2fd0:	4631      	mov	r1, r6
    2fd2:	4628      	mov	r0, r5
    2fd4:	4b25      	ldr	r3, [pc, #148]	; (306c <dhcp_bind+0x184>)
    2fd6:	4798      	blx	r3
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08" X32_F "\n", ip4_addr_get_u32(&gw_addr)));
    2fd8:	ae04      	add	r6, sp, #16
    2fda:	f856 1d08 	ldr.w	r1, [r6, #-8]!
    2fde:	4824      	ldr	r0, [pc, #144]	; (3070 <dhcp_bind+0x188>)
    2fe0:	47b8      	blx	r7
	netif_set_gw(netif, &gw_addr);
    2fe2:	4631      	mov	r1, r6
    2fe4:	4628      	mov	r0, r5
    2fe6:	4b23      	ldr	r3, [pc, #140]	; (3074 <dhcp_bind+0x18c>)
    2fe8:	4798      	blx	r3
	netif_set_up(netif);
    2fea:	4628      	mov	r0, r5
    2fec:	4b22      	ldr	r3, [pc, #136]	; (3078 <dhcp_bind+0x190>)
    2fee:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_BOUND);
    2ff0:	210a      	movs	r1, #10
    2ff2:	4620      	mov	r0, r4
    2ff4:	4b21      	ldr	r3, [pc, #132]	; (307c <dhcp_bind+0x194>)
    2ff6:	4798      	blx	r3
}
    2ff8:	b005      	add	sp, #20
    2ffa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    2ffc:	4b20      	ldr	r3, [pc, #128]	; (3080 <dhcp_bind+0x198>)
    2ffe:	f240 32a3 	movw	r2, #931	; 0x3a3
    3002:	4920      	ldr	r1, [pc, #128]	; (3084 <dhcp_bind+0x19c>)
    3004:	4820      	ldr	r0, [pc, #128]	; (3088 <dhcp_bind+0x1a0>)
    3006:	4c11      	ldr	r4, [pc, #68]	; (304c <dhcp_bind+0x164>)
    3008:	47a0      	blx	r4
    300a:	e7fe      	b.n	300a <dhcp_bind+0x122>
	LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    300c:	4b1c      	ldr	r3, [pc, #112]	; (3080 <dhcp_bind+0x198>)
    300e:	f240 32a5 	movw	r2, #933	; 0x3a5
    3012:	491e      	ldr	r1, [pc, #120]	; (308c <dhcp_bind+0x1a4>)
    3014:	481c      	ldr	r0, [pc, #112]	; (3088 <dhcp_bind+0x1a0>)
    3016:	4c0d      	ldr	r4, [pc, #52]	; (304c <dhcp_bind+0x164>)
    3018:	47a0      	blx	r4
    301a:	e7fe      	b.n	301a <dhcp_bind+0x132>
			dhcp->t1_timeout = 1;
    301c:	2301      	movs	r3, #1
    301e:	83a3      	strh	r3, [r4, #28]
    3020:	e78d      	b.n	2f3e <dhcp_bind+0x56>
			dhcp->t2_timeout = 1;
    3022:	2301      	movs	r3, #1
    3024:	83e3      	strh	r3, [r4, #30]
    3026:	e7a8      	b.n	2f7a <dhcp_bind+0x92>
		u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
    3028:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
		if (first_octet <= 127) {
    302c:	f013 0f80 	tst.w	r3, #128	; 0x80
    3030:	d102      	bne.n	3038 <dhcp_bind+0x150>
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
    3032:	23ff      	movs	r3, #255	; 0xff
    3034:	9303      	str	r3, [sp, #12]
    3036:	e7b3      	b.n	2fa0 <dhcp_bind+0xb8>
		} else if (first_octet >= 192) {
    3038:	2bbf      	cmp	r3, #191	; 0xbf
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
    303a:	bf8c      	ite	hi
    303c:	f06f 437f 	mvnhi.w	r3, #4278190080	; 0xff000000
			ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
    3040:	f64f 73ff 	movwls	r3, #65535	; 0xffff
    3044:	9303      	str	r3, [sp, #12]
    3046:	e7ab      	b.n	2fa0 <dhcp_bind+0xb8>
    3048:	0000af58 	.word	0x0000af58
    304c:	00009815 	.word	0x00009815
    3050:	0000af78 	.word	0x0000af78
    3054:	88888889 	.word	0x88888889
    3058:	0000afa0 	.word	0x0000afa0
    305c:	0000afcc 	.word	0x0000afcc
    3060:	0000aff4 	.word	0x0000aff4
    3064:	0000521d 	.word	0x0000521d
    3068:	0000b010 	.word	0x0000b010
    306c:	0000530d 	.word	0x0000530d
    3070:	0000b02c 	.word	0x0000b02c
    3074:	00005301 	.word	0x00005301
    3078:	00005325 	.word	0x00005325
    307c:	0000271d 	.word	0x0000271d
    3080:	0000aac4 	.word	0x0000aac4
    3084:	0000af24 	.word	0x0000af24
    3088:	0000ab0c 	.word	0x0000ab0c
    308c:	0000af40 	.word	0x0000af40

00003090 <dhcp_recv>:
{
    3090:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3094:	b08d      	sub	sp, #52	; 0x34
    3096:	4681      	mov	r9, r0
    3098:	4693      	mov	fp, r2
	struct dhcp *    dhcp      = netif->dhcp;
    309a:	6a82      	ldr	r2, [r0, #40]	; 0x28
    309c:	9204      	str	r2, [sp, #16]
	struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
    309e:	f8db 5004 	ldr.w	r5, [fp, #4]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    30a2:	7859      	ldrb	r1, [r3, #1]
    30a4:	781a      	ldrb	r2, [r3, #0]
    30a6:	f8bd 0058 	ldrh.w	r0, [sp, #88]	; 0x58
    30aa:	9002      	str	r0, [sp, #8]
    30ac:	78d8      	ldrb	r0, [r3, #3]
    30ae:	9001      	str	r0, [sp, #4]
    30b0:	789b      	ldrb	r3, [r3, #2]
    30b2:	9300      	str	r3, [sp, #0]
    30b4:	460b      	mov	r3, r1
    30b6:	4659      	mov	r1, fp
    30b8:	4859      	ldr	r0, [pc, #356]	; (3220 <dhcp_recv+0x190>)
    30ba:	4c5a      	ldr	r4, [pc, #360]	; (3224 <dhcp_recv+0x194>)
    30bc:	47a0      	blx	r4
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->len = %" U16_F "\n", p->len));
    30be:	f8bb 100a 	ldrh.w	r1, [fp, #10]
    30c2:	4859      	ldr	r0, [pc, #356]	; (3228 <dhcp_recv+0x198>)
    30c4:	47a0      	blx	r4
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %" U16_F "\n", p->tot_len));
    30c6:	f8bb 1008 	ldrh.w	r1, [fp, #8]
    30ca:	4858      	ldr	r0, [pc, #352]	; (322c <dhcp_recv+0x19c>)
    30cc:	47a0      	blx	r4
	if (p->len < DHCP_MIN_REPLY_LEN) {
    30ce:	f8bb 300a 	ldrh.w	r3, [fp, #10]
    30d2:	2b2b      	cmp	r3, #43	; 0x2b
    30d4:	d920      	bls.n	3118 <dhcp_recv+0x88>
	if (reply_msg->op != DHCP_BOOTREPLY) {
    30d6:	7829      	ldrb	r1, [r5, #0]
    30d8:	2902      	cmp	r1, #2
    30da:	d121      	bne.n	3120 <dhcp_recv+0x90>
	for (i = 0; i < netif->hwaddr_len; i++) {
    30dc:	f899 702e 	ldrb.w	r7, [r9, #46]	; 0x2e
    30e0:	b367      	cbz	r7, 313c <dhcp_recv+0xac>
		if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    30e2:	f899 202f 	ldrb.w	r2, [r9, #47]	; 0x2f
    30e6:	7f28      	ldrb	r0, [r5, #28]
    30e8:	4282      	cmp	r2, r0
    30ea:	d125      	bne.n	3138 <dhcp_recv+0xa8>
    30ec:	f109 0630 	add.w	r6, r9, #48	; 0x30
    30f0:	f105 041d 	add.w	r4, r5, #29
    30f4:	2301      	movs	r3, #1
	for (i = 0; i < netif->hwaddr_len; i++) {
    30f6:	b2da      	uxtb	r2, r3
    30f8:	42ba      	cmp	r2, r7
    30fa:	d21f      	bcs.n	313c <dhcp_recv+0xac>
		if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    30fc:	4619      	mov	r1, r3
    30fe:	f816 2b01 	ldrb.w	r2, [r6], #1
    3102:	f814 0b01 	ldrb.w	r0, [r4], #1
    3106:	3301      	adds	r3, #1
    3108:	4282      	cmp	r2, r0
    310a:	d0f4      	beq.n	30f6 <dhcp_recv+0x66>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    310c:	9000      	str	r0, [sp, #0]
    310e:	460b      	mov	r3, r1
    3110:	4847      	ldr	r0, [pc, #284]	; (3230 <dhcp_recv+0x1a0>)
    3112:	4c44      	ldr	r4, [pc, #272]	; (3224 <dhcp_recv+0x194>)
    3114:	47a0      	blx	r4
			goto free_pbuf_and_return;
    3116:	e006      	b.n	3126 <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    3118:	4846      	ldr	r0, [pc, #280]	; (3234 <dhcp_recv+0x1a4>)
    311a:	4b47      	ldr	r3, [pc, #284]	; (3238 <dhcp_recv+0x1a8>)
    311c:	4798      	blx	r3
		goto free_pbuf_and_return;
    311e:	e002      	b.n	3126 <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    3120:	4846      	ldr	r0, [pc, #280]	; (323c <dhcp_recv+0x1ac>)
    3122:	4b40      	ldr	r3, [pc, #256]	; (3224 <dhcp_recv+0x194>)
    3124:	4798      	blx	r3
	dhcp->msg_in = NULL;
    3126:	2300      	movs	r3, #0
    3128:	9a04      	ldr	r2, [sp, #16]
    312a:	6093      	str	r3, [r2, #8]
	pbuf_free(p);
    312c:	4658      	mov	r0, fp
    312e:	4b44      	ldr	r3, [pc, #272]	; (3240 <dhcp_recv+0x1b0>)
    3130:	4798      	blx	r3
}
    3132:	b00d      	add	sp, #52	; 0x34
    3134:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    3138:	2100      	movs	r1, #0
    313a:	e7e7      	b.n	310c <dhcp_recv+0x7c>
	if (ntohl(reply_msg->xid) != dhcp->xid) {
    313c:	6868      	ldr	r0, [r5, #4]
    313e:	4b41      	ldr	r3, [pc, #260]	; (3244 <dhcp_recv+0x1b4>)
    3140:	4798      	blx	r3
    3142:	9c04      	ldr	r4, [sp, #16]
    3144:	6823      	ldr	r3, [r4, #0]
    3146:	4298      	cmp	r0, r3
    3148:	d008      	beq.n	315c <dhcp_recv+0xcc>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    314a:	6868      	ldr	r0, [r5, #4]
    314c:	4b3d      	ldr	r3, [pc, #244]	; (3244 <dhcp_recv+0x1b4>)
    314e:	4798      	blx	r3
    3150:	6822      	ldr	r2, [r4, #0]
    3152:	4601      	mov	r1, r0
    3154:	483c      	ldr	r0, [pc, #240]	; (3248 <dhcp_recv+0x1b8>)
    3156:	4b33      	ldr	r3, [pc, #204]	; (3224 <dhcp_recv+0x194>)
    3158:	4798      	blx	r3
		goto free_pbuf_and_return;
    315a:	e7e4      	b.n	3126 <dhcp_recv+0x96>
	dhcp_clear_all_options(dhcp);
    315c:	4b3b      	ldr	r3, [pc, #236]	; (324c <dhcp_recv+0x1bc>)
    315e:	2200      	movs	r2, #0
    3160:	601a      	str	r2, [r3, #0]
    3162:	605a      	str	r2, [r3, #4]
    3164:	811a      	strh	r2, [r3, #8]
	if (p->len < DHCP_SNAME_OFS) {
    3166:	f8bb 300a 	ldrh.w	r3, [fp, #10]
    316a:	2b2b      	cmp	r3, #43	; 0x2b
    316c:	f240 8259 	bls.w	3622 <dhcp_recv+0x592>
	dhcp->msg_in = (struct dhcp_msg *)p->payload;
    3170:	f8db 3004 	ldr.w	r3, [fp, #4]
    3174:	9a04      	ldr	r2, [sp, #16]
    3176:	6093      	str	r3, [r2, #8]
	options_idx_max = p->tot_len;
    3178:	f8bb a008 	ldrh.w	sl, [fp, #8]
	int          parse_sname_as_options = 0;
    317c:	2300      	movs	r3, #0
    317e:	9306      	str	r3, [sp, #24]
	options_idx = DHCP_OPTIONS_OFS;
    3180:	24f0      	movs	r4, #240	; 0xf0
    3182:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
    3186:	f8cd b014 	str.w	fp, [sp, #20]
	while ((q != NULL) && (options_idx >= q->len)) {
    318a:	9a05      	ldr	r2, [sp, #20]
    318c:	2a00      	cmp	r2, #0
    318e:	f000 8243 	beq.w	3618 <dhcp_recv+0x588>
    3192:	8953      	ldrh	r3, [r2, #10]
    3194:	429c      	cmp	r4, r3
    3196:	f0c0 82fd 	bcc.w	3794 <dhcp_recv+0x704>
		options_idx -= q->len;
    319a:	1ae4      	subs	r4, r4, r3
    319c:	b2a4      	uxth	r4, r4
		options_idx_max -= q->len;
    319e:	ebaa 0a03 	sub.w	sl, sl, r3
    31a2:	fa1f fa8a 	uxth.w	sl, sl
		q = q->next;
    31a6:	6812      	ldr	r2, [r2, #0]
	while ((q != NULL) && (options_idx >= q->len)) {
    31a8:	2a00      	cmp	r2, #0
    31aa:	f000 8238 	beq.w	361e <dhcp_recv+0x58e>
    31ae:	8953      	ldrh	r3, [r2, #10]
    31b0:	42a3      	cmp	r3, r4
    31b2:	d9f2      	bls.n	319a <dhcp_recv+0x10a>
    31b4:	4693      	mov	fp, r2
	options    = (u8_t *)q->payload;
    31b6:	f8db 3004 	ldr.w	r3, [fp, #4]
    31ba:	9307      	str	r3, [sp, #28]
	while ((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    31bc:	4622      	mov	r2, r4
    31be:	5d1b      	ldrb	r3, [r3, r4]
    31c0:	2bff      	cmp	r3, #255	; 0xff
    31c2:	d002      	beq.n	31ca <dhcp_recv+0x13a>
    31c4:	45a2      	cmp	sl, r4
    31c6:	f200 80a3 	bhi.w	3310 <dhcp_recv+0x280>
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
    31ca:	4b20      	ldr	r3, [pc, #128]	; (324c <dhcp_recv+0x1bc>)
    31cc:	781b      	ldrb	r3, [r3, #0]
    31ce:	2b00      	cmp	r3, #0
    31d0:	f000 8210 	beq.w	35f4 <dhcp_recv+0x564>
		u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    31d4:	4b1e      	ldr	r3, [pc, #120]	; (3250 <dhcp_recv+0x1c0>)
    31d6:	6819      	ldr	r1, [r3, #0]
		dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    31d8:	2200      	movs	r2, #0
    31da:	4b1c      	ldr	r3, [pc, #112]	; (324c <dhcp_recv+0x1bc>)
    31dc:	701a      	strb	r2, [r3, #0]
		if (overload == DHCP_OVERLOAD_FILE) {
    31de:	2901      	cmp	r1, #1
    31e0:	f040 81f2 	bne.w	35c8 <dhcp_recv+0x538>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    31e4:	481b      	ldr	r0, [pc, #108]	; (3254 <dhcp_recv+0x1c4>)
    31e6:	4b14      	ldr	r3, [pc, #80]	; (3238 <dhcp_recv+0x1a8>)
    31e8:	4798      	blx	r3
		options_idx_max       = DHCP_FILE_OFS + DHCP_FILE_LEN;
    31ea:	f04f 0aec 	mov.w	sl, #236	; 0xec
		options_idx           = DHCP_FILE_OFS;
    31ee:	246c      	movs	r4, #108	; 0x6c
    31f0:	e7cb      	b.n	318a <dhcp_recv+0xfa>
		parse_sname_as_options = 0;
    31f2:	2300      	movs	r3, #0
    31f4:	9306      	str	r3, [sp, #24]
		options_idx_max        = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
    31f6:	f04f 0a6c 	mov.w	sl, #108	; 0x6c
		options_idx            = DHCP_SNAME_OFS;
    31fa:	242c      	movs	r4, #44	; 0x2c
    31fc:	e7c5      	b.n	318a <dhcp_recv+0xfa>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    31fe:	f8db 2000 	ldr.w	r2, [fp]
    3202:	2a00      	cmp	r2, #0
    3204:	f000 830c 	beq.w	3820 <dhcp_recv+0x790>
    3208:	6852      	ldr	r2, [r2, #4]
    320a:	7817      	ldrb	r7, [r2, #0]
    320c:	e089      	b.n	3322 <dhcp_recv+0x292>
			offset--;
    320e:	3c01      	subs	r4, #1
    3210:	b2a4      	uxth	r4, r4
			decode_len = len = 0;
    3212:	2700      	movs	r7, #0
    3214:	3402      	adds	r4, #2
		offset += len + 2;
    3216:	fa17 f484 	uxtah	r4, r7, r4
    321a:	b2a4      	uxth	r4, r4
    321c:	e055      	b.n	32ca <dhcp_recv+0x23a>
    321e:	bf00      	nop
    3220:	0000b048 	.word	0x0000b048
    3224:	00009815 	.word	0x00009815
    3228:	0000b088 	.word	0x0000b088
    322c:	0000b09c 	.word	0x0000b09c
    3230:	0000b104 	.word	0x0000b104
    3234:	0000b0b4 	.word	0x0000b0b4
    3238:	000098fd 	.word	0x000098fd
    323c:	0000b0dc 	.word	0x0000b0dc
    3240:	000054c9 	.word	0x000054c9
    3244:	00002711 	.word	0x00002711
    3248:	0000b140 	.word	0x0000b140
    324c:	200082d8 	.word	0x200082d8
    3250:	200082e4 	.word	0x200082e4
    3254:	0000b200 	.word	0x0000b200
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3258:	2f04      	cmp	r7, #4
    325a:	f040 80e1 	bne.w	3420 <dhcp_recv+0x390>
		decode_len = len;
    325e:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
    3260:	2606      	movs	r6, #6
    3262:	1ca3      	adds	r3, r4, #2
		offset += len + 2;
    3264:	fa17 f783 	uxtah	r7, r7, r3
    3268:	b2bb      	uxth	r3, r7
    326a:	9308      	str	r3, [sp, #32]
			u32_t value = 0;
    326c:	2300      	movs	r3, #0
    326e:	930b      	str	r3, [sp, #44]	; 0x2c
			if (!dhcp_option_given(dhcp, decode_idx)) {
    3270:	4bb9      	ldr	r3, [pc, #740]	; (3558 <dhcp_recv+0x4c8>)
    3272:	5d9b      	ldrb	r3, [r3, r6]
    3274:	bb43      	cbnz	r3, 32c8 <dhcp_recv+0x238>
		u16_t val_offset = offset + 2;
    3276:	3402      	adds	r4, #2
    3278:	b2a4      	uxth	r4, r4
    327a:	4fb7      	ldr	r7, [pc, #732]	; (3558 <dhcp_recv+0x4c8>)
    327c:	4437      	add	r7, r6
    327e:	4bb7      	ldr	r3, [pc, #732]	; (355c <dhcp_recv+0x4cc>)
    3280:	eb03 0886 	add.w	r8, r3, r6, lsl #2
				pbuf_copy_partial(q, &value, copy_len, val_offset);
    3284:	f8df 9300 	ldr.w	r9, [pc, #768]	; 3588 <dhcp_recv+0x4f8>
				copy_len = LWIP_MIN(decode_len, 4);
    3288:	2d03      	cmp	r5, #3
    328a:	bf94      	ite	ls
    328c:	462a      	movls	r2, r5
    328e:	2204      	movhi	r2, #4
				pbuf_copy_partial(q, &value, copy_len, val_offset);
    3290:	4623      	mov	r3, r4
    3292:	b292      	uxth	r2, r2
    3294:	a90b      	add	r1, sp, #44	; 0x2c
    3296:	4658      	mov	r0, fp
    3298:	47c8      	blx	r9
				if (decode_len > 4) {
    329a:	2d04      	cmp	r5, #4
    329c:	f240 8176 	bls.w	358c <dhcp_recv+0x4fc>
					LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
    32a0:	f015 0f03 	tst.w	r5, #3
    32a4:	f040 8150 	bne.w	3548 <dhcp_recv+0x4b8>
					dhcp_got_option(dhcp, decode_idx);
    32a8:	2301      	movs	r3, #1
    32aa:	703b      	strb	r3, [r7, #0]
					dhcp_set_option_value(dhcp, decode_idx, htonl(value));
    32ac:	980b      	ldr	r0, [sp, #44]	; 0x2c
    32ae:	4bac      	ldr	r3, [pc, #688]	; (3560 <dhcp_recv+0x4d0>)
    32b0:	4798      	blx	r3
    32b2:	f848 0f04 	str.w	r0, [r8, #4]!
					decode_len -= 4;
    32b6:	3d04      	subs	r5, #4
    32b8:	b2ed      	uxtb	r5, r5
					val_offset += 4;
    32ba:	3404      	adds	r4, #4
    32bc:	b2a4      	uxth	r4, r4
					decode_idx++;
    32be:	3601      	adds	r6, #1
			if (!dhcp_option_given(dhcp, decode_idx)) {
    32c0:	f817 3f01 	ldrb.w	r3, [r7, #1]!
    32c4:	2b00      	cmp	r3, #0
    32c6:	d0df      	beq.n	3288 <dhcp_recv+0x1f8>
    32c8:	9c08      	ldr	r4, [sp, #32]
		if (offset >= q->len) {
    32ca:	f8bb 300a 	ldrh.w	r3, [fp, #10]
    32ce:	42a3      	cmp	r3, r4
    32d0:	d811      	bhi.n	32f6 <dhcp_recv+0x266>
			offset -= q->len;
    32d2:	1ae4      	subs	r4, r4, r3
    32d4:	b2a4      	uxth	r4, r4
			offset_max -= q->len;
    32d6:	ebaa 0a03 	sub.w	sl, sl, r3
    32da:	fa1f fa8a 	uxth.w	sl, sl
			if ((offset < offset_max) && offset_max) {
    32de:	4554      	cmp	r4, sl
    32e0:	f4bf af73 	bcs.w	31ca <dhcp_recv+0x13a>
    32e4:	f1ba 0f00 	cmp.w	sl, #0
    32e8:	f43f af6f 	beq.w	31ca <dhcp_recv+0x13a>
				q = q->next;
    32ec:	f8db b000 	ldr.w	fp, [fp]
				options = (u8_t *)q->payload;
    32f0:	f8db 3004 	ldr.w	r3, [fp, #4]
    32f4:	9307      	str	r3, [sp, #28]
	while ((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    32f6:	f1bb 0f00 	cmp.w	fp, #0
    32fa:	f43f af66 	beq.w	31ca <dhcp_recv+0x13a>
    32fe:	4622      	mov	r2, r4
    3300:	9b07      	ldr	r3, [sp, #28]
    3302:	5d1b      	ldrb	r3, [r3, r4]
    3304:	2bff      	cmp	r3, #255	; 0xff
    3306:	f43f af60 	beq.w	31ca <dhcp_recv+0x13a>
    330a:	45a2      	cmp	sl, r4
    330c:	f67f af5d 	bls.w	31ca <dhcp_recv+0x13a>
		if (offset + 1 < q->len) {
    3310:	1c61      	adds	r1, r4, #1
    3312:	f8bb 000a 	ldrh.w	r0, [fp, #10]
    3316:	4281      	cmp	r1, r0
    3318:	f6bf af71 	bge.w	31fe <dhcp_recv+0x16e>
			len = options[offset + 1];
    331c:	9907      	ldr	r1, [sp, #28]
    331e:	440a      	add	r2, r1
    3320:	7857      	ldrb	r7, [r2, #1]
		switch (op) {
    3322:	2b3b      	cmp	r3, #59	; 0x3b
    3324:	f200 810b 	bhi.w	353e <dhcp_recv+0x4ae>
    3328:	a201      	add	r2, pc, #4	; (adr r2, 3330 <dhcp_recv+0x2a0>)
    332a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    332e:	bf00      	nop
    3330:	0000320f 	.word	0x0000320f
    3334:	00003259 	.word	0x00003259
    3338:	0000353f 	.word	0x0000353f
    333c:	00003433 	.word	0x00003433
    3340:	0000353f 	.word	0x0000353f
    3344:	0000353f 	.word	0x0000353f
    3348:	0000344f 	.word	0x0000344f
    334c:	0000353f 	.word	0x0000353f
    3350:	0000353f 	.word	0x0000353f
    3354:	0000353f 	.word	0x0000353f
    3358:	0000353f 	.word	0x0000353f
    335c:	0000353f 	.word	0x0000353f
    3360:	0000353f 	.word	0x0000353f
    3364:	0000353f 	.word	0x0000353f
    3368:	0000353f 	.word	0x0000353f
    336c:	0000353f 	.word	0x0000353f
    3370:	0000353f 	.word	0x0000353f
    3374:	0000353f 	.word	0x0000353f
    3378:	0000353f 	.word	0x0000353f
    337c:	0000353f 	.word	0x0000353f
    3380:	0000353f 	.word	0x0000353f
    3384:	0000353f 	.word	0x0000353f
    3388:	0000353f 	.word	0x0000353f
    338c:	0000353f 	.word	0x0000353f
    3390:	0000353f 	.word	0x0000353f
    3394:	0000353f 	.word	0x0000353f
    3398:	0000353f 	.word	0x0000353f
    339c:	0000353f 	.word	0x0000353f
    33a0:	0000353f 	.word	0x0000353f
    33a4:	0000353f 	.word	0x0000353f
    33a8:	0000353f 	.word	0x0000353f
    33ac:	0000353f 	.word	0x0000353f
    33b0:	0000353f 	.word	0x0000353f
    33b4:	0000353f 	.word	0x0000353f
    33b8:	0000353f 	.word	0x0000353f
    33bc:	0000353f 	.word	0x0000353f
    33c0:	0000353f 	.word	0x0000353f
    33c4:	0000353f 	.word	0x0000353f
    33c8:	0000353f 	.word	0x0000353f
    33cc:	0000353f 	.word	0x0000353f
    33d0:	0000353f 	.word	0x0000353f
    33d4:	0000353f 	.word	0x0000353f
    33d8:	0000353f 	.word	0x0000353f
    33dc:	0000353f 	.word	0x0000353f
    33e0:	0000353f 	.word	0x0000353f
    33e4:	0000353f 	.word	0x0000353f
    33e8:	0000353f 	.word	0x0000353f
    33ec:	0000353f 	.word	0x0000353f
    33f0:	0000353f 	.word	0x0000353f
    33f4:	0000353f 	.word	0x0000353f
    33f8:	0000353f 	.word	0x0000353f
    33fc:	00003497 	.word	0x00003497
    3400:	000034b3 	.word	0x000034b3
    3404:	000034cf 	.word	0x000034cf
    3408:	000034eb 	.word	0x000034eb
    340c:	0000353f 	.word	0x0000353f
    3410:	0000353f 	.word	0x0000353f
    3414:	0000353f 	.word	0x0000353f
    3418:	00003507 	.word	0x00003507
    341c:	00003523 	.word	0x00003523
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3420:	4b50      	ldr	r3, [pc, #320]	; (3564 <dhcp_recv+0x4d4>)
    3422:	f240 527c 	movw	r2, #1404	; 0x57c
    3426:	4950      	ldr	r1, [pc, #320]	; (3568 <dhcp_recv+0x4d8>)
    3428:	4850      	ldr	r0, [pc, #320]	; (356c <dhcp_recv+0x4dc>)
    342a:	4c51      	ldr	r4, [pc, #324]	; (3570 <dhcp_recv+0x4e0>)
    342c:	47a0      	blx	r4
    342e:	e7fe      	b.n	342e <dhcp_recv+0x39e>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3430:	2700      	movs	r7, #0
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    3432:	2f03      	cmp	r7, #3
    3434:	d902      	bls.n	343c <dhcp_recv+0x3ac>
			decode_idx = DHCP_OPTION_IDX_ROUTER;
    3436:	2607      	movs	r6, #7
			decode_len = 4; /* only copy the first given router */
    3438:	2504      	movs	r5, #4
    343a:	e712      	b.n	3262 <dhcp_recv+0x1d2>
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    343c:	4b49      	ldr	r3, [pc, #292]	; (3564 <dhcp_recv+0x4d4>)
    343e:	f240 5281 	movw	r2, #1409	; 0x581
    3442:	494c      	ldr	r1, [pc, #304]	; (3574 <dhcp_recv+0x4e4>)
    3444:	4849      	ldr	r0, [pc, #292]	; (356c <dhcp_recv+0x4dc>)
    3446:	4c4a      	ldr	r4, [pc, #296]	; (3570 <dhcp_recv+0x4e0>)
    3448:	47a0      	blx	r4
    344a:	e7fe      	b.n	344a <dhcp_recv+0x3ba>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    344c:	2700      	movs	r7, #0
			LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
    344e:	f017 0f03 	tst.w	r7, #3
    3452:	d10f      	bne.n	3474 <dhcp_recv+0x3e4>
			decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
    3454:	463d      	mov	r5, r7
    3456:	2f08      	cmp	r7, #8
    3458:	bf28      	it	cs
    345a:	2508      	movcs	r5, #8
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    345c:	42bd      	cmp	r5, r7
    345e:	d811      	bhi.n	3484 <dhcp_recv+0x3f4>
    3460:	1ca3      	adds	r3, r4, #2
		offset += len + 2;
    3462:	fa17 f783 	uxtah	r7, r7, r3
    3466:	b2bb      	uxth	r3, r7
    3468:	9308      	str	r3, [sp, #32]
		if (decode_len > 0) {
    346a:	2d00      	cmp	r5, #0
    346c:	f000 80aa 	beq.w	35c4 <dhcp_recv+0x534>
			decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
    3470:	2608      	movs	r6, #8
    3472:	e6fb      	b.n	326c <dhcp_recv+0x1dc>
			LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
    3474:	4b3b      	ldr	r3, [pc, #236]	; (3564 <dhcp_recv+0x4d4>)
    3476:	f240 5286 	movw	r2, #1414	; 0x586
    347a:	493f      	ldr	r1, [pc, #252]	; (3578 <dhcp_recv+0x4e8>)
    347c:	483b      	ldr	r0, [pc, #236]	; (356c <dhcp_recv+0x4dc>)
    347e:	4c3c      	ldr	r4, [pc, #240]	; (3570 <dhcp_recv+0x4e0>)
    3480:	47a0      	blx	r4
    3482:	e7fe      	b.n	3482 <dhcp_recv+0x3f2>
			LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    3484:	4b37      	ldr	r3, [pc, #220]	; (3564 <dhcp_recv+0x4d4>)
    3486:	f240 5289 	movw	r2, #1417	; 0x589
    348a:	493a      	ldr	r1, [pc, #232]	; (3574 <dhcp_recv+0x4e4>)
    348c:	4837      	ldr	r0, [pc, #220]	; (356c <dhcp_recv+0x4dc>)
    348e:	4c38      	ldr	r4, [pc, #224]	; (3570 <dhcp_recv+0x4e0>)
    3490:	47a0      	blx	r4
    3492:	e7fe      	b.n	3492 <dhcp_recv+0x402>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3494:	2700      	movs	r7, #0
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3496:	2f04      	cmp	r7, #4
    3498:	d102      	bne.n	34a0 <dhcp_recv+0x410>
		decode_len = len;
    349a:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
    349c:	2603      	movs	r6, #3
    349e:	e6e0      	b.n	3262 <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    34a0:	4b30      	ldr	r3, [pc, #192]	; (3564 <dhcp_recv+0x4d4>)
    34a2:	f240 528d 	movw	r2, #1421	; 0x58d
    34a6:	4930      	ldr	r1, [pc, #192]	; (3568 <dhcp_recv+0x4d8>)
    34a8:	4830      	ldr	r0, [pc, #192]	; (356c <dhcp_recv+0x4dc>)
    34aa:	4c31      	ldr	r4, [pc, #196]	; (3570 <dhcp_recv+0x4e0>)
    34ac:	47a0      	blx	r4
    34ae:	e7fe      	b.n	34ae <dhcp_recv+0x41e>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    34b0:	2700      	movs	r7, #0
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    34b2:	2f01      	cmp	r7, #1
    34b4:	d102      	bne.n	34bc <dhcp_recv+0x42c>
		decode_len = len;
    34b6:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_OVERLOAD;
    34b8:	2600      	movs	r6, #0
    34ba:	e6d2      	b.n	3262 <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    34bc:	4b29      	ldr	r3, [pc, #164]	; (3564 <dhcp_recv+0x4d4>)
    34be:	f240 5291 	movw	r2, #1425	; 0x591
    34c2:	492e      	ldr	r1, [pc, #184]	; (357c <dhcp_recv+0x4ec>)
    34c4:	4829      	ldr	r0, [pc, #164]	; (356c <dhcp_recv+0x4dc>)
    34c6:	4c2a      	ldr	r4, [pc, #168]	; (3570 <dhcp_recv+0x4e0>)
    34c8:	47a0      	blx	r4
    34ca:	e7fe      	b.n	34ca <dhcp_recv+0x43a>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    34cc:	2700      	movs	r7, #0
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    34ce:	2f01      	cmp	r7, #1
    34d0:	d102      	bne.n	34d8 <dhcp_recv+0x448>
		decode_len = len;
    34d2:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
    34d4:	2601      	movs	r6, #1
    34d6:	e6c4      	b.n	3262 <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    34d8:	4b22      	ldr	r3, [pc, #136]	; (3564 <dhcp_recv+0x4d4>)
    34da:	f240 5295 	movw	r2, #1429	; 0x595
    34de:	4927      	ldr	r1, [pc, #156]	; (357c <dhcp_recv+0x4ec>)
    34e0:	4822      	ldr	r0, [pc, #136]	; (356c <dhcp_recv+0x4dc>)
    34e2:	4c23      	ldr	r4, [pc, #140]	; (3570 <dhcp_recv+0x4e0>)
    34e4:	47a0      	blx	r4
    34e6:	e7fe      	b.n	34e6 <dhcp_recv+0x456>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    34e8:	2700      	movs	r7, #0
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    34ea:	2f04      	cmp	r7, #4
    34ec:	d102      	bne.n	34f4 <dhcp_recv+0x464>
		decode_len = len;
    34ee:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_SERVER_ID;
    34f0:	2602      	movs	r6, #2
    34f2:	e6b6      	b.n	3262 <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    34f4:	4b1b      	ldr	r3, [pc, #108]	; (3564 <dhcp_recv+0x4d4>)
    34f6:	f240 5299 	movw	r2, #1433	; 0x599
    34fa:	491b      	ldr	r1, [pc, #108]	; (3568 <dhcp_recv+0x4d8>)
    34fc:	481b      	ldr	r0, [pc, #108]	; (356c <dhcp_recv+0x4dc>)
    34fe:	4c1c      	ldr	r4, [pc, #112]	; (3570 <dhcp_recv+0x4e0>)
    3500:	47a0      	blx	r4
    3502:	e7fe      	b.n	3502 <dhcp_recv+0x472>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3504:	2700      	movs	r7, #0
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3506:	2f04      	cmp	r7, #4
    3508:	d102      	bne.n	3510 <dhcp_recv+0x480>
		decode_len = len;
    350a:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_T1;
    350c:	2604      	movs	r6, #4
    350e:	e6a8      	b.n	3262 <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3510:	4b14      	ldr	r3, [pc, #80]	; (3564 <dhcp_recv+0x4d4>)
    3512:	f240 529d 	movw	r2, #1437	; 0x59d
    3516:	4914      	ldr	r1, [pc, #80]	; (3568 <dhcp_recv+0x4d8>)
    3518:	4814      	ldr	r0, [pc, #80]	; (356c <dhcp_recv+0x4dc>)
    351a:	4c15      	ldr	r4, [pc, #84]	; (3570 <dhcp_recv+0x4e0>)
    351c:	47a0      	blx	r4
    351e:	e7fe      	b.n	351e <dhcp_recv+0x48e>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    3520:	2700      	movs	r7, #0
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    3522:	2f04      	cmp	r7, #4
    3524:	d102      	bne.n	352c <dhcp_recv+0x49c>
		decode_len = len;
    3526:	463d      	mov	r5, r7
			decode_idx = DHCP_OPTION_IDX_T2;
    3528:	2605      	movs	r6, #5
    352a:	e69a      	b.n	3262 <dhcp_recv+0x1d2>
			LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    352c:	4b0d      	ldr	r3, [pc, #52]	; (3564 <dhcp_recv+0x4d4>)
    352e:	f240 52a1 	movw	r2, #1441	; 0x5a1
    3532:	490d      	ldr	r1, [pc, #52]	; (3568 <dhcp_recv+0x4d8>)
    3534:	480d      	ldr	r0, [pc, #52]	; (356c <dhcp_recv+0x4dc>)
    3536:	4c0e      	ldr	r4, [pc, #56]	; (3570 <dhcp_recv+0x4e0>)
    3538:	47a0      	blx	r4
    353a:	e7fe      	b.n	353a <dhcp_recv+0x4aa>
			len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
    353c:	2700      	movs	r7, #0
			LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %" U16_F " in options\n", op));
    353e:	4619      	mov	r1, r3
    3540:	480f      	ldr	r0, [pc, #60]	; (3580 <dhcp_recv+0x4f0>)
    3542:	4b0b      	ldr	r3, [pc, #44]	; (3570 <dhcp_recv+0x4e0>)
    3544:	4798      	blx	r3
    3546:	e665      	b.n	3214 <dhcp_recv+0x184>
					LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
    3548:	4b06      	ldr	r3, [pc, #24]	; (3564 <dhcp_recv+0x4d4>)
    354a:	f240 52b4 	movw	r2, #1460	; 0x5b4
    354e:	490d      	ldr	r1, [pc, #52]	; (3584 <dhcp_recv+0x4f4>)
    3550:	4806      	ldr	r0, [pc, #24]	; (356c <dhcp_recv+0x4dc>)
    3552:	4c07      	ldr	r4, [pc, #28]	; (3570 <dhcp_recv+0x4e0>)
    3554:	47a0      	blx	r4
    3556:	e7fe      	b.n	3556 <dhcp_recv+0x4c6>
    3558:	200082d8 	.word	0x200082d8
    355c:	200082e0 	.word	0x200082e0
    3560:	000026f9 	.word	0x000026f9
    3564:	0000aac4 	.word	0x0000aac4
    3568:	0000b17c 	.word	0x0000b17c
    356c:	0000ab0c 	.word	0x0000ab0c
    3570:	00009815 	.word	0x00009815
    3574:	0000b188 	.word	0x0000b188
    3578:	0000b19c 	.word	0x0000b19c
    357c:	0000b1ac 	.word	0x0000b1ac
    3580:	0000b1b8 	.word	0x0000b1b8
    3584:	0000b1d8 	.word	0x0000b1d8
    3588:	00005855 	.word	0x00005855
				} else if (decode_len == 4) {
    358c:	2d04      	cmp	r5, #4
    358e:	d00c      	beq.n	35aa <dhcp_recv+0x51a>
					LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
    3590:	2d01      	cmp	r5, #1
    3592:	d10f      	bne.n	35b4 <dhcp_recv+0x524>
					value = ((u8_t *)&value)[0];
    3594:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    3598:	930b      	str	r3, [sp, #44]	; 0x2c
				dhcp_got_option(dhcp, decode_idx);
    359a:	2201      	movs	r2, #1
    359c:	4b7f      	ldr	r3, [pc, #508]	; (379c <dhcp_recv+0x70c>)
    359e:	559a      	strb	r2, [r3, r6]
				dhcp_set_option_value(dhcp, decode_idx, value);
    35a0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    35a2:	4b7f      	ldr	r3, [pc, #508]	; (37a0 <dhcp_recv+0x710>)
    35a4:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
    35a8:	e68e      	b.n	32c8 <dhcp_recv+0x238>
					value = ntohl(value);
    35aa:	980b      	ldr	r0, [sp, #44]	; 0x2c
    35ac:	4b7d      	ldr	r3, [pc, #500]	; (37a4 <dhcp_recv+0x714>)
    35ae:	4798      	blx	r3
    35b0:	900b      	str	r0, [sp, #44]	; 0x2c
    35b2:	e7f2      	b.n	359a <dhcp_recv+0x50a>
					LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
    35b4:	4b7c      	ldr	r3, [pc, #496]	; (37a8 <dhcp_recv+0x718>)
    35b6:	f240 52be 	movw	r2, #1470	; 0x5be
    35ba:	497c      	ldr	r1, [pc, #496]	; (37ac <dhcp_recv+0x71c>)
    35bc:	487c      	ldr	r0, [pc, #496]	; (37b0 <dhcp_recv+0x720>)
    35be:	4c7d      	ldr	r4, [pc, #500]	; (37b4 <dhcp_recv+0x724>)
    35c0:	47a0      	blx	r4
    35c2:	e7fe      	b.n	35c2 <dhcp_recv+0x532>
		offset += len + 2;
    35c4:	9c08      	ldr	r4, [sp, #32]
    35c6:	e680      	b.n	32ca <dhcp_recv+0x23a>
		} else if (overload == DHCP_OVERLOAD_SNAME) {
    35c8:	2902      	cmp	r1, #2
    35ca:	d108      	bne.n	35de <dhcp_recv+0x54e>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    35cc:	487a      	ldr	r0, [pc, #488]	; (37b8 <dhcp_recv+0x728>)
    35ce:	4b7b      	ldr	r3, [pc, #492]	; (37bc <dhcp_recv+0x72c>)
    35d0:	4798      	blx	r3
		parse_sname_as_options = 0;
    35d2:	2300      	movs	r3, #0
    35d4:	9306      	str	r3, [sp, #24]
		options_idx_max        = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
    35d6:	f04f 0a6c 	mov.w	sl, #108	; 0x6c
		options_idx            = DHCP_SNAME_OFS;
    35da:	242c      	movs	r4, #44	; 0x2c
    35dc:	e5d5      	b.n	318a <dhcp_recv+0xfa>
		} else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
    35de:	2903      	cmp	r1, #3
    35e0:	d105      	bne.n	35ee <dhcp_recv+0x55e>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname and file field\n"));
    35e2:	4877      	ldr	r0, [pc, #476]	; (37c0 <dhcp_recv+0x730>)
    35e4:	4b75      	ldr	r3, [pc, #468]	; (37bc <dhcp_recv+0x72c>)
    35e6:	4798      	blx	r3
			parse_sname_as_options = 1;
    35e8:	2301      	movs	r3, #1
    35ea:	9306      	str	r3, [sp, #24]
    35ec:	e5fd      	b.n	31ea <dhcp_recv+0x15a>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("invalid overload option: %d\n", (int)overload));
    35ee:	4875      	ldr	r0, [pc, #468]	; (37c4 <dhcp_recv+0x734>)
    35f0:	4b70      	ldr	r3, [pc, #448]	; (37b4 <dhcp_recv+0x724>)
    35f2:	4798      	blx	r3
	} else if (parse_sname_as_options) {
    35f4:	9b06      	ldr	r3, [sp, #24]
    35f6:	2b00      	cmp	r3, #0
    35f8:	f47f adfb 	bne.w	31f2 <dhcp_recv+0x162>
    35fc:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    3600:	f8dd b014 	ldr.w	fp, [sp, #20]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
    3604:	4870      	ldr	r0, [pc, #448]	; (37c8 <dhcp_recv+0x738>)
    3606:	4b6d      	ldr	r3, [pc, #436]	; (37bc <dhcp_recv+0x72c>)
    3608:	4798      	blx	r3
	if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    360a:	4b64      	ldr	r3, [pc, #400]	; (379c <dhcp_recv+0x70c>)
    360c:	785b      	ldrb	r3, [r3, #1]
    360e:	b963      	cbnz	r3, 362a <dhcp_recv+0x59a>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
    3610:	486e      	ldr	r0, [pc, #440]	; (37cc <dhcp_recv+0x73c>)
    3612:	4b6a      	ldr	r3, [pc, #424]	; (37bc <dhcp_recv+0x72c>)
    3614:	4798      	blx	r3
		goto free_pbuf_and_return;
    3616:	e586      	b.n	3126 <dhcp_recv+0x96>
    3618:	f8dd b014 	ldr.w	fp, [sp, #20]
    361c:	e001      	b.n	3622 <dhcp_recv+0x592>
    361e:	f8dd b014 	ldr.w	fp, [sp, #20]
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    3622:	486b      	ldr	r0, [pc, #428]	; (37d0 <dhcp_recv+0x740>)
    3624:	4b65      	ldr	r3, [pc, #404]	; (37bc <dhcp_recv+0x72c>)
    3626:	4798      	blx	r3
		goto free_pbuf_and_return;
    3628:	e57d      	b.n	3126 <dhcp_recv+0x96>
	msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
    362a:	4b5d      	ldr	r3, [pc, #372]	; (37a0 <dhcp_recv+0x710>)
    362c:	791b      	ldrb	r3, [r3, #4]
	if (msg_type == DHCP_ACK) {
    362e:	2b05      	cmp	r3, #5
    3630:	d149      	bne.n	36c6 <dhcp_recv+0x636>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    3632:	4868      	ldr	r0, [pc, #416]	; (37d4 <dhcp_recv+0x744>)
    3634:	4b61      	ldr	r3, [pc, #388]	; (37bc <dhcp_recv+0x72c>)
    3636:	4798      	blx	r3
		if (dhcp->state == DHCP_REQUESTING) {
    3638:	9b04      	ldr	r3, [sp, #16]
    363a:	7b1b      	ldrb	r3, [r3, #12]
    363c:	2b01      	cmp	r3, #1
    363e:	d139      	bne.n	36b4 <dhcp_recv+0x624>
	struct dhcp *dhcp = netif->dhcp;
    3640:	f8d9 4028 	ldr.w	r4, [r9, #40]	; 0x28
	ip_addr_set_zero(&dhcp->offered_sn_mask);
    3644:	2300      	movs	r3, #0
    3646:	62a3      	str	r3, [r4, #40]	; 0x28
	ip_addr_set_zero(&dhcp->offered_gw_addr);
    3648:	62e3      	str	r3, [r4, #44]	; 0x2c
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
    364a:	4b54      	ldr	r3, [pc, #336]	; (379c <dhcp_recv+0x70c>)
    364c:	78db      	ldrb	r3, [r3, #3]
    364e:	b113      	cbz	r3, 3656 <dhcp_recv+0x5c6>
		dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
    3650:	4b53      	ldr	r3, [pc, #332]	; (37a0 <dhcp_recv+0x710>)
    3652:	68db      	ldr	r3, [r3, #12]
    3654:	6323      	str	r3, [r4, #48]	; 0x30
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
    3656:	4b51      	ldr	r3, [pc, #324]	; (379c <dhcp_recv+0x70c>)
    3658:	791b      	ldrb	r3, [r3, #4]
    365a:	b30b      	cbz	r3, 36a0 <dhcp_recv+0x610>
		dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
    365c:	4b50      	ldr	r3, [pc, #320]	; (37a0 <dhcp_recv+0x710>)
    365e:	691b      	ldr	r3, [r3, #16]
    3660:	6363      	str	r3, [r4, #52]	; 0x34
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
    3662:	4b4e      	ldr	r3, [pc, #312]	; (379c <dhcp_recv+0x70c>)
    3664:	795b      	ldrb	r3, [r3, #5]
    3666:	b1fb      	cbz	r3, 36a8 <dhcp_recv+0x618>
		dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
    3668:	4b4d      	ldr	r3, [pc, #308]	; (37a0 <dhcp_recv+0x710>)
    366a:	695b      	ldr	r3, [r3, #20]
    366c:	63a3      	str	r3, [r4, #56]	; 0x38
	ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    366e:	68a3      	ldr	r3, [r4, #8]
    3670:	691b      	ldr	r3, [r3, #16]
    3672:	6263      	str	r3, [r4, #36]	; 0x24
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
    3674:	4b49      	ldr	r3, [pc, #292]	; (379c <dhcp_recv+0x70c>)
    3676:	799b      	ldrb	r3, [r3, #6]
    3678:	b1cb      	cbz	r3, 36ae <dhcp_recv+0x61e>
		ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
    367a:	4b49      	ldr	r3, [pc, #292]	; (37a0 <dhcp_recv+0x710>)
    367c:	6998      	ldr	r0, [r3, #24]
    367e:	4b56      	ldr	r3, [pc, #344]	; (37d8 <dhcp_recv+0x748>)
    3680:	4798      	blx	r3
    3682:	62a0      	str	r0, [r4, #40]	; 0x28
		dhcp->subnet_mask_given = 1;
    3684:	2301      	movs	r3, #1
    3686:	73a3      	strb	r3, [r4, #14]
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
    3688:	4b44      	ldr	r3, [pc, #272]	; (379c <dhcp_recv+0x70c>)
    368a:	79db      	ldrb	r3, [r3, #7]
    368c:	b123      	cbz	r3, 3698 <dhcp_recv+0x608>
		ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
    368e:	4b44      	ldr	r3, [pc, #272]	; (37a0 <dhcp_recv+0x710>)
    3690:	69d8      	ldr	r0, [r3, #28]
    3692:	4b51      	ldr	r3, [pc, #324]	; (37d8 <dhcp_recv+0x748>)
    3694:	4798      	blx	r3
    3696:	62e0      	str	r0, [r4, #44]	; 0x2c
			dhcp_check(netif);
    3698:	4648      	mov	r0, r9
    369a:	4b50      	ldr	r3, [pc, #320]	; (37dc <dhcp_recv+0x74c>)
    369c:	4798      	blx	r3
    369e:	e542      	b.n	3126 <dhcp_recv+0x96>
		dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
    36a0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    36a2:	085b      	lsrs	r3, r3, #1
    36a4:	6363      	str	r3, [r4, #52]	; 0x34
    36a6:	e7dc      	b.n	3662 <dhcp_recv+0x5d2>
		dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
    36a8:	6b23      	ldr	r3, [r4, #48]	; 0x30
    36aa:	63a3      	str	r3, [r4, #56]	; 0x38
    36ac:	e7df      	b.n	366e <dhcp_recv+0x5de>
		dhcp->subnet_mask_given = 0;
    36ae:	2300      	movs	r3, #0
    36b0:	73a3      	strb	r3, [r4, #14]
    36b2:	e7e9      	b.n	3688 <dhcp_recv+0x5f8>
		else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
    36b4:	3b03      	subs	r3, #3
    36b6:	b2db      	uxtb	r3, r3
    36b8:	2b02      	cmp	r3, #2
    36ba:	f63f ad34 	bhi.w	3126 <dhcp_recv+0x96>
			dhcp_bind(netif);
    36be:	4648      	mov	r0, r9
    36c0:	4b47      	ldr	r3, [pc, #284]	; (37e0 <dhcp_recv+0x750>)
    36c2:	4798      	blx	r3
    36c4:	e52f      	b.n	3126 <dhcp_recv+0x96>
	else if ((msg_type == DHCP_NAK)
    36c6:	2b06      	cmp	r3, #6
    36c8:	d130      	bne.n	372c <dhcp_recv+0x69c>
	         && ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_REBINDING)
    36ca:	9b04      	ldr	r3, [sp, #16]
    36cc:	7b1a      	ldrb	r2, [r3, #12]
    36ce:	1ed3      	subs	r3, r2, #3
    36d0:	b2db      	uxtb	r3, r3
    36d2:	2b02      	cmp	r3, #2
    36d4:	d902      	bls.n	36dc <dhcp_recv+0x64c>
    36d6:	2a01      	cmp	r2, #1
    36d8:	f47f ad25 	bne.w	3126 <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    36dc:	4841      	ldr	r0, [pc, #260]	; (37e4 <dhcp_recv+0x754>)
    36de:	4b37      	ldr	r3, [pc, #220]	; (37bc <dhcp_recv+0x72c>)
    36e0:	4798      	blx	r3
	struct dhcp *dhcp = netif->dhcp;
    36e2:	f8d9 5028 	ldr.w	r5, [r9, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    36e6:	f899 3037 	ldrb.w	r3, [r9, #55]	; 0x37
    36ea:	f899 2036 	ldrb.w	r2, [r9, #54]	; 0x36
    36ee:	f899 1038 	ldrb.w	r1, [r9, #56]	; 0x38
    36f2:	9100      	str	r1, [sp, #0]
    36f4:	4649      	mov	r1, r9
    36f6:	483c      	ldr	r0, [pc, #240]	; (37e8 <dhcp_recv+0x758>)
    36f8:	4c2e      	ldr	r4, [pc, #184]	; (37b4 <dhcp_recv+0x724>)
    36fa:	47a0      	blx	r4
	netif_set_down(netif);
    36fc:	4648      	mov	r0, r9
    36fe:	4b3b      	ldr	r3, [pc, #236]	; (37ec <dhcp_recv+0x75c>)
    3700:	4798      	blx	r3
	netif_set_ipaddr(netif, IP_ADDR_ANY);
    3702:	4c3b      	ldr	r4, [pc, #236]	; (37f0 <dhcp_recv+0x760>)
    3704:	4621      	mov	r1, r4
    3706:	4648      	mov	r0, r9
    3708:	4b3a      	ldr	r3, [pc, #232]	; (37f4 <dhcp_recv+0x764>)
    370a:	4798      	blx	r3
	netif_set_gw(netif, IP_ADDR_ANY);
    370c:	4621      	mov	r1, r4
    370e:	4648      	mov	r0, r9
    3710:	4b39      	ldr	r3, [pc, #228]	; (37f8 <dhcp_recv+0x768>)
    3712:	4798      	blx	r3
	netif_set_netmask(netif, IP_ADDR_ANY);
    3714:	4621      	mov	r1, r4
    3716:	4648      	mov	r0, r9
    3718:	4b38      	ldr	r3, [pc, #224]	; (37fc <dhcp_recv+0x76c>)
    371a:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    371c:	210c      	movs	r1, #12
    371e:	4628      	mov	r0, r5
    3720:	4b37      	ldr	r3, [pc, #220]	; (3800 <dhcp_recv+0x770>)
    3722:	4798      	blx	r3
	dhcp_discover(netif);
    3724:	4648      	mov	r0, r9
    3726:	4b37      	ldr	r3, [pc, #220]	; (3804 <dhcp_recv+0x774>)
    3728:	4798      	blx	r3
    372a:	e4fc      	b.n	3126 <dhcp_recv+0x96>
	else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    372c:	2b02      	cmp	r3, #2
    372e:	f47f acfa 	bne.w	3126 <dhcp_recv+0x96>
    3732:	9b04      	ldr	r3, [sp, #16]
    3734:	7b1b      	ldrb	r3, [r3, #12]
    3736:	2b06      	cmp	r3, #6
    3738:	f47f acf5 	bne.w	3126 <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    373c:	4832      	ldr	r0, [pc, #200]	; (3808 <dhcp_recv+0x778>)
    373e:	4b1f      	ldr	r3, [pc, #124]	; (37bc <dhcp_recv+0x72c>)
    3740:	4798      	blx	r3
		dhcp->request_timeout = 0;
    3742:	2300      	movs	r3, #0
    3744:	9a04      	ldr	r2, [sp, #16]
    3746:	8353      	strh	r3, [r2, #26]
	struct dhcp *dhcp = netif->dhcp;
    3748:	f8d9 4028 	ldr.w	r4, [r9, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
    374c:	f899 3037 	ldrb.w	r3, [r9, #55]	; 0x37
    3750:	f899 2036 	ldrb.w	r2, [r9, #54]	; 0x36
    3754:	f899 1038 	ldrb.w	r1, [r9, #56]	; 0x38
    3758:	9100      	str	r1, [sp, #0]
    375a:	4649      	mov	r1, r9
    375c:	482b      	ldr	r0, [pc, #172]	; (380c <dhcp_recv+0x77c>)
    375e:	4d15      	ldr	r5, [pc, #84]	; (37b4 <dhcp_recv+0x724>)
    3760:	47a8      	blx	r5
	if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    3762:	4b0e      	ldr	r3, [pc, #56]	; (379c <dhcp_recv+0x70c>)
    3764:	789b      	ldrb	r3, [r3, #2]
    3766:	b183      	cbz	r3, 378a <dhcp_recv+0x6fa>
		ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
    3768:	4b0d      	ldr	r3, [pc, #52]	; (37a0 <dhcp_recv+0x710>)
    376a:	6898      	ldr	r0, [r3, #8]
    376c:	4b1a      	ldr	r3, [pc, #104]	; (37d8 <dhcp_recv+0x748>)
    376e:	4798      	blx	r3
    3770:	4601      	mov	r1, r0
    3772:	6220      	str	r0, [r4, #32]
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE,
    3774:	4826      	ldr	r0, [pc, #152]	; (3810 <dhcp_recv+0x780>)
    3776:	47a8      	blx	r5
		ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    3778:	68a3      	ldr	r3, [r4, #8]
    377a:	6919      	ldr	r1, [r3, #16]
    377c:	6261      	str	r1, [r4, #36]	; 0x24
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE,
    377e:	4825      	ldr	r0, [pc, #148]	; (3814 <dhcp_recv+0x784>)
    3780:	47a8      	blx	r5
		dhcp_select(netif);
    3782:	4648      	mov	r0, r9
    3784:	4b24      	ldr	r3, [pc, #144]	; (3818 <dhcp_recv+0x788>)
    3786:	4798      	blx	r3
    3788:	e4cd      	b.n	3126 <dhcp_recv+0x96>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    378a:	4649      	mov	r1, r9
    378c:	4823      	ldr	r0, [pc, #140]	; (381c <dhcp_recv+0x78c>)
    378e:	4b09      	ldr	r3, [pc, #36]	; (37b4 <dhcp_recv+0x724>)
    3790:	4798      	blx	r3
    3792:	e4c8      	b.n	3126 <dhcp_recv+0x96>
	q = p;
    3794:	f8dd b014 	ldr.w	fp, [sp, #20]
    3798:	e50d      	b.n	31b6 <dhcp_recv+0x126>
    379a:	bf00      	nop
    379c:	200082d8 	.word	0x200082d8
    37a0:	200082e4 	.word	0x200082e4
    37a4:	00002711 	.word	0x00002711
    37a8:	0000aac4 	.word	0x0000aac4
    37ac:	0000b1ec 	.word	0x0000b1ec
    37b0:	0000ab0c 	.word	0x0000ab0c
    37b4:	00009815 	.word	0x00009815
    37b8:	0000b218 	.word	0x0000b218
    37bc:	000098fd 	.word	0x000098fd
    37c0:	0000b230 	.word	0x0000b230
    37c4:	0000b250 	.word	0x0000b250
    37c8:	0000b2a8 	.word	0x0000b2a8
    37cc:	0000b2cc 	.word	0x0000b2cc
    37d0:	0000b270 	.word	0x0000b270
    37d4:	0000b2f8 	.word	0x0000b2f8
    37d8:	000026f9 	.word	0x000026f9
    37dc:	00002e81 	.word	0x00002e81
    37e0:	00002ee9 	.word	0x00002ee9
    37e4:	0000b30c 	.word	0x0000b30c
    37e8:	0000b320 	.word	0x0000b320
    37ec:	00005361 	.word	0x00005361
    37f0:	0000bac0 	.word	0x0000bac0
    37f4:	0000521d 	.word	0x0000521d
    37f8:	00005301 	.word	0x00005301
    37fc:	0000530d 	.word	0x0000530d
    3800:	0000271d 	.word	0x0000271d
    3804:	00002af1 	.word	0x00002af1
    3808:	0000b344 	.word	0x0000b344
    380c:	0000b370 	.word	0x0000b370
    3810:	0000b398 	.word	0x0000b398
    3814:	0000b3bc 	.word	0x0000b3bc
    3818:	00002c29 	.word	0x00002c29
    381c:	0000b3e4 	.word	0x0000b3e4
		switch (op) {
    3820:	2b3b      	cmp	r3, #59	; 0x3b
    3822:	f63f ae8b 	bhi.w	353c <dhcp_recv+0x4ac>
    3826:	a201      	add	r2, pc, #4	; (adr r2, 382c <dhcp_recv+0x79c>)
    3828:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    382c:	0000320f 	.word	0x0000320f
    3830:	00003421 	.word	0x00003421
    3834:	0000353d 	.word	0x0000353d
    3838:	00003431 	.word	0x00003431
    383c:	0000353d 	.word	0x0000353d
    3840:	0000353d 	.word	0x0000353d
    3844:	0000344d 	.word	0x0000344d
    3848:	0000353d 	.word	0x0000353d
    384c:	0000353d 	.word	0x0000353d
    3850:	0000353d 	.word	0x0000353d
    3854:	0000353d 	.word	0x0000353d
    3858:	0000353d 	.word	0x0000353d
    385c:	0000353d 	.word	0x0000353d
    3860:	0000353d 	.word	0x0000353d
    3864:	0000353d 	.word	0x0000353d
    3868:	0000353d 	.word	0x0000353d
    386c:	0000353d 	.word	0x0000353d
    3870:	0000353d 	.word	0x0000353d
    3874:	0000353d 	.word	0x0000353d
    3878:	0000353d 	.word	0x0000353d
    387c:	0000353d 	.word	0x0000353d
    3880:	0000353d 	.word	0x0000353d
    3884:	0000353d 	.word	0x0000353d
    3888:	0000353d 	.word	0x0000353d
    388c:	0000353d 	.word	0x0000353d
    3890:	0000353d 	.word	0x0000353d
    3894:	0000353d 	.word	0x0000353d
    3898:	0000353d 	.word	0x0000353d
    389c:	0000353d 	.word	0x0000353d
    38a0:	0000353d 	.word	0x0000353d
    38a4:	0000353d 	.word	0x0000353d
    38a8:	0000353d 	.word	0x0000353d
    38ac:	0000353d 	.word	0x0000353d
    38b0:	0000353d 	.word	0x0000353d
    38b4:	0000353d 	.word	0x0000353d
    38b8:	0000353d 	.word	0x0000353d
    38bc:	0000353d 	.word	0x0000353d
    38c0:	0000353d 	.word	0x0000353d
    38c4:	0000353d 	.word	0x0000353d
    38c8:	0000353d 	.word	0x0000353d
    38cc:	0000353d 	.word	0x0000353d
    38d0:	0000353d 	.word	0x0000353d
    38d4:	0000353d 	.word	0x0000353d
    38d8:	0000353d 	.word	0x0000353d
    38dc:	0000353d 	.word	0x0000353d
    38e0:	0000353d 	.word	0x0000353d
    38e4:	0000353d 	.word	0x0000353d
    38e8:	0000353d 	.word	0x0000353d
    38ec:	0000353d 	.word	0x0000353d
    38f0:	0000353d 	.word	0x0000353d
    38f4:	0000353d 	.word	0x0000353d
    38f8:	00003495 	.word	0x00003495
    38fc:	000034b1 	.word	0x000034b1
    3900:	000034cd 	.word	0x000034cd
    3904:	000034e9 	.word	0x000034e9
    3908:	0000353d 	.word	0x0000353d
    390c:	0000353d 	.word	0x0000353d
    3910:	0000353d 	.word	0x0000353d
    3914:	00003505 	.word	0x00003505
    3918:	00003521 	.word	0x00003521

0000391c <dhcp_arp_reply>:
{
    391c:	b570      	push	{r4, r5, r6, lr}
    391e:	b082      	sub	sp, #8
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    3920:	b158      	cbz	r0, 393a <dhcp_arp_reply+0x1e>
    3922:	460c      	mov	r4, r1
    3924:	4605      	mov	r5, r0
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
    3926:	482e      	ldr	r0, [pc, #184]	; (39e0 <dhcp_arp_reply+0xc4>)
    3928:	4b2e      	ldr	r3, [pc, #184]	; (39e4 <dhcp_arp_reply+0xc8>)
    392a:	4798      	blx	r3
	if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
    392c:	6aab      	ldr	r3, [r5, #40]	; 0x28
    392e:	b113      	cbz	r3, 3936 <dhcp_arp_reply+0x1a>
    3930:	7b1b      	ldrb	r3, [r3, #12]
    3932:	2b08      	cmp	r3, #8
    3934:	d009      	beq.n	394a <dhcp_arp_reply+0x2e>
}
    3936:	b002      	add	sp, #8
    3938:	bd70      	pop	{r4, r5, r6, pc}
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    393a:	4b2b      	ldr	r3, [pc, #172]	; (39e8 <dhcp_arp_reply+0xcc>)
    393c:	f240 3226 	movw	r2, #806	; 0x326
    3940:	492a      	ldr	r1, [pc, #168]	; (39ec <dhcp_arp_reply+0xd0>)
    3942:	482b      	ldr	r0, [pc, #172]	; (39f0 <dhcp_arp_reply+0xd4>)
    3944:	4c2b      	ldr	r4, [pc, #172]	; (39f4 <dhcp_arp_reply+0xd8>)
    3946:	47a0      	blx	r4
    3948:	e7fe      	b.n	3948 <dhcp_arp_reply+0x2c>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    394a:	6821      	ldr	r1, [r4, #0]
    394c:	482a      	ldr	r0, [pc, #168]	; (39f8 <dhcp_arp_reply+0xdc>)
    394e:	4b29      	ldr	r3, [pc, #164]	; (39f4 <dhcp_arp_reply+0xd8>)
    3950:	4798      	blx	r3
		if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
    3952:	6aab      	ldr	r3, [r5, #40]	; 0x28
    3954:	6822      	ldr	r2, [r4, #0]
    3956:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3958:	429a      	cmp	r2, r3
    395a:	d1ec      	bne.n	3936 <dhcp_arp_reply+0x1a>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
    395c:	4827      	ldr	r0, [pc, #156]	; (39fc <dhcp_arp_reply+0xe0>)
    395e:	4e21      	ldr	r6, [pc, #132]	; (39e4 <dhcp_arp_reply+0xc8>)
    3960:	47b0      	blx	r6
	struct dhcp *dhcp   = netif->dhcp;
    3962:	6aac      	ldr	r4, [r5, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
    3964:	4826      	ldr	r0, [pc, #152]	; (3a00 <dhcp_arp_reply+0xe4>)
    3966:	47b0      	blx	r6
	dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    3968:	210c      	movs	r1, #12
    396a:	4620      	mov	r0, r4
    396c:	4b25      	ldr	r3, [pc, #148]	; (3a04 <dhcp_arp_reply+0xe8>)
    396e:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
    3970:	2204      	movs	r2, #4
    3972:	4621      	mov	r1, r4
    3974:	4628      	mov	r0, r5
    3976:	4b24      	ldr	r3, [pc, #144]	; (3a08 <dhcp_arp_reply+0xec>)
    3978:	4798      	blx	r3
	if (result == ERR_OK) {
    397a:	2800      	cmp	r0, #0
    397c:	d12b      	bne.n	39d6 <dhcp_arp_reply+0xba>
		dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    397e:	2204      	movs	r2, #4
    3980:	2132      	movs	r1, #50	; 0x32
    3982:	4620      	mov	r0, r4
    3984:	4b21      	ldr	r3, [pc, #132]	; (3a0c <dhcp_arp_reply+0xf0>)
    3986:	4798      	blx	r3
		dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    3988:	6a60      	ldr	r0, [r4, #36]	; 0x24
    398a:	4b21      	ldr	r3, [pc, #132]	; (3a10 <dhcp_arp_reply+0xf4>)
    398c:	4798      	blx	r3
    398e:	4601      	mov	r1, r0
    3990:	4620      	mov	r0, r4
    3992:	4b20      	ldr	r3, [pc, #128]	; (3a14 <dhcp_arp_reply+0xf8>)
    3994:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    3996:	4620      	mov	r0, r4
    3998:	4b1f      	ldr	r3, [pc, #124]	; (3a18 <dhcp_arp_reply+0xfc>)
    399a:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    399c:	8b21      	ldrh	r1, [r4, #24]
    399e:	31f0      	adds	r1, #240	; 0xf0
    39a0:	b289      	uxth	r1, r1
    39a2:	6920      	ldr	r0, [r4, #16]
    39a4:	4b1d      	ldr	r3, [pc, #116]	; (3a1c <dhcp_arp_reply+0x100>)
    39a6:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    39a8:	6921      	ldr	r1, [r4, #16]
    39aa:	6860      	ldr	r0, [r4, #4]
    39ac:	9500      	str	r5, [sp, #0]
    39ae:	2343      	movs	r3, #67	; 0x43
    39b0:	4a1b      	ldr	r2, [pc, #108]	; (3a20 <dhcp_arp_reply+0x104>)
    39b2:	4d1c      	ldr	r5, [pc, #112]	; (3a24 <dhcp_arp_reply+0x108>)
    39b4:	47a8      	blx	r5
		dhcp_delete_msg(dhcp);
    39b6:	4620      	mov	r0, r4
    39b8:	4b1b      	ldr	r3, [pc, #108]	; (3a28 <dhcp_arp_reply+0x10c>)
    39ba:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
    39bc:	481b      	ldr	r0, [pc, #108]	; (3a2c <dhcp_arp_reply+0x110>)
    39be:	47b0      	blx	r6
	dhcp->tries++;
    39c0:	7b63      	ldrb	r3, [r4, #13]
    39c2:	3301      	adds	r3, #1
    39c4:	7363      	strb	r3, [r4, #13]
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    39c6:	2314      	movs	r3, #20
    39c8:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %" U16_F " msecs\n", msecs));
    39ca:	f242 7110 	movw	r1, #10000	; 0x2710
    39ce:	4818      	ldr	r0, [pc, #96]	; (3a30 <dhcp_arp_reply+0x114>)
    39d0:	4b08      	ldr	r3, [pc, #32]	; (39f4 <dhcp_arp_reply+0xd8>)
    39d2:	4798      	blx	r3
}
    39d4:	e7af      	b.n	3936 <dhcp_arp_reply+0x1a>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    39d6:	4817      	ldr	r0, [pc, #92]	; (3a34 <dhcp_arp_reply+0x118>)
    39d8:	4b02      	ldr	r3, [pc, #8]	; (39e4 <dhcp_arp_reply+0xc8>)
    39da:	4798      	blx	r3
    39dc:	e7f0      	b.n	39c0 <dhcp_arp_reply+0xa4>
    39de:	bf00      	nop
    39e0:	0000b4b8 	.word	0x0000b4b8
    39e4:	000098fd 	.word	0x000098fd
    39e8:	0000aac4 	.word	0x0000aac4
    39ec:	0000b418 	.word	0x0000b418
    39f0:	0000ab0c 	.word	0x0000ab0c
    39f4:	00009815 	.word	0x00009815
    39f8:	0000b4cc 	.word	0x0000b4cc
    39fc:	0000b500 	.word	0x0000b500
    3a00:	0000b544 	.word	0x0000b544
    3a04:	0000271d 	.word	0x0000271d
    3a08:	00002821 	.word	0x00002821
    3a0c:	0000272d 	.word	0x0000272d
    3a10:	00002711 	.word	0x00002711
    3a14:	0000278b 	.word	0x0000278b
    3a18:	000027d1 	.word	0x000027d1
    3a1c:	0000566d 	.word	0x0000566d
    3a20:	0000babc 	.word	0x0000babc
    3a24:	000084f1 	.word	0x000084f1
    3a28:	000029cd 	.word	0x000029cd
    3a2c:	0000b554 	.word	0x0000b554
    3a30:	0000b5a0 	.word	0x0000b5a0
    3a34:	0000b570 	.word	0x0000b570

00003a38 <dhcp_renew>:
{
    3a38:	b570      	push	{r4, r5, r6, lr}
    3a3a:	b082      	sub	sp, #8
    3a3c:	4606      	mov	r6, r0
	struct dhcp *dhcp = netif->dhcp;
    3a3e:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
    3a40:	4828      	ldr	r0, [pc, #160]	; (3ae4 <dhcp_renew+0xac>)
    3a42:	4b29      	ldr	r3, [pc, #164]	; (3ae8 <dhcp_renew+0xb0>)
    3a44:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_RENEWING);
    3a46:	2105      	movs	r1, #5
    3a48:	4620      	mov	r0, r4
    3a4a:	4b28      	ldr	r3, [pc, #160]	; (3aec <dhcp_renew+0xb4>)
    3a4c:	4798      	blx	r3
	result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    3a4e:	2203      	movs	r2, #3
    3a50:	4621      	mov	r1, r4
    3a52:	4630      	mov	r0, r6
    3a54:	4b26      	ldr	r3, [pc, #152]	; (3af0 <dhcp_renew+0xb8>)
    3a56:	4798      	blx	r3
	if (result == ERR_OK) {
    3a58:	4605      	mov	r5, r0
    3a5a:	2800      	cmp	r0, #0
    3a5c:	d13a      	bne.n	3ad4 <dhcp_renew+0x9c>
		dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    3a5e:	2202      	movs	r2, #2
    3a60:	2139      	movs	r1, #57	; 0x39
    3a62:	4620      	mov	r0, r4
    3a64:	4b23      	ldr	r3, [pc, #140]	; (3af4 <dhcp_renew+0xbc>)
    3a66:	4798      	blx	r3
		dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    3a68:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
    3a6a:	4620      	mov	r0, r4
    3a6c:	4b22      	ldr	r3, [pc, #136]	; (3af8 <dhcp_renew+0xc0>)
    3a6e:	4798      	blx	r3
		dhcp_option_trailer(dhcp);
    3a70:	4620      	mov	r0, r4
    3a72:	4b22      	ldr	r3, [pc, #136]	; (3afc <dhcp_renew+0xc4>)
    3a74:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3a76:	8b21      	ldrh	r1, [r4, #24]
    3a78:	31f0      	adds	r1, #240	; 0xf0
    3a7a:	b289      	uxth	r1, r1
    3a7c:	6920      	ldr	r0, [r4, #16]
    3a7e:	4b20      	ldr	r3, [pc, #128]	; (3b00 <dhcp_renew+0xc8>)
    3a80:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    3a82:	6921      	ldr	r1, [r4, #16]
    3a84:	6860      	ldr	r0, [r4, #4]
    3a86:	9600      	str	r6, [sp, #0]
    3a88:	2343      	movs	r3, #67	; 0x43
    3a8a:	f104 0220 	add.w	r2, r4, #32
    3a8e:	4e1d      	ldr	r6, [pc, #116]	; (3b04 <dhcp_renew+0xcc>)
    3a90:	47b0      	blx	r6
		dhcp_delete_msg(dhcp);
    3a92:	4620      	mov	r0, r4
    3a94:	4b1c      	ldr	r3, [pc, #112]	; (3b08 <dhcp_renew+0xd0>)
    3a96:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
    3a98:	481c      	ldr	r0, [pc, #112]	; (3b0c <dhcp_renew+0xd4>)
    3a9a:	4b13      	ldr	r3, [pc, #76]	; (3ae8 <dhcp_renew+0xb0>)
    3a9c:	4798      	blx	r3
	dhcp->tries++;
    3a9e:	7b61      	ldrb	r1, [r4, #13]
    3aa0:	3101      	adds	r1, #1
    3aa2:	b2c9      	uxtb	r1, r1
    3aa4:	7361      	strb	r1, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    3aa6:	2909      	cmp	r1, #9
    3aa8:	d818      	bhi.n	3adc <dhcp_renew+0xa4>
    3aaa:	ebc1 1341 	rsb	r3, r1, r1, lsl #5
    3aae:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    3ab2:	0109      	lsls	r1, r1, #4
    3ab4:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3ab6:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    3aba:	4a15      	ldr	r2, [pc, #84]	; (3b10 <dhcp_renew+0xd8>)
    3abc:	fb82 0203 	smull	r0, r2, r2, r3
    3ac0:	17db      	asrs	r3, r3, #31
    3ac2:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    3ac6:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    3ac8:	4812      	ldr	r0, [pc, #72]	; (3b14 <dhcp_renew+0xdc>)
    3aca:	4b13      	ldr	r3, [pc, #76]	; (3b18 <dhcp_renew+0xe0>)
    3acc:	4798      	blx	r3
}
    3ace:	4628      	mov	r0, r5
    3ad0:	b002      	add	sp, #8
    3ad2:	bd70      	pop	{r4, r5, r6, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    3ad4:	4811      	ldr	r0, [pc, #68]	; (3b1c <dhcp_renew+0xe4>)
    3ad6:	4b04      	ldr	r3, [pc, #16]	; (3ae8 <dhcp_renew+0xb0>)
    3ad8:	4798      	blx	r3
    3ada:	e7e0      	b.n	3a9e <dhcp_renew+0x66>
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    3adc:	f644 6120 	movw	r1, #20000	; 0x4e20
    3ae0:	e7e9      	b.n	3ab6 <dhcp_renew+0x7e>
    3ae2:	bf00      	nop
    3ae4:	0000b5d0 	.word	0x0000b5d0
    3ae8:	000098fd 	.word	0x000098fd
    3aec:	0000271d 	.word	0x0000271d
    3af0:	00002821 	.word	0x00002821
    3af4:	0000272d 	.word	0x0000272d
    3af8:	00002765 	.word	0x00002765
    3afc:	000027d1 	.word	0x000027d1
    3b00:	0000566d 	.word	0x0000566d
    3b04:	000084f1 	.word	0x000084f1
    3b08:	000029cd 	.word	0x000029cd
    3b0c:	0000b5e0 	.word	0x0000b5e0
    3b10:	10624dd3 	.word	0x10624dd3
    3b14:	0000b624 	.word	0x0000b624
    3b18:	00009815 	.word	0x00009815
    3b1c:	0000b5f8 	.word	0x0000b5f8

00003b20 <dhcp_coarse_tmr>:
{
    3b20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct netif *netif = netif_list;
    3b24:	4b22      	ldr	r3, [pc, #136]	; (3bb0 <dhcp_coarse_tmr+0x90>)
    3b26:	681c      	ldr	r4, [r3, #0]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
    3b28:	4822      	ldr	r0, [pc, #136]	; (3bb4 <dhcp_coarse_tmr+0x94>)
    3b2a:	4b23      	ldr	r3, [pc, #140]	; (3bb8 <dhcp_coarse_tmr+0x98>)
    3b2c:	4798      	blx	r3
	while (netif != NULL) {
    3b2e:	2c00      	cmp	r4, #0
    3b30:	d03b      	beq.n	3baa <dhcp_coarse_tmr+0x8a>
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
    3b32:	4f22      	ldr	r7, [pc, #136]	; (3bbc <dhcp_coarse_tmr+0x9c>)
    3b34:	4d20      	ldr	r5, [pc, #128]	; (3bb8 <dhcp_coarse_tmr+0x98>)
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
    3b36:	4e22      	ldr	r6, [pc, #136]	; (3bc0 <dhcp_coarse_tmr+0xa0>)
    3b38:	e00f      	b.n	3b5a <dhcp_coarse_tmr+0x3a>
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
    3b3a:	4822      	ldr	r0, [pc, #136]	; (3bc4 <dhcp_coarse_tmr+0xa4>)
    3b3c:	47a8      	blx	r5
	struct dhcp *dhcp = netif->dhcp;
    3b3e:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
    3b42:	4821      	ldr	r0, [pc, #132]	; (3bc8 <dhcp_coarse_tmr+0xa8>)
    3b44:	47a8      	blx	r5
	if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    3b46:	f898 300c 	ldrb.w	r3, [r8, #12]
    3b4a:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
    3b4e:	2a01      	cmp	r2, #1
    3b50:	d025      	beq.n	3b9e <dhcp_coarse_tmr+0x7e>
    3b52:	2b0a      	cmp	r3, #10
    3b54:	d023      	beq.n	3b9e <dhcp_coarse_tmr+0x7e>
		netif = netif->next;
    3b56:	6824      	ldr	r4, [r4, #0]
	while (netif != NULL) {
    3b58:	b33c      	cbz	r4, 3baa <dhcp_coarse_tmr+0x8a>
		if (netif->dhcp != NULL) {
    3b5a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    3b5c:	2b00      	cmp	r3, #0
    3b5e:	d0fa      	beq.n	3b56 <dhcp_coarse_tmr+0x36>
			if (netif->dhcp->t2_timeout-- == 1) {
    3b60:	8bda      	ldrh	r2, [r3, #30]
    3b62:	1e51      	subs	r1, r2, #1
    3b64:	83d9      	strh	r1, [r3, #30]
    3b66:	2a01      	cmp	r2, #1
    3b68:	d0e7      	beq.n	3b3a <dhcp_coarse_tmr+0x1a>
			} else if (netif->dhcp->t1_timeout-- == 1) {
    3b6a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    3b6c:	8b93      	ldrh	r3, [r2, #28]
    3b6e:	1e59      	subs	r1, r3, #1
    3b70:	8391      	strh	r1, [r2, #28]
    3b72:	2b01      	cmp	r3, #1
    3b74:	d1ef      	bne.n	3b56 <dhcp_coarse_tmr+0x36>
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
    3b76:	4638      	mov	r0, r7
    3b78:	47a8      	blx	r5
	struct dhcp *dhcp = netif->dhcp;
    3b7a:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
    3b7e:	4630      	mov	r0, r6
    3b80:	47a8      	blx	r5
	if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
    3b82:	f898 300c 	ldrb.w	r3, [r8, #12]
    3b86:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
    3b8a:	2a01      	cmp	r2, #1
    3b8c:	d001      	beq.n	3b92 <dhcp_coarse_tmr+0x72>
    3b8e:	2b0a      	cmp	r3, #10
    3b90:	d1e1      	bne.n	3b56 <dhcp_coarse_tmr+0x36>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    3b92:	480e      	ldr	r0, [pc, #56]	; (3bcc <dhcp_coarse_tmr+0xac>)
    3b94:	47a8      	blx	r5
		dhcp_renew(netif);
    3b96:	4620      	mov	r0, r4
    3b98:	4b0d      	ldr	r3, [pc, #52]	; (3bd0 <dhcp_coarse_tmr+0xb0>)
    3b9a:	4798      	blx	r3
    3b9c:	e7db      	b.n	3b56 <dhcp_coarse_tmr+0x36>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    3b9e:	480d      	ldr	r0, [pc, #52]	; (3bd4 <dhcp_coarse_tmr+0xb4>)
    3ba0:	47a8      	blx	r5
		dhcp_rebind(netif);
    3ba2:	4620      	mov	r0, r4
    3ba4:	4b0c      	ldr	r3, [pc, #48]	; (3bd8 <dhcp_coarse_tmr+0xb8>)
    3ba6:	4798      	blx	r3
    3ba8:	e7d5      	b.n	3b56 <dhcp_coarse_tmr+0x36>
    3baa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3bae:	bf00      	nop
    3bb0:	200092d0 	.word	0x200092d0
    3bb4:	0000b654 	.word	0x0000b654
    3bb8:	000098fd 	.word	0x000098fd
    3bbc:	0000b6bc 	.word	0x0000b6bc
    3bc0:	0000b6dc 	.word	0x0000b6dc
    3bc4:	0000b668 	.word	0x0000b668
    3bc8:	0000b688 	.word	0x0000b688
    3bcc:	0000b6f0 	.word	0x0000b6f0
    3bd0:	00003a39 	.word	0x00003a39
    3bd4:	0000b69c 	.word	0x0000b69c
    3bd8:	00002a09 	.word	0x00002a09

00003bdc <dhcp_release>:
{
    3bdc:	b5f0      	push	{r4, r5, r6, r7, lr}
    3bde:	b083      	sub	sp, #12
    3be0:	4605      	mov	r5, r0
	struct dhcp *dhcp = netif->dhcp;
    3be2:	6a84      	ldr	r4, [r0, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));
    3be4:	482f      	ldr	r0, [pc, #188]	; (3ca4 <dhcp_release+0xc8>)
    3be6:	4b30      	ldr	r3, [pc, #192]	; (3ca8 <dhcp_release+0xcc>)
    3be8:	4798      	blx	r3
	dhcp_set_state(dhcp, DHCP_OFF);
    3bea:	2100      	movs	r1, #0
    3bec:	4620      	mov	r0, r4
    3bee:	4b2f      	ldr	r3, [pc, #188]	; (3cac <dhcp_release+0xd0>)
    3bf0:	4798      	blx	r3
	ip_addr_set_zero(&dhcp->server_ip_addr);
    3bf2:	2300      	movs	r3, #0
    3bf4:	6223      	str	r3, [r4, #32]
	ip_addr_set_zero(&dhcp->offered_ip_addr);
    3bf6:	6263      	str	r3, [r4, #36]	; 0x24
	ip_addr_set_zero(&dhcp->offered_sn_mask);
    3bf8:	62a3      	str	r3, [r4, #40]	; 0x28
	ip_addr_set_zero(&dhcp->offered_gw_addr);
    3bfa:	62e3      	str	r3, [r4, #44]	; 0x2c
	dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
    3bfc:	63a3      	str	r3, [r4, #56]	; 0x38
    3bfe:	6363      	str	r3, [r4, #52]	; 0x34
    3c00:	6323      	str	r3, [r4, #48]	; 0x30
	result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
    3c02:	2207      	movs	r2, #7
    3c04:	4621      	mov	r1, r4
    3c06:	4628      	mov	r0, r5
    3c08:	4b29      	ldr	r3, [pc, #164]	; (3cb0 <dhcp_release+0xd4>)
    3c0a:	4798      	blx	r3
	if (result == ERR_OK) {
    3c0c:	4606      	mov	r6, r0
    3c0e:	2800      	cmp	r0, #0
    3c10:	d141      	bne.n	3c96 <dhcp_release+0xba>
		dhcp_option_trailer(dhcp);
    3c12:	4620      	mov	r0, r4
    3c14:	4b27      	ldr	r3, [pc, #156]	; (3cb4 <dhcp_release+0xd8>)
    3c16:	4798      	blx	r3
		pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3c18:	8b21      	ldrh	r1, [r4, #24]
    3c1a:	31f0      	adds	r1, #240	; 0xf0
    3c1c:	b289      	uxth	r1, r1
    3c1e:	6920      	ldr	r0, [r4, #16]
    3c20:	4b25      	ldr	r3, [pc, #148]	; (3cb8 <dhcp_release+0xdc>)
    3c22:	4798      	blx	r3
		udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    3c24:	6921      	ldr	r1, [r4, #16]
    3c26:	6860      	ldr	r0, [r4, #4]
    3c28:	9500      	str	r5, [sp, #0]
    3c2a:	2343      	movs	r3, #67	; 0x43
    3c2c:	f104 0220 	add.w	r2, r4, #32
    3c30:	4f22      	ldr	r7, [pc, #136]	; (3cbc <dhcp_release+0xe0>)
    3c32:	47b8      	blx	r7
		dhcp_delete_msg(dhcp);
    3c34:	4620      	mov	r0, r4
    3c36:	4b22      	ldr	r3, [pc, #136]	; (3cc0 <dhcp_release+0xe4>)
    3c38:	4798      	blx	r3
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
    3c3a:	4822      	ldr	r0, [pc, #136]	; (3cc4 <dhcp_release+0xe8>)
    3c3c:	4b1a      	ldr	r3, [pc, #104]	; (3ca8 <dhcp_release+0xcc>)
    3c3e:	4798      	blx	r3
	dhcp->tries++;
    3c40:	7b61      	ldrb	r1, [r4, #13]
    3c42:	3101      	adds	r1, #1
    3c44:	b2c9      	uxtb	r1, r1
    3c46:	7361      	strb	r1, [r4, #13]
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3c48:	2909      	cmp	r1, #9
    3c4a:	d828      	bhi.n	3c9e <dhcp_release+0xc2>
    3c4c:	ebc1 1341 	rsb	r3, r1, r1, lsl #5
    3c50:	eb01 0183 	add.w	r1, r1, r3, lsl #2
    3c54:	00c9      	lsls	r1, r1, #3
    3c56:	b289      	uxth	r1, r1
	dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3c58:	f201 13f3 	addw	r3, r1, #499	; 0x1f3
    3c5c:	4a1a      	ldr	r2, [pc, #104]	; (3cc8 <dhcp_release+0xec>)
    3c5e:	fb82 0203 	smull	r0, r2, r2, r3
    3c62:	17db      	asrs	r3, r3, #31
    3c64:	ebc3 1362 	rsb	r3, r3, r2, asr #5
    3c68:	8363      	strh	r3, [r4, #26]
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    3c6a:	4818      	ldr	r0, [pc, #96]	; (3ccc <dhcp_release+0xf0>)
    3c6c:	4b18      	ldr	r3, [pc, #96]	; (3cd0 <dhcp_release+0xf4>)
    3c6e:	4798      	blx	r3
	netif_set_down(netif);
    3c70:	4628      	mov	r0, r5
    3c72:	4b18      	ldr	r3, [pc, #96]	; (3cd4 <dhcp_release+0xf8>)
    3c74:	4798      	blx	r3
	netif_set_ipaddr(netif, IP_ADDR_ANY);
    3c76:	4c18      	ldr	r4, [pc, #96]	; (3cd8 <dhcp_release+0xfc>)
    3c78:	4621      	mov	r1, r4
    3c7a:	4628      	mov	r0, r5
    3c7c:	4b17      	ldr	r3, [pc, #92]	; (3cdc <dhcp_release+0x100>)
    3c7e:	4798      	blx	r3
	netif_set_gw(netif, IP_ADDR_ANY);
    3c80:	4621      	mov	r1, r4
    3c82:	4628      	mov	r0, r5
    3c84:	4b16      	ldr	r3, [pc, #88]	; (3ce0 <dhcp_release+0x104>)
    3c86:	4798      	blx	r3
	netif_set_netmask(netif, IP_ADDR_ANY);
    3c88:	4621      	mov	r1, r4
    3c8a:	4628      	mov	r0, r5
    3c8c:	4b15      	ldr	r3, [pc, #84]	; (3ce4 <dhcp_release+0x108>)
    3c8e:	4798      	blx	r3
}
    3c90:	4630      	mov	r0, r6
    3c92:	b003      	add	sp, #12
    3c94:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    3c96:	4814      	ldr	r0, [pc, #80]	; (3ce8 <dhcp_release+0x10c>)
    3c98:	4b03      	ldr	r3, [pc, #12]	; (3ca8 <dhcp_release+0xcc>)
    3c9a:	4798      	blx	r3
    3c9c:	e7d0      	b.n	3c40 <dhcp_release+0x64>
	msecs                 = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3c9e:	f242 7110 	movw	r1, #10000	; 0x2710
    3ca2:	e7d9      	b.n	3c58 <dhcp_release+0x7c>
    3ca4:	0000b710 	.word	0x0000b710
    3ca8:	000098fd 	.word	0x000098fd
    3cac:	0000271d 	.word	0x0000271d
    3cb0:	00002821 	.word	0x00002821
    3cb4:	000027d1 	.word	0x000027d1
    3cb8:	0000566d 	.word	0x0000566d
    3cbc:	000084f1 	.word	0x000084f1
    3cc0:	000029cd 	.word	0x000029cd
    3cc4:	0000b720 	.word	0x0000b720
    3cc8:	10624dd3 	.word	0x10624dd3
    3ccc:	0000b774 	.word	0x0000b774
    3cd0:	00009815 	.word	0x00009815
    3cd4:	00005361 	.word	0x00005361
    3cd8:	0000bac0 	.word	0x0000bac0
    3cdc:	0000521d 	.word	0x0000521d
    3ce0:	00005301 	.word	0x00005301
    3ce4:	0000530d 	.word	0x0000530d
    3ce8:	0000b744 	.word	0x0000b744

00003cec <dhcp_fine_tmr>:
{
    3cec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct netif *netif = netif_list;
    3cf0:	4b3a      	ldr	r3, [pc, #232]	; (3ddc <dhcp_fine_tmr+0xf0>)
    3cf2:	681c      	ldr	r4, [r3, #0]
	while (netif != NULL) {
    3cf4:	2c00      	cmp	r4, #0
    3cf6:	d06f      	beq.n	3dd8 <dhcp_fine_tmr+0xec>
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
    3cf8:	4f39      	ldr	r7, [pc, #228]	; (3de0 <dhcp_fine_tmr+0xf4>)
    3cfa:	4d3a      	ldr	r5, [pc, #232]	; (3de4 <dhcp_fine_tmr+0xf8>)
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
    3cfc:	4e3a      	ldr	r6, [pc, #232]	; (3de8 <dhcp_fine_tmr+0xfc>)
    3cfe:	e004      	b.n	3d0a <dhcp_fine_tmr+0x1e>
			} else if (netif->dhcp->request_timeout == 1) {
    3d00:	2b01      	cmp	r3, #1
    3d02:	d00b      	beq.n	3d1c <dhcp_fine_tmr+0x30>
		netif = netif->next;
    3d04:	6824      	ldr	r4, [r4, #0]
	while (netif != NULL) {
    3d06:	2c00      	cmp	r4, #0
    3d08:	d066      	beq.n	3dd8 <dhcp_fine_tmr+0xec>
		if (netif->dhcp != NULL) {
    3d0a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    3d0c:	2a00      	cmp	r2, #0
    3d0e:	d0f9      	beq.n	3d04 <dhcp_fine_tmr+0x18>
			if (netif->dhcp->request_timeout > 1) {
    3d10:	8b53      	ldrh	r3, [r2, #26]
    3d12:	2b01      	cmp	r3, #1
    3d14:	d9f4      	bls.n	3d00 <dhcp_fine_tmr+0x14>
				netif->dhcp->request_timeout--;
    3d16:	3b01      	subs	r3, #1
    3d18:	8353      	strh	r3, [r2, #26]
    3d1a:	e7f3      	b.n	3d04 <dhcp_fine_tmr+0x18>
				netif->dhcp->request_timeout--;
    3d1c:	2300      	movs	r3, #0
    3d1e:	8353      	strh	r3, [r2, #26]
				LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
    3d20:	4638      	mov	r0, r7
    3d22:	47a8      	blx	r5
	struct dhcp *dhcp = netif->dhcp;
    3d24:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
    3d28:	4630      	mov	r0, r6
    3d2a:	47a8      	blx	r5
	if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    3d2c:	f898 300c 	ldrb.w	r3, [r8, #12]
    3d30:	2b0c      	cmp	r3, #12
    3d32:	d014      	beq.n	3d5e <dhcp_fine_tmr+0x72>
    3d34:	2b06      	cmp	r3, #6
    3d36:	d012      	beq.n	3d5e <dhcp_fine_tmr+0x72>
	} else if (dhcp->state == DHCP_REQUESTING) {
    3d38:	2b01      	cmp	r3, #1
    3d3a:	d016      	beq.n	3d6a <dhcp_fine_tmr+0x7e>
	} else if (dhcp->state == DHCP_CHECKING) {
    3d3c:	2b08      	cmp	r3, #8
    3d3e:	d027      	beq.n	3d90 <dhcp_fine_tmr+0xa4>
	else if (dhcp->state == DHCP_RENEWING) {
    3d40:	2b05      	cmp	r3, #5
    3d42:	d030      	beq.n	3da6 <dhcp_fine_tmr+0xba>
	} else if (dhcp->state == DHCP_REBINDING) {
    3d44:	2b04      	cmp	r3, #4
    3d46:	d034      	beq.n	3db2 <dhcp_fine_tmr+0xc6>
	} else if (dhcp->state == DHCP_REBOOTING) {
    3d48:	2b03      	cmp	r3, #3
    3d4a:	d1db      	bne.n	3d04 <dhcp_fine_tmr+0x18>
		if (dhcp->tries < REBOOT_TRIES) {
    3d4c:	f898 300d 	ldrb.w	r3, [r8, #13]
    3d50:	2b01      	cmp	r3, #1
			dhcp_reboot(netif);
    3d52:	4620      	mov	r0, r4
    3d54:	bf94      	ite	ls
    3d56:	4b25      	ldrls	r3, [pc, #148]	; (3dec <dhcp_fine_tmr+0x100>)
			dhcp_discover(netif);
    3d58:	4b25      	ldrhi	r3, [pc, #148]	; (3df0 <dhcp_fine_tmr+0x104>)
    3d5a:	4798      	blx	r3
    3d5c:	e7d2      	b.n	3d04 <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    3d5e:	4825      	ldr	r0, [pc, #148]	; (3df4 <dhcp_fine_tmr+0x108>)
    3d60:	47a8      	blx	r5
		dhcp_discover(netif);
    3d62:	4620      	mov	r0, r4
    3d64:	4b22      	ldr	r3, [pc, #136]	; (3df0 <dhcp_fine_tmr+0x104>)
    3d66:	4798      	blx	r3
    3d68:	e7cc      	b.n	3d04 <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    3d6a:	4823      	ldr	r0, [pc, #140]	; (3df8 <dhcp_fine_tmr+0x10c>)
    3d6c:	47a8      	blx	r5
		if (dhcp->tries <= 5) {
    3d6e:	f898 300d 	ldrb.w	r3, [r8, #13]
    3d72:	2b05      	cmp	r3, #5
    3d74:	d803      	bhi.n	3d7e <dhcp_fine_tmr+0x92>
			dhcp_select(netif);
    3d76:	4620      	mov	r0, r4
    3d78:	4b20      	ldr	r3, [pc, #128]	; (3dfc <dhcp_fine_tmr+0x110>)
    3d7a:	4798      	blx	r3
    3d7c:	e7c2      	b.n	3d04 <dhcp_fine_tmr+0x18>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    3d7e:	4820      	ldr	r0, [pc, #128]	; (3e00 <dhcp_fine_tmr+0x114>)
    3d80:	47a8      	blx	r5
			dhcp_release(netif);
    3d82:	4620      	mov	r0, r4
    3d84:	4b1f      	ldr	r3, [pc, #124]	; (3e04 <dhcp_fine_tmr+0x118>)
    3d86:	4798      	blx	r3
			dhcp_discover(netif);
    3d88:	4620      	mov	r0, r4
    3d8a:	4b19      	ldr	r3, [pc, #100]	; (3df0 <dhcp_fine_tmr+0x104>)
    3d8c:	4798      	blx	r3
    3d8e:	e7b9      	b.n	3d04 <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    3d90:	481d      	ldr	r0, [pc, #116]	; (3e08 <dhcp_fine_tmr+0x11c>)
    3d92:	47a8      	blx	r5
		if (dhcp->tries <= 1) {
    3d94:	f898 300d 	ldrb.w	r3, [r8, #13]
    3d98:	2b01      	cmp	r3, #1
			dhcp_check(netif);
    3d9a:	4620      	mov	r0, r4
    3d9c:	bf94      	ite	ls
    3d9e:	4b1b      	ldrls	r3, [pc, #108]	; (3e0c <dhcp_fine_tmr+0x120>)
			dhcp_bind(netif);
    3da0:	4b1b      	ldrhi	r3, [pc, #108]	; (3e10 <dhcp_fine_tmr+0x124>)
    3da2:	4798      	blx	r3
    3da4:	e7ae      	b.n	3d04 <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    3da6:	481b      	ldr	r0, [pc, #108]	; (3e14 <dhcp_fine_tmr+0x128>)
    3da8:	47a8      	blx	r5
		dhcp_renew(netif);
    3daa:	4620      	mov	r0, r4
    3dac:	4b1a      	ldr	r3, [pc, #104]	; (3e18 <dhcp_fine_tmr+0x12c>)
    3dae:	4798      	blx	r3
    3db0:	e7a8      	b.n	3d04 <dhcp_fine_tmr+0x18>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
    3db2:	481a      	ldr	r0, [pc, #104]	; (3e1c <dhcp_fine_tmr+0x130>)
    3db4:	47a8      	blx	r5
		if (dhcp->tries <= 8) {
    3db6:	f898 300d 	ldrb.w	r3, [r8, #13]
    3dba:	2b08      	cmp	r3, #8
    3dbc:	d803      	bhi.n	3dc6 <dhcp_fine_tmr+0xda>
			dhcp_rebind(netif);
    3dbe:	4620      	mov	r0, r4
    3dc0:	4b17      	ldr	r3, [pc, #92]	; (3e20 <dhcp_fine_tmr+0x134>)
    3dc2:	4798      	blx	r3
    3dc4:	e79e      	b.n	3d04 <dhcp_fine_tmr+0x18>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
    3dc6:	4817      	ldr	r0, [pc, #92]	; (3e24 <dhcp_fine_tmr+0x138>)
    3dc8:	47a8      	blx	r5
			dhcp_release(netif);
    3dca:	4620      	mov	r0, r4
    3dcc:	4b0d      	ldr	r3, [pc, #52]	; (3e04 <dhcp_fine_tmr+0x118>)
    3dce:	4798      	blx	r3
			dhcp_discover(netif);
    3dd0:	4620      	mov	r0, r4
    3dd2:	4b07      	ldr	r3, [pc, #28]	; (3df0 <dhcp_fine_tmr+0x104>)
    3dd4:	4798      	blx	r3
    3dd6:	e795      	b.n	3d04 <dhcp_fine_tmr+0x18>
    3dd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3ddc:	200092d0 	.word	0x200092d0
    3de0:	0000b7a4 	.word	0x0000b7a4
    3de4:	000098fd 	.word	0x000098fd
    3de8:	0000b7c8 	.word	0x0000b7c8
    3dec:	00002d79 	.word	0x00002d79
    3df0:	00002af1 	.word	0x00002af1
    3df4:	0000b7d8 	.word	0x0000b7d8
    3df8:	0000b800 	.word	0x0000b800
    3dfc:	00002c29 	.word	0x00002c29
    3e00:	0000b834 	.word	0x0000b834
    3e04:	00003bdd 	.word	0x00003bdd
    3e08:	0000b868 	.word	0x0000b868
    3e0c:	00002e81 	.word	0x00002e81
    3e10:	00002ee9 	.word	0x00002ee9
    3e14:	0000b898 	.word	0x0000b898
    3e18:	00003a39 	.word	0x00003a39
    3e1c:	0000b8cc 	.word	0x0000b8cc
    3e20:	00002a09 	.word	0x00002a09
    3e24:	0000b900 	.word	0x0000b900

00003e28 <dhcp_stop>:
{
    3e28:	b510      	push	{r4, lr}
	LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    3e2a:	b1a8      	cbz	r0, 3e58 <dhcp_stop+0x30>
	dhcp = netif->dhcp;
    3e2c:	6a84      	ldr	r4, [r0, #40]	; 0x28
	netif->flags &= ~NETIF_FLAG_DHCP;
    3e2e:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
    3e32:	f022 0208 	bic.w	r2, r2, #8
    3e36:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
    3e3a:	480b      	ldr	r0, [pc, #44]	; (3e68 <dhcp_stop+0x40>)
    3e3c:	4b0b      	ldr	r3, [pc, #44]	; (3e6c <dhcp_stop+0x44>)
    3e3e:	4798      	blx	r3
	if (dhcp != NULL) {
    3e40:	b14c      	cbz	r4, 3e56 <dhcp_stop+0x2e>
		if (dhcp->pcb != NULL) {
    3e42:	6860      	ldr	r0, [r4, #4]
    3e44:	b118      	cbz	r0, 3e4e <dhcp_stop+0x26>
			udp_remove(dhcp->pcb);
    3e46:	4b0a      	ldr	r3, [pc, #40]	; (3e70 <dhcp_stop+0x48>)
    3e48:	4798      	blx	r3
			dhcp->pcb = NULL;
    3e4a:	2300      	movs	r3, #0
    3e4c:	6063      	str	r3, [r4, #4]
		dhcp_set_state(dhcp, DHCP_OFF);
    3e4e:	2100      	movs	r1, #0
    3e50:	4620      	mov	r0, r4
    3e52:	4b08      	ldr	r3, [pc, #32]	; (3e74 <dhcp_stop+0x4c>)
    3e54:	4798      	blx	r3
    3e56:	bd10      	pop	{r4, pc}
	LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    3e58:	4b07      	ldr	r3, [pc, #28]	; (3e78 <dhcp_stop+0x50>)
    3e5a:	f240 42cc 	movw	r2, #1228	; 0x4cc
    3e5e:	4907      	ldr	r1, [pc, #28]	; (3e7c <dhcp_stop+0x54>)
    3e60:	4807      	ldr	r0, [pc, #28]	; (3e80 <dhcp_stop+0x58>)
    3e62:	4c08      	ldr	r4, [pc, #32]	; (3e84 <dhcp_stop+0x5c>)
    3e64:	47a0      	blx	r4
    3e66:	e7fe      	b.n	3e66 <dhcp_stop+0x3e>
    3e68:	0000b944 	.word	0x0000b944
    3e6c:	000098fd 	.word	0x000098fd
    3e70:	0000869d 	.word	0x0000869d
    3e74:	0000271d 	.word	0x0000271d
    3e78:	0000aac4 	.word	0x0000aac4
    3e7c:	0000b928 	.word	0x0000b928
    3e80:	0000ab0c 	.word	0x0000ab0c
    3e84:	00009815 	.word	0x00009815

00003e88 <dhcp_start>:
{
    3e88:	b570      	push	{r4, r5, r6, lr}
    3e8a:	b082      	sub	sp, #8
	LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    3e8c:	2800      	cmp	r0, #0
    3e8e:	d052      	beq.n	3f36 <dhcp_start+0xae>
    3e90:	4604      	mov	r4, r0
	dhcp = netif->dhcp;
    3e92:	6a85      	ldr	r5, [r0, #40]	; 0x28
	LWIP_DEBUGF(
    3e94:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    3e98:	f890 2036 	ldrb.w	r2, [r0, #54]	; 0x36
    3e9c:	f890 1038 	ldrb.w	r1, [r0, #56]	; 0x38
    3ea0:	9100      	str	r1, [sp, #0]
    3ea2:	4601      	mov	r1, r0
    3ea4:	483d      	ldr	r0, [pc, #244]	; (3f9c <dhcp_start+0x114>)
    3ea6:	4e3e      	ldr	r6, [pc, #248]	; (3fa0 <dhcp_start+0x118>)
    3ea8:	47b0      	blx	r6
	netif->flags &= ~NETIF_FLAG_DHCP;
    3eaa:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    3eae:	f023 0208 	bic.w	r2, r3, #8
    3eb2:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
	if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
    3eb6:	f013 0f20 	tst.w	r3, #32
    3eba:	d044      	beq.n	3f46 <dhcp_start+0xbe>
	if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
    3ebc:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    3ebe:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
    3ec2:	d346      	bcc.n	3f52 <dhcp_start+0xca>
	if (dhcp == NULL) {
    3ec4:	2d00      	cmp	r5, #0
    3ec6:	d04a      	beq.n	3f5e <dhcp_start+0xd6>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    3ec8:	4836      	ldr	r0, [pc, #216]	; (3fa4 <dhcp_start+0x11c>)
    3eca:	4b37      	ldr	r3, [pc, #220]	; (3fa8 <dhcp_start+0x120>)
    3ecc:	4798      	blx	r3
		if (dhcp->pcb != NULL) {
    3ece:	6868      	ldr	r0, [r5, #4]
    3ed0:	b108      	cbz	r0, 3ed6 <dhcp_start+0x4e>
			udp_remove(dhcp->pcb);
    3ed2:	4b36      	ldr	r3, [pc, #216]	; (3fac <dhcp_start+0x124>)
    3ed4:	4798      	blx	r3
	memset(dhcp, 0, sizeof(struct dhcp));
    3ed6:	223c      	movs	r2, #60	; 0x3c
    3ed8:	2100      	movs	r1, #0
    3eda:	4628      	mov	r0, r5
    3edc:	4b34      	ldr	r3, [pc, #208]	; (3fb0 <dhcp_start+0x128>)
    3ede:	4798      	blx	r3
	dhcp->pcb = udp_new();
    3ee0:	4b34      	ldr	r3, [pc, #208]	; (3fb4 <dhcp_start+0x12c>)
    3ee2:	4798      	blx	r3
    3ee4:	6068      	str	r0, [r5, #4]
	if (dhcp->pcb == NULL) {
    3ee6:	2800      	cmp	r0, #0
    3ee8:	d04c      	beq.n	3f84 <dhcp_start+0xfc>
	ip_set_option(dhcp->pcb, SOF_BROADCAST);
    3eea:	7a03      	ldrb	r3, [r0, #8]
    3eec:	f043 0320 	orr.w	r3, r3, #32
    3ef0:	7203      	strb	r3, [r0, #8]
	udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    3ef2:	4e31      	ldr	r6, [pc, #196]	; (3fb8 <dhcp_start+0x130>)
    3ef4:	2244      	movs	r2, #68	; 0x44
    3ef6:	4631      	mov	r1, r6
    3ef8:	6868      	ldr	r0, [r5, #4]
    3efa:	4b30      	ldr	r3, [pc, #192]	; (3fbc <dhcp_start+0x134>)
    3efc:	4798      	blx	r3
	udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
    3efe:	2243      	movs	r2, #67	; 0x43
    3f00:	4631      	mov	r1, r6
    3f02:	6868      	ldr	r0, [r5, #4]
    3f04:	4b2e      	ldr	r3, [pc, #184]	; (3fc0 <dhcp_start+0x138>)
    3f06:	4798      	blx	r3
	udp_recv(dhcp->pcb, dhcp_recv, netif);
    3f08:	4622      	mov	r2, r4
    3f0a:	492e      	ldr	r1, [pc, #184]	; (3fc4 <dhcp_start+0x13c>)
    3f0c:	6868      	ldr	r0, [r5, #4]
    3f0e:	4b2e      	ldr	r3, [pc, #184]	; (3fc8 <dhcp_start+0x140>)
    3f10:	4798      	blx	r3
	LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
    3f12:	482e      	ldr	r0, [pc, #184]	; (3fcc <dhcp_start+0x144>)
    3f14:	4b24      	ldr	r3, [pc, #144]	; (3fa8 <dhcp_start+0x120>)
    3f16:	4798      	blx	r3
	result = dhcp_discover(netif);
    3f18:	4620      	mov	r0, r4
    3f1a:	4b2d      	ldr	r3, [pc, #180]	; (3fd0 <dhcp_start+0x148>)
    3f1c:	4798      	blx	r3
	if (result != ERR_OK) {
    3f1e:	4603      	mov	r3, r0
    3f20:	2800      	cmp	r0, #0
    3f22:	d135      	bne.n	3f90 <dhcp_start+0x108>
	netif->flags |= NETIF_FLAG_DHCP;
    3f24:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
    3f28:	f042 0208 	orr.w	r2, r2, #8
    3f2c:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
}
    3f30:	4618      	mov	r0, r3
    3f32:	b002      	add	sp, #8
    3f34:	bd70      	pop	{r4, r5, r6, pc}
	LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    3f36:	4b27      	ldr	r3, [pc, #156]	; (3fd4 <dhcp_start+0x14c>)
    3f38:	f240 227a 	movw	r2, #634	; 0x27a
    3f3c:	4926      	ldr	r1, [pc, #152]	; (3fd8 <dhcp_start+0x150>)
    3f3e:	4827      	ldr	r0, [pc, #156]	; (3fdc <dhcp_start+0x154>)
    3f40:	4c17      	ldr	r4, [pc, #92]	; (3fa0 <dhcp_start+0x118>)
    3f42:	47a0      	blx	r4
    3f44:	e7fe      	b.n	3f44 <dhcp_start+0xbc>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): No ETHARP netif\n"));
    3f46:	4826      	ldr	r0, [pc, #152]	; (3fe0 <dhcp_start+0x158>)
    3f48:	4b17      	ldr	r3, [pc, #92]	; (3fa8 <dhcp_start+0x120>)
    3f4a:	4798      	blx	r3
		return ERR_ARG;
    3f4c:	f06f 030d 	mvn.w	r3, #13
    3f50:	e7ee      	b.n	3f30 <dhcp_start+0xa8>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    3f52:	4824      	ldr	r0, [pc, #144]	; (3fe4 <dhcp_start+0x15c>)
    3f54:	4b14      	ldr	r3, [pc, #80]	; (3fa8 <dhcp_start+0x120>)
    3f56:	4798      	blx	r3
		return ERR_MEM;
    3f58:	f04f 33ff 	mov.w	r3, #4294967295
    3f5c:	e7e8      	b.n	3f30 <dhcp_start+0xa8>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    3f5e:	4822      	ldr	r0, [pc, #136]	; (3fe8 <dhcp_start+0x160>)
    3f60:	4b11      	ldr	r3, [pc, #68]	; (3fa8 <dhcp_start+0x120>)
    3f62:	4798      	blx	r3
		dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
    3f64:	203c      	movs	r0, #60	; 0x3c
    3f66:	4b21      	ldr	r3, [pc, #132]	; (3fec <dhcp_start+0x164>)
    3f68:	4798      	blx	r3
		if (dhcp == NULL) {
    3f6a:	4605      	mov	r5, r0
    3f6c:	b120      	cbz	r0, 3f78 <dhcp_start+0xf0>
		netif->dhcp = dhcp;
    3f6e:	62a0      	str	r0, [r4, #40]	; 0x28
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
    3f70:	481f      	ldr	r0, [pc, #124]	; (3ff0 <dhcp_start+0x168>)
    3f72:	4b0b      	ldr	r3, [pc, #44]	; (3fa0 <dhcp_start+0x118>)
    3f74:	4798      	blx	r3
    3f76:	e7ae      	b.n	3ed6 <dhcp_start+0x4e>
			LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
    3f78:	481e      	ldr	r0, [pc, #120]	; (3ff4 <dhcp_start+0x16c>)
    3f7a:	4b0b      	ldr	r3, [pc, #44]	; (3fa8 <dhcp_start+0x120>)
    3f7c:	4798      	blx	r3
			return ERR_MEM;
    3f7e:	f04f 33ff 	mov.w	r3, #4294967295
    3f82:	e7d5      	b.n	3f30 <dhcp_start+0xa8>
		LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    3f84:	481c      	ldr	r0, [pc, #112]	; (3ff8 <dhcp_start+0x170>)
    3f86:	4b08      	ldr	r3, [pc, #32]	; (3fa8 <dhcp_start+0x120>)
    3f88:	4798      	blx	r3
		return ERR_MEM;
    3f8a:	f04f 33ff 	mov.w	r3, #4294967295
    3f8e:	e7cf      	b.n	3f30 <dhcp_start+0xa8>
		dhcp_stop(netif);
    3f90:	4620      	mov	r0, r4
    3f92:	4b1a      	ldr	r3, [pc, #104]	; (3ffc <dhcp_start+0x174>)
    3f94:	4798      	blx	r3
		return ERR_MEM;
    3f96:	f04f 33ff 	mov.w	r3, #4294967295
    3f9a:	e7c9      	b.n	3f30 <dhcp_start+0xa8>
    3f9c:	0000b950 	.word	0x0000b950
    3fa0:	00009815 	.word	0x00009815
    3fa4:	0000ba40 	.word	0x0000ba40
    3fa8:	000098fd 	.word	0x000098fd
    3fac:	0000869d 	.word	0x0000869d
    3fb0:	00009805 	.word	0x00009805
    3fb4:	000086d9 	.word	0x000086d9
    3fb8:	0000bac0 	.word	0x0000bac0
    3fbc:	00008415 	.word	0x00008415
    3fc0:	00008635 	.word	0x00008635
    3fc4:	00003091 	.word	0x00003091
    3fc8:	00008695 	.word	0x00008695
    3fcc:	0000ba90 	.word	0x0000ba90
    3fd0:	00002af1 	.word	0x00002af1
    3fd4:	0000aac4 	.word	0x0000aac4
    3fd8:	0000b418 	.word	0x0000b418
    3fdc:	0000ab0c 	.word	0x0000ab0c
    3fe0:	0000b970 	.word	0x0000b970
    3fe4:	0000b990 	.word	0x0000b990
    3fe8:	0000b9d0 	.word	0x0000b9d0
    3fec:	0000506d 	.word	0x0000506d
    3ff0:	0000ba20 	.word	0x0000ba20
    3ff4:	0000b9f8 	.word	0x0000b9f8
    3ff8:	0000ba6c 	.word	0x0000ba6c
    3ffc:	00003e29 	.word	0x00003e29

00004000 <lwip_init>:

/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void lwip_init(void)
{
    4000:	b508      	push	{r3, lr}
	/* Modules initialization */
	stats_init();
#if !NO_SYS
	sys_init();
#endif /* !NO_SYS */
	mem_init();
    4002:	4b06      	ldr	r3, [pc, #24]	; (401c <lwip_init+0x1c>)
    4004:	4798      	blx	r3
	memp_init();
    4006:	4b06      	ldr	r3, [pc, #24]	; (4020 <lwip_init+0x20>)
    4008:	4798      	blx	r3
	pbuf_init();
	netif_init();
    400a:	4b06      	ldr	r3, [pc, #24]	; (4024 <lwip_init+0x24>)
    400c:	4798      	blx	r3
#endif /* LWIP_ARP */
#if LWIP_RAW
	raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
	udp_init();
    400e:	4b06      	ldr	r3, [pc, #24]	; (4028 <lwip_init+0x28>)
    4010:	4798      	blx	r3
#endif /* LWIP_UDP */
#if LWIP_TCP
	tcp_init();
    4012:	4b06      	ldr	r3, [pc, #24]	; (402c <lwip_init+0x2c>)
    4014:	4798      	blx	r3
#if LWIP_DNS
	dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
	sys_timeouts_init();
    4016:	4b06      	ldr	r3, [pc, #24]	; (4030 <lwip_init+0x30>)
    4018:	4798      	blx	r3
    401a:	bd08      	pop	{r3, pc}
    401c:	00004ee5 	.word	0x00004ee5
    4020:	00005141 	.word	0x00005141
    4024:	00005219 	.word	0x00005219
    4028:	00008221 	.word	0x00008221
    402c:	00005969 	.word	0x00005969
    4030:	000080e1 	.word	0x000080e1

00004034 <icmp_send_response>:
 *          p->payload pointing to the IP header
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
    4034:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4038:	b085      	sub	sp, #20
    403a:	4680      	mov	r8, r0
    403c:	4689      	mov	r9, r1
    403e:	4615      	mov	r5, r2
	/* we can use the echo header here */
	struct icmp_echo_hdr *icmphdr;
	ip_addr_t             iphdr_src;

	/* ICMP header + IP header + 8 bytes of data */
	q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE, PBUF_RAM);
    4040:	2200      	movs	r2, #0
    4042:	2124      	movs	r1, #36	; 0x24
    4044:	2001      	movs	r0, #1
    4046:	4b22      	ldr	r3, [pc, #136]	; (40d0 <icmp_send_response+0x9c>)
    4048:	4798      	blx	r3
	if (q == NULL) {
    404a:	2800      	cmp	r0, #0
    404c:	d03d      	beq.n	40ca <icmp_send_response+0x96>
    404e:	4606      	mov	r6, r0
		return;
	}
	LWIP_ASSERT("check that first pbuf can hold icmp message",
	            (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

	iphdr = (struct ip_hdr *)p->payload;
    4050:	f8d8 7004 	ldr.w	r7, [r8, #4]
	ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
	LWIP_DEBUGF(ICMP_DEBUG, (" to "));
	ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
	LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

	icmphdr        = (struct icmp_echo_hdr *)q->payload;
    4054:	6844      	ldr	r4, [r0, #4]
	icmphdr->type  = type;
    4056:	f884 9000 	strb.w	r9, [r4]
	icmphdr->code  = code;
    405a:	7065      	strb	r5, [r4, #1]
	icmphdr->id    = 0;
    405c:	2500      	movs	r5, #0
    405e:	7125      	strb	r5, [r4, #4]
    4060:	7165      	strb	r5, [r4, #5]
	icmphdr->seqno = 0;
    4062:	71a5      	strb	r5, [r4, #6]
    4064:	71e5      	strb	r5, [r4, #7]

	/* copy fields from original packet */
	SMEMCPY(
    4066:	f8d0 c004 	ldr.w	ip, [r0, #4]
    406a:	f8d8 3004 	ldr.w	r3, [r8, #4]
    406e:	f8d3 e000 	ldr.w	lr, [r3]
    4072:	6858      	ldr	r0, [r3, #4]
    4074:	6899      	ldr	r1, [r3, #8]
    4076:	f8d3 800c 	ldr.w	r8, [r3, #12]
    407a:	f8cc e008 	str.w	lr, [ip, #8]
    407e:	f8cc 000c 	str.w	r0, [ip, #12]
    4082:	f8cc 1010 	str.w	r1, [ip, #16]
    4086:	f8cc 8014 	str.w	r8, [ip, #20]
    408a:	f8d3 e010 	ldr.w	lr, [r3, #16]
    408e:	6958      	ldr	r0, [r3, #20]
    4090:	6999      	ldr	r1, [r3, #24]
    4092:	f8cc e018 	str.w	lr, [ip, #24]
    4096:	f8cc 001c 	str.w	r0, [ip, #28]
    409a:	f8cc 1020 	str.w	r1, [ip, #32]
	    (u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload, IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

	/* calculate checksum */
	icmphdr->chksum = 0;
    409e:	70a5      	strb	r5, [r4, #2]
    40a0:	70e5      	strb	r5, [r4, #3]
	icmphdr->chksum = inet_chksum(icmphdr, q->len);
    40a2:	8971      	ldrh	r1, [r6, #10]
    40a4:	4620      	mov	r0, r4
    40a6:	4b0b      	ldr	r3, [pc, #44]	; (40d4 <icmp_send_response+0xa0>)
    40a8:	4798      	blx	r3
    40aa:	8060      	strh	r0, [r4, #2]
	ICMP_STATS_INC(icmp.xmit);
	/* increase number of messages attempted to send */
	snmp_inc_icmpoutmsgs();
	/* increase number of destination unreachable messages attempted to send */
	snmp_inc_icmpouttimeexcds();
	ip_addr_copy(iphdr_src, iphdr->src);
    40ac:	68fb      	ldr	r3, [r7, #12]
    40ae:	aa04      	add	r2, sp, #16
    40b0:	f842 3d04 	str.w	r3, [r2, #-4]!
	ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
    40b4:	2301      	movs	r3, #1
    40b6:	9301      	str	r3, [sp, #4]
    40b8:	9500      	str	r5, [sp, #0]
    40ba:	23ff      	movs	r3, #255	; 0xff
    40bc:	4629      	mov	r1, r5
    40be:	4630      	mov	r0, r6
    40c0:	4c05      	ldr	r4, [pc, #20]	; (40d8 <icmp_send_response+0xa4>)
    40c2:	47a0      	blx	r4
	pbuf_free(q);
    40c4:	4630      	mov	r0, r6
    40c6:	4b05      	ldr	r3, [pc, #20]	; (40dc <icmp_send_response+0xa8>)
    40c8:	4798      	blx	r3
}
    40ca:	b005      	add	sp, #20
    40cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    40d0:	00005531 	.word	0x00005531
    40d4:	00004369 	.word	0x00004369
    40d8:	000046f9 	.word	0x000046f9
    40dc:	000054c9 	.word	0x000054c9

000040e0 <icmp_input>:
{
    40e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    40e4:	b085      	sub	sp, #20
    40e6:	4606      	mov	r6, r0
    40e8:	4688      	mov	r8, r1
	iphdr = (struct ip_hdr *)p->payload;
    40ea:	6847      	ldr	r7, [r0, #4]
	hlen  = IPH_HL(iphdr) * 4;
    40ec:	783c      	ldrb	r4, [r7, #0]
    40ee:	f004 040f 	and.w	r4, r4, #15
    40f2:	00a4      	lsls	r4, r4, #2
	if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t) * 2)) {
    40f4:	4265      	negs	r5, r4
    40f6:	b22d      	sxth	r5, r5
    40f8:	4629      	mov	r1, r5
    40fa:	4b45      	ldr	r3, [pc, #276]	; (4210 <icmp_input+0x130>)
    40fc:	4798      	blx	r3
    40fe:	b9a0      	cbnz	r0, 412a <icmp_input+0x4a>
    4100:	8933      	ldrh	r3, [r6, #8]
    4102:	2b03      	cmp	r3, #3
    4104:	d911      	bls.n	412a <icmp_input+0x4a>
	type = *((u8_t *)p->payload);
    4106:	6873      	ldr	r3, [r6, #4]
	switch (type) {
    4108:	781b      	ldrb	r3, [r3, #0]
    410a:	2b08      	cmp	r3, #8
    410c:	d16f      	bne.n	41ee <icmp_input+0x10e>
		if (ip_addr_ismulticast(&current_iphdr_dest)) {
    410e:	4b41      	ldr	r3, [pc, #260]	; (4214 <icmp_input+0x134>)
    4110:	6818      	ldr	r0, [r3, #0]
    4112:	f000 09f0 	and.w	r9, r0, #240	; 0xf0
		if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
    4116:	4641      	mov	r1, r8
    4118:	4b3f      	ldr	r3, [pc, #252]	; (4218 <icmp_input+0x138>)
    411a:	4798      	blx	r3
    411c:	b958      	cbnz	r0, 4136 <icmp_input+0x56>
		if (!accepted) {
    411e:	f1b9 0fe0 	cmp.w	r9, #224	; 0xe0
    4122:	d008      	beq.n	4136 <icmp_input+0x56>
		if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
    4124:	8933      	ldrh	r3, [r6, #8]
    4126:	2b07      	cmp	r3, #7
    4128:	d809      	bhi.n	413e <icmp_input+0x5e>
	pbuf_free(p);
    412a:	4630      	mov	r0, r6
    412c:	4b3b      	ldr	r3, [pc, #236]	; (421c <icmp_input+0x13c>)
    412e:	4798      	blx	r3
}
    4130:	b005      	add	sp, #20
    4132:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			pbuf_free(p);
    4136:	4630      	mov	r0, r6
    4138:	4b38      	ldr	r3, [pc, #224]	; (421c <icmp_input+0x13c>)
    413a:	4798      	blx	r3
			return;
    413c:	e7f8      	b.n	4130 <icmp_input+0x50>
		if (inet_chksum_pbuf(p) != 0) {
    413e:	4630      	mov	r0, r6
    4140:	4b37      	ldr	r3, [pc, #220]	; (4220 <icmp_input+0x140>)
    4142:	4798      	blx	r3
    4144:	b970      	cbnz	r0, 4164 <icmp_input+0x84>
	hlen  = IPH_HL(iphdr) * 4;
    4146:	b224      	sxth	r4, r4
		if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    4148:	2122      	movs	r1, #34	; 0x22
    414a:	4630      	mov	r0, r6
    414c:	4b30      	ldr	r3, [pc, #192]	; (4210 <icmp_input+0x130>)
    414e:	4798      	blx	r3
    4150:	b330      	cbz	r0, 41a0 <icmp_input+0xc0>
			if (pbuf_header(p, hlen)) {
    4152:	4621      	mov	r1, r4
    4154:	4630      	mov	r0, r6
    4156:	4b2e      	ldr	r3, [pc, #184]	; (4210 <icmp_input+0x130>)
    4158:	4798      	blx	r3
    415a:	b138      	cbz	r0, 416c <icmp_input+0x8c>
	pbuf_free(p);
    415c:	4630      	mov	r0, r6
    415e:	4b2f      	ldr	r3, [pc, #188]	; (421c <icmp_input+0x13c>)
    4160:	4798      	blx	r3
	return;
    4162:	e7e5      	b.n	4130 <icmp_input+0x50>
			pbuf_free(p);
    4164:	4630      	mov	r0, r6
    4166:	4b2d      	ldr	r3, [pc, #180]	; (421c <icmp_input+0x13c>)
    4168:	4798      	blx	r3
			return;
    416a:	e7e1      	b.n	4130 <icmp_input+0x50>
			r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
    416c:	2200      	movs	r2, #0
    416e:	8931      	ldrh	r1, [r6, #8]
    4170:	2002      	movs	r0, #2
    4172:	4b2c      	ldr	r3, [pc, #176]	; (4224 <icmp_input+0x144>)
    4174:	4798      	blx	r3
			if (r == NULL) {
    4176:	4681      	mov	r9, r0
    4178:	2800      	cmp	r0, #0
    417a:	d0ef      	beq.n	415c <icmp_input+0x7c>
			if (pbuf_copy(r, p) != ERR_OK) {
    417c:	4631      	mov	r1, r6
    417e:	4b2a      	ldr	r3, [pc, #168]	; (4228 <icmp_input+0x148>)
    4180:	4798      	blx	r3
    4182:	2800      	cmp	r0, #0
    4184:	d1ea      	bne.n	415c <icmp_input+0x7c>
			iphdr = (struct ip_hdr *)r->payload;
    4186:	f8d9 7004 	ldr.w	r7, [r9, #4]
			if (pbuf_header(r, -hlen)) {
    418a:	4629      	mov	r1, r5
    418c:	4648      	mov	r0, r9
    418e:	4b20      	ldr	r3, [pc, #128]	; (4210 <icmp_input+0x130>)
    4190:	4798      	blx	r3
    4192:	2800      	cmp	r0, #0
    4194:	d1e2      	bne.n	415c <icmp_input+0x7c>
			pbuf_free(p);
    4196:	4630      	mov	r0, r6
    4198:	4b20      	ldr	r3, [pc, #128]	; (421c <icmp_input+0x13c>)
    419a:	4798      	blx	r3
			p = r;
    419c:	464e      	mov	r6, r9
    419e:	e006      	b.n	41ae <icmp_input+0xce>
			if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    41a0:	f06f 0121 	mvn.w	r1, #33	; 0x21
    41a4:	4630      	mov	r0, r6
    41a6:	4b1a      	ldr	r3, [pc, #104]	; (4210 <icmp_input+0x130>)
    41a8:	4798      	blx	r3
    41aa:	2800      	cmp	r0, #0
    41ac:	d1d6      	bne.n	415c <icmp_input+0x7c>
		iecho = (struct icmp_echo_hdr *)p->payload;
    41ae:	6872      	ldr	r2, [r6, #4]
		ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    41b0:	4b18      	ldr	r3, [pc, #96]	; (4214 <icmp_input+0x134>)
    41b2:	681b      	ldr	r3, [r3, #0]
    41b4:	60fb      	str	r3, [r7, #12]
		ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    41b6:	4b1d      	ldr	r3, [pc, #116]	; (422c <icmp_input+0x14c>)
    41b8:	681b      	ldr	r3, [r3, #0]
    41ba:	613b      	str	r3, [r7, #16]
		ICMPH_TYPE_SET(iecho, ICMP_ER);
    41bc:	2300      	movs	r3, #0
    41be:	7013      	strb	r3, [r2, #0]
		if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
    41c0:	8853      	ldrh	r3, [r2, #2]
    41c2:	f64f 71f6 	movw	r1, #65526	; 0xfff6
    41c6:	428b      	cmp	r3, r1
			iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
    41c8:	bf8c      	ite	hi
    41ca:	3309      	addhi	r3, #9
			iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
    41cc:	3308      	addls	r3, #8
    41ce:	8053      	strh	r3, [r2, #2]
		IPH_TTL_SET(iphdr, ICMP_TTL);
    41d0:	23ff      	movs	r3, #255	; 0xff
    41d2:	723b      	strb	r3, [r7, #8]
		IPH_CHKSUM_SET(iphdr, 0);
    41d4:	2300      	movs	r3, #0
    41d6:	72bb      	strb	r3, [r7, #10]
    41d8:	72fb      	strb	r3, [r7, #11]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    41da:	2114      	movs	r1, #20
    41dc:	4638      	mov	r0, r7
    41de:	4b14      	ldr	r3, [pc, #80]	; (4230 <icmp_input+0x150>)
    41e0:	4798      	blx	r3
    41e2:	8178      	strh	r0, [r7, #10]
		if (pbuf_header(p, hlen)) {
    41e4:	4621      	mov	r1, r4
    41e6:	4630      	mov	r0, r6
    41e8:	4b09      	ldr	r3, [pc, #36]	; (4210 <icmp_input+0x130>)
    41ea:	4798      	blx	r3
    41ec:	b118      	cbz	r0, 41f6 <icmp_input+0x116>
	pbuf_free(p);
    41ee:	4630      	mov	r0, r6
    41f0:	4b0a      	ldr	r3, [pc, #40]	; (421c <icmp_input+0x13c>)
    41f2:	4798      	blx	r3
	return;
    41f4:	e79c      	b.n	4130 <icmp_input+0x50>
			ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL, ICMP_TTL, 0, IP_PROTO_ICMP, inp);
    41f6:	f8cd 8008 	str.w	r8, [sp, #8]
    41fa:	2301      	movs	r3, #1
    41fc:	9301      	str	r3, [sp, #4]
    41fe:	2200      	movs	r2, #0
    4200:	9200      	str	r2, [sp, #0]
    4202:	23ff      	movs	r3, #255	; 0xff
    4204:	4903      	ldr	r1, [pc, #12]	; (4214 <icmp_input+0x134>)
    4206:	4630      	mov	r0, r6
    4208:	4c0a      	ldr	r4, [pc, #40]	; (4234 <icmp_input+0x154>)
    420a:	47a0      	blx	r4
    420c:	e7ef      	b.n	41ee <icmp_input+0x10e>
    420e:	bf00      	nop
    4210:	00005435 	.word	0x00005435
    4214:	20008314 	.word	0x20008314
    4218:	00004739 	.word	0x00004739
    421c:	000054c9 	.word	0x000054c9
    4220:	00004379 	.word	0x00004379
    4224:	00005531 	.word	0x00005531
    4228:	00005755 	.word	0x00005755
    422c:	2000830c 	.word	0x2000830c
    4230:	00004369 	.word	0x00004369
    4234:	000045fd 	.word	0x000045fd

00004238 <icmp_dest_unreach>:
{
    4238:	b508      	push	{r3, lr}
	icmp_send_response(p, ICMP_DUR, t);
    423a:	460a      	mov	r2, r1
    423c:	2103      	movs	r1, #3
    423e:	4b01      	ldr	r3, [pc, #4]	; (4244 <icmp_dest_unreach+0xc>)
    4240:	4798      	blx	r3
    4242:	bd08      	pop	{r3, pc}
    4244:	00004035 	.word	0x00004035

00004248 <icmp_time_exceeded>:
{
    4248:	b508      	push	{r3, lr}
	icmp_send_response(p, ICMP_TE, t);
    424a:	460a      	mov	r2, r1
    424c:	210b      	movs	r1, #11
    424e:	4b01      	ldr	r3, [pc, #4]	; (4254 <icmp_time_exceeded+0xc>)
    4250:	4798      	blx	r3
    4252:	bd08      	pop	{r3, pc}
    4254:	00004035 	.word	0x00004035

00004258 <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */

static u16_t lwip_standard_chksum(void *dataptr, int len)
{
    4258:	b410      	push	{r4}
    425a:	b083      	sub	sp, #12
	u8_t * pb = (u8_t *)dataptr;
	u16_t *ps, t = 0;
    425c:	2300      	movs	r3, #0
    425e:	f8ad 3006 	strh.w	r3, [sp, #6]
	u32_t  sum = 0;
	int    odd = ((mem_ptr_t)pb & 1);

	/* Get aligned to u16_t */
	if (odd && len > 0) {
    4262:	f010 0401 	ands.w	r4, r0, #1
    4266:	d007      	beq.n	4278 <lwip_standard_chksum+0x20>
    4268:	4299      	cmp	r1, r3
    426a:	dd2a      	ble.n	42c2 <lwip_standard_chksum+0x6a>
		((u8_t *)&t)[1] = *pb++;
    426c:	1c43      	adds	r3, r0, #1
    426e:	7802      	ldrb	r2, [r0, #0]
    4270:	f88d 2007 	strb.w	r2, [sp, #7]
		len--;
    4274:	3901      	subs	r1, #1
    4276:	e000      	b.n	427a <lwip_standard_chksum+0x22>
	u8_t * pb = (u8_t *)dataptr;
    4278:	4603      	mov	r3, r0
	}

	/* Add the bulk of the data */
	ps = (u16_t *)(void *)pb;
	while (len > 1) {
    427a:	2901      	cmp	r1, #1
    427c:	dd1f      	ble.n	42be <lwip_standard_chksum+0x66>
	u8_t * pb = (u8_t *)dataptr;
    427e:	2200      	movs	r2, #0
		sum += *ps++;
    4280:	f833 0b02 	ldrh.w	r0, [r3], #2
    4284:	4402      	add	r2, r0
		len -= 2;
    4286:	3902      	subs	r1, #2
	while (len > 1) {
    4288:	2901      	cmp	r1, #1
    428a:	dcf9      	bgt.n	4280 <lwip_standard_chksum+0x28>
	}

	/* Consume left-over byte, if any */
	if (len > 0) {
    428c:	2900      	cmp	r1, #0
		((u8_t *)&t)[0] = *(u8_t *)ps;
    428e:	bfc4      	itt	gt
    4290:	781b      	ldrbgt	r3, [r3, #0]
    4292:	f88d 3006 	strbgt.w	r3, [sp, #6]
	}

	/* Add end bytes */
	sum += t;
    4296:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    429a:	4402      	add	r2, r0

	/* Fold 32-bit sum to 16 bits
	   calling this twice is propably faster than if statements... */
	sum = FOLD_U32T(sum);
    429c:	b290      	uxth	r0, r2
    429e:	eb00 4212 	add.w	r2, r0, r2, lsr #16
	sum = FOLD_U32T(sum);
    42a2:	b290      	uxth	r0, r2
    42a4:	eb00 4012 	add.w	r0, r0, r2, lsr #16

	/* Swap if alignment was odd */
	if (odd) {
    42a8:	b124      	cbz	r4, 42b4 <lwip_standard_chksum+0x5c>
		sum = SWAP_BYTES_IN_WORD(sum);
    42aa:	0203      	lsls	r3, r0, #8
    42ac:	b29b      	uxth	r3, r3
    42ae:	f3c0 2007 	ubfx	r0, r0, #8, #8
    42b2:	4318      	orrs	r0, r3
	}

	return (u16_t)sum;
    42b4:	b280      	uxth	r0, r0
}
    42b6:	b003      	add	sp, #12
    42b8:	f85d 4b04 	ldr.w	r4, [sp], #4
    42bc:	4770      	bx	lr
	u32_t  sum = 0;
    42be:	2200      	movs	r2, #0
    42c0:	e7e4      	b.n	428c <lwip_standard_chksum+0x34>
	while (len > 1) {
    42c2:	2901      	cmp	r1, #1
	u8_t * pb = (u8_t *)dataptr;
    42c4:	bfc8      	it	gt
    42c6:	4603      	movgt	r3, r0
	while (len > 1) {
    42c8:	dcd9      	bgt.n	427e <lwip_standard_chksum+0x26>
	sum = FOLD_U32T(sum);
    42ca:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    42ce:	e7ec      	b.n	42aa <lwip_standard_chksum+0x52>

000042d0 <inet_chksum_pseudo>:
 * @param proto ip protocol (used for checksum of pseudo header)
 * @param proto_len length of the ip data part (used for checksum of pseudo header)
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t inet_chksum_pseudo(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t proto, u16_t proto_len)
{
    42d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    42d4:	468a      	mov	sl, r1
    42d6:	4691      	mov	r9, r2
    42d8:	4698      	mov	r8, r3
	u8_t         swapped;

	acc     = 0;
	swapped = 0;
	/* iterate through all pbuf in chain */
	for (q = p; q != NULL; q = q->next) {
    42da:	2800      	cmp	r0, #0
    42dc:	d03e      	beq.n	435c <inet_chksum_pseudo+0x8c>
    42de:	4605      	mov	r5, r0
    42e0:	2600      	movs	r6, #0
    42e2:	4634      	mov	r4, r6
		LWIP_DEBUGF(INET_DEBUG,
		            ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n", (void *)q, (void *)q->next));
		acc += LWIP_CHKSUM(q->payload, q->len);
    42e4:	4f1e      	ldr	r7, [pc, #120]	; (4360 <inet_chksum_pseudo+0x90>)
    42e6:	e001      	b.n	42ec <inet_chksum_pseudo+0x1c>
	for (q = p; q != NULL; q = q->next) {
    42e8:	682d      	ldr	r5, [r5, #0]
    42ea:	b19d      	cbz	r5, 4314 <inet_chksum_pseudo+0x44>
		acc += LWIP_CHKSUM(q->payload, q->len);
    42ec:	8969      	ldrh	r1, [r5, #10]
    42ee:	6868      	ldr	r0, [r5, #4]
    42f0:	47b8      	blx	r7
    42f2:	4404      	add	r4, r0
		/*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
		/* just executing this next line is probably faster that the if statement needed
		   to check whether we really need to execute it, and does no harm */
		acc = FOLD_U32T(acc);
    42f4:	b2a0      	uxth	r0, r4
    42f6:	eb00 4414 	add.w	r4, r0, r4, lsr #16
		if (q->len % 2 != 0) {
    42fa:	896b      	ldrh	r3, [r5, #10]
    42fc:	f013 0f01 	tst.w	r3, #1
    4300:	d0f2      	beq.n	42e8 <inet_chksum_pseudo+0x18>
			swapped = 1 - swapped;
    4302:	f1c6 0601 	rsb	r6, r6, #1
    4306:	b2f6      	uxtb	r6, r6
			acc     = SWAP_BYTES_IN_WORD(acc);
    4308:	0223      	lsls	r3, r4, #8
    430a:	b29b      	uxth	r3, r3
    430c:	f3c4 2407 	ubfx	r4, r4, #8, #8
    4310:	431c      	orrs	r4, r3
    4312:	e7e9      	b.n	42e8 <inet_chksum_pseudo+0x18>
		}
		/*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
	}

	if (swapped) {
    4314:	b126      	cbz	r6, 4320 <inet_chksum_pseudo+0x50>
		acc = SWAP_BYTES_IN_WORD(acc);
    4316:	0223      	lsls	r3, r4, #8
    4318:	b29b      	uxth	r3, r3
    431a:	f3c4 2407 	ubfx	r4, r4, #8, #8
    431e:	431c      	orrs	r4, r3
	}
	addr = ip4_addr_get_u32(src);
    4320:	f8da 2000 	ldr.w	r2, [sl]
	acc += (addr & 0xffffUL);
	acc += ((addr >> 16) & 0xffffUL);
	addr = ip4_addr_get_u32(dest);
    4324:	f8d9 3000 	ldr.w	r3, [r9]
	acc += (addr & 0xffffUL);
	acc += ((addr >> 16) & 0xffffUL);
    4328:	0c18      	lsrs	r0, r3, #16
    432a:	fa10 f083 	uxtah	r0, r0, r3
    432e:	fa10 f082 	uxtah	r0, r0, r2
    4332:	eb00 4012 	add.w	r0, r0, r2, lsr #16
    4336:	4404      	add	r4, r0
	acc += (u32_t)htons((u16_t)proto);
    4338:	4640      	mov	r0, r8
    433a:	4d0a      	ldr	r5, [pc, #40]	; (4364 <inet_chksum_pseudo+0x94>)
    433c:	47a8      	blx	r5
    433e:	4404      	add	r4, r0
	acc += (u32_t)htons(proto_len);
    4340:	f8bd 0020 	ldrh.w	r0, [sp, #32]
    4344:	47a8      	blx	r5
    4346:	4420      	add	r0, r4

	/* Fold 32-bit sum to 16 bits
	   calling this twice is propably faster than if statements... */
	acc = FOLD_U32T(acc);
    4348:	b284      	uxth	r4, r0
    434a:	eb04 4410 	add.w	r4, r4, r0, lsr #16
	acc = FOLD_U32T(acc);
    434e:	b2a0      	uxth	r0, r4
    4350:	eb00 4014 	add.w	r0, r0, r4, lsr #16
	LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%" X32_F "\n", acc));
	return (u16_t) ~(acc & 0xffffUL);
    4354:	43c0      	mvns	r0, r0
}
    4356:	b280      	uxth	r0, r0
    4358:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	acc     = 0;
    435c:	2400      	movs	r4, #0
    435e:	e7df      	b.n	4320 <inet_chksum_pseudo+0x50>
    4360:	00004259 	.word	0x00004259
    4364:	000026e5 	.word	0x000026e5

00004368 <inet_chksum>:
 * @param len length of the buffer to calculate the checksum
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t inet_chksum(void *dataptr, u16_t len)
{
    4368:	b508      	push	{r3, lr}
	return ~LWIP_CHKSUM(dataptr, len);
    436a:	4b02      	ldr	r3, [pc, #8]	; (4374 <inet_chksum+0xc>)
    436c:	4798      	blx	r3
    436e:	43c0      	mvns	r0, r0
}
    4370:	b280      	uxth	r0, r0
    4372:	bd08      	pop	{r3, pc}
    4374:	00004259 	.word	0x00004259

00004378 <inet_chksum_pbuf>:
 *
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t inet_chksum_pbuf(struct pbuf *p)
{
    4378:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct pbuf *q;
	u8_t         swapped;

	acc     = 0;
	swapped = 0;
	for (q = p; q != NULL; q = q->next) {
    437a:	b318      	cbz	r0, 43c4 <inet_chksum_pbuf+0x4c>
    437c:	4605      	mov	r5, r0
    437e:	2600      	movs	r6, #0
    4380:	4634      	mov	r4, r6
		acc += LWIP_CHKSUM(q->payload, q->len);
    4382:	4f11      	ldr	r7, [pc, #68]	; (43c8 <inet_chksum_pbuf+0x50>)
    4384:	e001      	b.n	438a <inet_chksum_pbuf+0x12>
	for (q = p; q != NULL; q = q->next) {
    4386:	682d      	ldr	r5, [r5, #0]
    4388:	b19d      	cbz	r5, 43b2 <inet_chksum_pbuf+0x3a>
		acc += LWIP_CHKSUM(q->payload, q->len);
    438a:	8969      	ldrh	r1, [r5, #10]
    438c:	6868      	ldr	r0, [r5, #4]
    438e:	47b8      	blx	r7
    4390:	4420      	add	r0, r4
		acc = FOLD_U32T(acc);
    4392:	b284      	uxth	r4, r0
    4394:	eb04 4410 	add.w	r4, r4, r0, lsr #16
		if (q->len % 2 != 0) {
    4398:	896b      	ldrh	r3, [r5, #10]
    439a:	f013 0f01 	tst.w	r3, #1
    439e:	d0f2      	beq.n	4386 <inet_chksum_pbuf+0xe>
			swapped = 1 - swapped;
    43a0:	f1c6 0601 	rsb	r6, r6, #1
    43a4:	b2f6      	uxtb	r6, r6
			acc     = SWAP_BYTES_IN_WORD(acc);
    43a6:	0223      	lsls	r3, r4, #8
    43a8:	b29b      	uxth	r3, r3
    43aa:	f3c4 2407 	ubfx	r4, r4, #8, #8
    43ae:	431c      	orrs	r4, r3
    43b0:	e7e9      	b.n	4386 <inet_chksum_pbuf+0xe>
		}
	}

	if (swapped) {
    43b2:	b126      	cbz	r6, 43be <inet_chksum_pbuf+0x46>
		acc = SWAP_BYTES_IN_WORD(acc);
    43b4:	0223      	lsls	r3, r4, #8
    43b6:	b29b      	uxth	r3, r3
    43b8:	f3c4 2407 	ubfx	r4, r4, #8, #8
    43bc:	431c      	orrs	r4, r3
	}
	return (u16_t) ~(acc & 0xffffUL);
    43be:	43e0      	mvns	r0, r4
}
    43c0:	b280      	uxth	r0, r0
    43c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	acc     = 0;
    43c4:	2400      	movs	r4, #0
    43c6:	e7fa      	b.n	43be <inet_chksum_pbuf+0x46>
    43c8:	00004259 	.word	0x00004259

000043cc <ip_route>:
		return netif;
	}
#endif

	/* iterate through netifs */
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    43cc:	4b0e      	ldr	r3, [pc, #56]	; (4408 <ip_route+0x3c>)
    43ce:	681b      	ldr	r3, [r3, #0]
    43d0:	b973      	cbnz	r3, 43f0 <ip_route+0x24>
				/* return netif on which to forward IP packet */
				return netif;
			}
		}
	}
	if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    43d2:	4b0e      	ldr	r3, [pc, #56]	; (440c <ip_route+0x40>)
    43d4:	681b      	ldr	r3, [r3, #0]
    43d6:	b133      	cbz	r3, 43e6 <ip_route+0x1a>
    43d8:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
    43dc:	f002 0201 	and.w	r2, r2, #1
		             ip4_addr2_16(dest),
		             ip4_addr3_16(dest),
		             ip4_addr4_16(dest)));
		IP_STATS_INC(ip.rterr);
		snmp_inc_ipoutnoroutes();
		return NULL;
    43e0:	2a00      	cmp	r2, #0
    43e2:	bf08      	it	eq
    43e4:	2300      	moveq	r3, #0
	}
	/* no matching netif found, use default netif */
	return netif_default;
}
    43e6:	4618      	mov	r0, r3
    43e8:	4770      	bx	lr
	for (netif = netif_list; netif != NULL; netif = netif->next) {
    43ea:	681b      	ldr	r3, [r3, #0]
    43ec:	2b00      	cmp	r3, #0
    43ee:	d0f0      	beq.n	43d2 <ip_route+0x6>
		if (netif_is_up(netif)) {
    43f0:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
    43f4:	f012 0f01 	tst.w	r2, #1
    43f8:	d0f7      	beq.n	43ea <ip_route+0x1e>
			if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
    43fa:	6802      	ldr	r2, [r0, #0]
    43fc:	6859      	ldr	r1, [r3, #4]
    43fe:	404a      	eors	r2, r1
    4400:	6899      	ldr	r1, [r3, #8]
    4402:	420a      	tst	r2, r1
    4404:	d1f1      	bne.n	43ea <ip_route+0x1e>
    4406:	e7ee      	b.n	43e6 <ip_route+0x1a>
    4408:	200092d0 	.word	0x200092d0
    440c:	200092d4 	.word	0x200092d4

00004410 <ip_input>:
 * @param inp the netif on which this packet was received
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t ip_input(struct pbuf *p, struct netif *inp)
{
    4410:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4414:	4606      	mov	r6, r0

	IP_STATS_INC(ip.recv);
	snmp_inc_ipinreceives();

	/* identify the IP header */
	iphdr = (struct ip_hdr *)p->payload;
    4416:	f8d0 9004 	ldr.w	r9, [r0, #4]
	if (IPH_V(iphdr) != 4) {
    441a:	f899 5000 	ldrb.w	r5, [r9]
    441e:	092b      	lsrs	r3, r5, #4
    4420:	2b04      	cmp	r3, #4
    4422:	d004      	beq.n	442e <ip_input+0x1e>
		LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING,
		            ("IP packet dropped due to bad version number %" U16_F "\n", IPH_V(iphdr)));
		ip_debug_print(p);
		pbuf_free(p);
    4424:	4b65      	ldr	r3, [pc, #404]	; (45bc <ip_input+0x1ac>)
    4426:	4798      	blx	r3
	current_header = NULL;
	ip_addr_set_any(&current_iphdr_src);
	ip_addr_set_any(&current_iphdr_dest);

	return ERR_OK;
}
    4428:	2000      	movs	r0, #0
    442a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    442e:	4688      	mov	r8, r1
	iphdr_hlen = IPH_HL(iphdr);
    4430:	f005 050f 	and.w	r5, r5, #15
	iphdr_hlen *= 4;
    4434:	00ad      	lsls	r5, r5, #2
	iphdr_len = ntohs(IPH_LEN(iphdr));
    4436:	f8b9 0002 	ldrh.w	r0, [r9, #2]
    443a:	4b61      	ldr	r3, [pc, #388]	; (45c0 <ip_input+0x1b0>)
    443c:	4798      	blx	r3
    443e:	4604      	mov	r4, r0
	if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    4440:	8973      	ldrh	r3, [r6, #10]
    4442:	42ab      	cmp	r3, r5
    4444:	d302      	bcc.n	444c <ip_input+0x3c>
    4446:	8933      	ldrh	r3, [r6, #8]
    4448:	4283      	cmp	r3, r0
    444a:	d203      	bcs.n	4454 <ip_input+0x44>
		pbuf_free(p);
    444c:	4630      	mov	r0, r6
    444e:	4b5b      	ldr	r3, [pc, #364]	; (45bc <ip_input+0x1ac>)
    4450:	4798      	blx	r3
		return ERR_OK;
    4452:	e7e9      	b.n	4428 <ip_input+0x18>
	if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    4454:	4629      	mov	r1, r5
    4456:	4648      	mov	r0, r9
    4458:	4b5a      	ldr	r3, [pc, #360]	; (45c4 <ip_input+0x1b4>)
    445a:	4798      	blx	r3
    445c:	b990      	cbnz	r0, 4484 <ip_input+0x74>
	pbuf_realloc(p, iphdr_len);
    445e:	4621      	mov	r1, r4
    4460:	4630      	mov	r0, r6
    4462:	4b59      	ldr	r3, [pc, #356]	; (45c8 <ip_input+0x1b8>)
    4464:	4798      	blx	r3
	ip_addr_copy(current_iphdr_dest, iphdr->dest);
    4466:	f8d9 2010 	ldr.w	r2, [r9, #16]
    446a:	4b58      	ldr	r3, [pc, #352]	; (45cc <ip_input+0x1bc>)
    446c:	601a      	str	r2, [r3, #0]
	ip_addr_copy(current_iphdr_src, iphdr->src);
    446e:	f8d9 200c 	ldr.w	r2, [r9, #12]
    4472:	4b57      	ldr	r3, [pc, #348]	; (45d0 <ip_input+0x1c0>)
    4474:	601a      	str	r2, [r3, #0]
		netif     = inp;
    4476:	4644      	mov	r4, r8
		int first = 1;
    4478:	2701      	movs	r7, #1
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    447a:	f8df b150 	ldr.w	fp, [pc, #336]	; 45cc <ip_input+0x1bc>
				netif = netif_list;
    447e:	f8df a178 	ldr.w	sl, [pc, #376]	; 45f8 <ip_input+0x1e8>
    4482:	e00b      	b.n	449c <ip_input+0x8c>
		pbuf_free(p);
    4484:	4630      	mov	r0, r6
    4486:	4b4d      	ldr	r3, [pc, #308]	; (45bc <ip_input+0x1ac>)
    4488:	4798      	blx	r3
		return ERR_OK;
    448a:	e7cd      	b.n	4428 <ip_input+0x18>
			if (first) {
    448c:	b1ff      	cbz	r7, 44ce <ip_input+0xbe>
				netif = netif_list;
    448e:	f8da 4000 	ldr.w	r4, [sl]
			if (netif == inp) {
    4492:	4544      	cmp	r4, r8
				netif = netif->next;
    4494:	bf08      	it	eq
    4496:	6824      	ldreq	r4, [r4, #0]
    4498:	2700      	movs	r7, #0
		} while (netif != NULL);
    449a:	b1d4      	cbz	r4, 44d2 <ip_input+0xc2>
			if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    449c:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    44a0:	f013 0f01 	tst.w	r3, #1
    44a4:	d0f2      	beq.n	448c <ip_input+0x7c>
    44a6:	f114 0f04 	cmn.w	r4, #4
    44aa:	d0ef      	beq.n	448c <ip_input+0x7c>
    44ac:	6863      	ldr	r3, [r4, #4]
    44ae:	2b00      	cmp	r3, #0
    44b0:	d0ec      	beq.n	448c <ip_input+0x7c>
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    44b2:	f8db 0000 	ldr.w	r0, [fp]
    44b6:	4283      	cmp	r3, r0
    44b8:	d004      	beq.n	44c4 <ip_input+0xb4>
				    ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    44ba:	4621      	mov	r1, r4
    44bc:	4b45      	ldr	r3, [pc, #276]	; (45d4 <ip_input+0x1c4>)
    44be:	4798      	blx	r3
				if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    44c0:	2800      	cmp	r0, #0
    44c2:	d0e3      	beq.n	448c <ip_input+0x7c>
	if (netif == NULL) {
    44c4:	b12c      	cbz	r4, 44d2 <ip_input+0xc2>
	if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
    44c6:	4b42      	ldr	r3, [pc, #264]	; (45d0 <ip_input+0x1c0>)
    44c8:	6818      	ldr	r0, [r3, #0]
    44ca:	b1c0      	cbz	r0, 44fe <ip_input+0xee>
    44cc:	e00a      	b.n	44e4 <ip_input+0xd4>
				netif = netif->next;
    44ce:	6824      	ldr	r4, [r4, #0]
    44d0:	e7df      	b.n	4492 <ip_input+0x82>
		if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
    44d2:	f899 3009 	ldrb.w	r3, [r9, #9]
    44d6:	2b11      	cmp	r3, #17
    44d8:	d049      	beq.n	456e <ip_input+0x15e>
	if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
    44da:	4b3d      	ldr	r3, [pc, #244]	; (45d0 <ip_input+0x1c0>)
    44dc:	6818      	ldr	r0, [r3, #0]
    44de:	2800      	cmp	r0, #0
    44e0:	d050      	beq.n	4584 <ip_input+0x174>
    44e2:	2400      	movs	r4, #0
		if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) || (ip_addr_ismulticast(&current_iphdr_src))) {
    44e4:	4641      	mov	r1, r8
    44e6:	4b3b      	ldr	r3, [pc, #236]	; (45d4 <ip_input+0x1c4>)
    44e8:	4798      	blx	r3
    44ea:	2800      	cmp	r0, #0
    44ec:	d146      	bne.n	457c <ip_input+0x16c>
    44ee:	4b38      	ldr	r3, [pc, #224]	; (45d0 <ip_input+0x1c0>)
    44f0:	681b      	ldr	r3, [r3, #0]
    44f2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    44f6:	2be0      	cmp	r3, #224	; 0xe0
    44f8:	d040      	beq.n	457c <ip_input+0x16c>
	if (netif == NULL) {
    44fa:	2c00      	cmp	r4, #0
    44fc:	d042      	beq.n	4584 <ip_input+0x174>
	if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
    44fe:	f8b9 3006 	ldrh.w	r3, [r9, #6]
    4502:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    4506:	b29b      	uxth	r3, r3
    4508:	b13b      	cbz	r3, 451a <ip_input+0x10a>
		p = ip_reass(p);
    450a:	4630      	mov	r0, r6
    450c:	4b32      	ldr	r3, [pc, #200]	; (45d8 <ip_input+0x1c8>)
    450e:	4798      	blx	r3
		if (p == NULL) {
    4510:	4606      	mov	r6, r0
    4512:	2800      	cmp	r0, #0
    4514:	d088      	beq.n	4428 <ip_input+0x18>
		iphdr = (struct ip_hdr *)p->payload;
    4516:	f8d0 9004 	ldr.w	r9, [r0, #4]
	current_netif  = inp;
    451a:	4b30      	ldr	r3, [pc, #192]	; (45dc <ip_input+0x1cc>)
    451c:	f8c3 8000 	str.w	r8, [r3]
	current_header = iphdr;
    4520:	4b2f      	ldr	r3, [pc, #188]	; (45e0 <ip_input+0x1d0>)
    4522:	f8c3 9000 	str.w	r9, [r3]
	if (raw_input(p, inp) == 0)
    4526:	4641      	mov	r1, r8
    4528:	4630      	mov	r0, r6
    452a:	4b2e      	ldr	r3, [pc, #184]	; (45e4 <ip_input+0x1d4>)
    452c:	4798      	blx	r3
    452e:	2800      	cmp	r0, #0
    4530:	d130      	bne.n	4594 <ip_input+0x184>
		switch (IPH_PROTO(iphdr)) {
    4532:	f899 3009 	ldrb.w	r3, [r9, #9]
    4536:	2b06      	cmp	r3, #6
    4538:	d036      	beq.n	45a8 <ip_input+0x198>
    453a:	2b11      	cmp	r3, #17
    453c:	d026      	beq.n	458c <ip_input+0x17c>
    453e:	2b01      	cmp	r3, #1
    4540:	d037      	beq.n	45b2 <ip_input+0x1a2>
			if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) && !ip_addr_ismulticast(&current_iphdr_dest)) {
    4542:	4641      	mov	r1, r8
    4544:	4b21      	ldr	r3, [pc, #132]	; (45cc <ip_input+0x1bc>)
    4546:	6818      	ldr	r0, [r3, #0]
    4548:	4b22      	ldr	r3, [pc, #136]	; (45d4 <ip_input+0x1c4>)
    454a:	4798      	blx	r3
    454c:	b958      	cbnz	r0, 4566 <ip_input+0x156>
    454e:	4b1f      	ldr	r3, [pc, #124]	; (45cc <ip_input+0x1bc>)
    4550:	681b      	ldr	r3, [r3, #0]
    4552:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    4556:	2be0      	cmp	r3, #224	; 0xe0
    4558:	d005      	beq.n	4566 <ip_input+0x156>
				p->payload = iphdr;
    455a:	f8c6 9004 	str.w	r9, [r6, #4]
				icmp_dest_unreach(p, ICMP_DUR_PROTO);
    455e:	2102      	movs	r1, #2
    4560:	4630      	mov	r0, r6
    4562:	4b21      	ldr	r3, [pc, #132]	; (45e8 <ip_input+0x1d8>)
    4564:	4798      	blx	r3
			pbuf_free(p);
    4566:	4630      	mov	r0, r6
    4568:	4b14      	ldr	r3, [pc, #80]	; (45bc <ip_input+0x1ac>)
    456a:	4798      	blx	r3
    456c:	e012      	b.n	4594 <ip_input+0x184>
			if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
    456e:	444d      	add	r5, r9
    4570:	886b      	ldrh	r3, [r5, #2]
    4572:	f5b3 4f88 	cmp.w	r3, #17408	; 0x4400
    4576:	d1b0      	bne.n	44da <ip_input+0xca>
				netif        = inp;
    4578:	4644      	mov	r4, r8
    457a:	e7be      	b.n	44fa <ip_input+0xea>
			pbuf_free(p);
    457c:	4630      	mov	r0, r6
    457e:	4b0f      	ldr	r3, [pc, #60]	; (45bc <ip_input+0x1ac>)
    4580:	4798      	blx	r3
			return ERR_OK;
    4582:	e751      	b.n	4428 <ip_input+0x18>
		pbuf_free(p);
    4584:	4630      	mov	r0, r6
    4586:	4b0d      	ldr	r3, [pc, #52]	; (45bc <ip_input+0x1ac>)
    4588:	4798      	blx	r3
		return ERR_OK;
    458a:	e74d      	b.n	4428 <ip_input+0x18>
			udp_input(p, inp);
    458c:	4641      	mov	r1, r8
    458e:	4630      	mov	r0, r6
    4590:	4b16      	ldr	r3, [pc, #88]	; (45ec <ip_input+0x1dc>)
    4592:	4798      	blx	r3
	current_netif  = NULL;
    4594:	2300      	movs	r3, #0
    4596:	4a11      	ldr	r2, [pc, #68]	; (45dc <ip_input+0x1cc>)
    4598:	6013      	str	r3, [r2, #0]
	current_header = NULL;
    459a:	4a11      	ldr	r2, [pc, #68]	; (45e0 <ip_input+0x1d0>)
    459c:	6013      	str	r3, [r2, #0]
	ip_addr_set_any(&current_iphdr_src);
    459e:	4a0c      	ldr	r2, [pc, #48]	; (45d0 <ip_input+0x1c0>)
    45a0:	6013      	str	r3, [r2, #0]
	ip_addr_set_any(&current_iphdr_dest);
    45a2:	4a0a      	ldr	r2, [pc, #40]	; (45cc <ip_input+0x1bc>)
    45a4:	6013      	str	r3, [r2, #0]
	return ERR_OK;
    45a6:	e73f      	b.n	4428 <ip_input+0x18>
			tcp_input(p, inp);
    45a8:	4641      	mov	r1, r8
    45aa:	4630      	mov	r0, r6
    45ac:	4b10      	ldr	r3, [pc, #64]	; (45f0 <ip_input+0x1e0>)
    45ae:	4798      	blx	r3
			break;
    45b0:	e7f0      	b.n	4594 <ip_input+0x184>
			icmp_input(p, inp);
    45b2:	4641      	mov	r1, r8
    45b4:	4630      	mov	r0, r6
    45b6:	4b0f      	ldr	r3, [pc, #60]	; (45f4 <ip_input+0x1e4>)
    45b8:	4798      	blx	r3
			break;
    45ba:	e7eb      	b.n	4594 <ip_input+0x184>
    45bc:	000054c9 	.word	0x000054c9
    45c0:	000026ef 	.word	0x000026ef
    45c4:	00004369 	.word	0x00004369
    45c8:	0000566d 	.word	0x0000566d
    45cc:	20008314 	.word	0x20008314
    45d0:	2000830c 	.word	0x2000830c
    45d4:	00004739 	.word	0x00004739
    45d8:	000049b1 	.word	0x000049b1
    45dc:	20008310 	.word	0x20008310
    45e0:	20008318 	.word	0x20008318
    45e4:	000058f1 	.word	0x000058f1
    45e8:	00004239 	.word	0x00004239
    45ec:	00008225 	.word	0x00008225
    45f0:	00006db5 	.word	0x00006db5
    45f4:	000040e1 	.word	0x000040e1
    45f8:	200092d0 	.word	0x200092d0

000045fc <ip_output_if>:
 *
 * @note ip_id: RFC791 "some host may be able to simply use
 *  unique identifiers independent of destination"
 */
err_t ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t ttl, u8_t tos, u8_t proto, struct netif *netif)
{
    45fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4600:	b087      	sub	sp, #28
    4602:	4605      	mov	r5, r0
    4604:	9102      	str	r1, [sp, #8]
    4606:	f89d 8040 	ldrb.w	r8, [sp, #64]	; 0x40
    460a:	f89d b044 	ldrb.w	fp, [sp, #68]	; 0x44
    460e:	9e12      	ldr	r6, [sp, #72]	; 0x48
	LWIP_ASSERT("p->ref == 1", p->ref == 1);

	snmp_inc_ipoutrequests();

	/* Should the IP header be generated or is it already included in p? */
	if (dest != IP_HDRINCL) {
    4610:	9201      	str	r2, [sp, #4]
    4612:	2a00      	cmp	r2, #0
    4614:	d057      	beq.n	46c6 <ip_output_if+0xca>
    4616:	469a      	mov	sl, r3
    4618:	4617      	mov	r7, r2
			}
#endif /* CHECKSUM_GEN_IP_INLINE */
		}
#endif /* IP_OPTIONS_SEND */
		/* generate IP header */
		if (pbuf_header(p, IP_HLEN)) {
    461a:	2114      	movs	r1, #20
    461c:	4b32      	ldr	r3, [pc, #200]	; (46e8 <ip_output_if+0xec>)
    461e:	4798      	blx	r3
    4620:	2800      	cmp	r0, #0
    4622:	d15d      	bne.n	46e0 <ip_output_if+0xe4>
			IP_STATS_INC(ip.err);
			snmp_inc_ipoutdiscards();
			return ERR_BUF;
		}

		iphdr = (struct ip_hdr *)p->payload;
    4624:	686c      	ldr	r4, [r5, #4]
		LWIP_ASSERT("check that first pbuf can hold struct ip_hdr", (p->len >= sizeof(struct ip_hdr)));

		IPH_TTL_SET(iphdr, ttl);
    4626:	f884 a008 	strb.w	sl, [r4, #8]
		IPH_PROTO_SET(iphdr, proto);
    462a:	f884 b009 	strb.w	fp, [r4, #9]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

		/* dest cannot be NULL here */
		ip_addr_copy(iphdr->dest, *dest);
    462e:	683b      	ldr	r3, [r7, #0]
    4630:	6123      	str	r3, [r4, #16]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    4632:	b29a      	uxth	r2, r3
    4634:	9203      	str	r2, [sp, #12]
		chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
    4636:	ea4f 4913 	mov.w	r9, r3, lsr #16
#endif /* CHECKSUM_GEN_IP_INLINE */

		IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    463a:	2345      	movs	r3, #69	; 0x45
    463c:	7023      	strb	r3, [r4, #0]
		IPH_TOS_SET(iphdr, tos);
    463e:	f884 8001 	strb.w	r8, [r4, #1]
		chk_sum += LWIP_MAKE_U16(proto, ttl);
    4642:	ea4a 2a0b 	orr.w	sl, sl, fp, lsl #8
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    4646:	ea4f 2808 	mov.w	r8, r8, lsl #8
    464a:	ea48 0803 	orr.w	r8, r8, r3
    464e:	eb0a 0b08 	add.w	fp, sl, r8
#endif /* CHECKSUM_GEN_IP_INLINE */
		IPH_LEN_SET(iphdr, htons(p->tot_len));
    4652:	8928      	ldrh	r0, [r5, #8]
    4654:	4f25      	ldr	r7, [pc, #148]	; (46ec <ip_output_if+0xf0>)
    4656:	47b8      	blx	r7
    4658:	4682      	mov	sl, r0
    465a:	8060      	strh	r0, [r4, #2]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
		IPH_OFFSET_SET(iphdr, 0);
    465c:	2300      	movs	r3, #0
    465e:	71a3      	strb	r3, [r4, #6]
    4660:	71e3      	strb	r3, [r4, #7]
		IPH_ID_SET(iphdr, htons(ip_id));
    4662:	f8df 8090 	ldr.w	r8, [pc, #144]	; 46f4 <ip_output_if+0xf8>
    4666:	f8b8 0000 	ldrh.w	r0, [r8]
    466a:	47b8      	blx	r7
    466c:	80a0      	strh	r0, [r4, #4]
#if CHECKSUM_GEN_IP_INLINE
		chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
		++ip_id;
    466e:	f8b8 3000 	ldrh.w	r3, [r8]
    4672:	3301      	adds	r3, #1
    4674:	f8a8 3000 	strh.w	r3, [r8]

		if (ip_addr_isany(src)) {
    4678:	9b02      	ldr	r3, [sp, #8]
    467a:	b10b      	cbz	r3, 4680 <ip_output_if+0x84>
    467c:	681b      	ldr	r3, [r3, #0]
    467e:	bb03      	cbnz	r3, 46c2 <ip_output_if+0xc6>
			ip_addr_copy(iphdr->src, netif->ip_addr);
    4680:	6873      	ldr	r3, [r6, #4]
    4682:	60e3      	str	r3, [r4, #12]
			/* src cannot be NULL here */
			ip_addr_copy(iphdr->src, *src);
		}

#if CHECKSUM_GEN_IP_INLINE
		chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
    4684:	68e2      	ldr	r2, [r4, #12]
		chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
    4686:	fa1b f382 	uxtah	r3, fp, r2
    468a:	eb03 4312 	add.w	r3, r3, r2, lsr #16
    468e:	9a03      	ldr	r2, [sp, #12]
    4690:	4413      	add	r3, r2
    4692:	444b      	add	r3, r9
    4694:	449a      	add	sl, r3
    4696:	4450      	add	r0, sl
		chk_sum        = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    4698:	fa1f fa80 	uxth.w	sl, r0
    469c:	eb0a 4010 	add.w	r0, sl, r0, lsr #16
		chk_sum        = (chk_sum >> 16) + chk_sum;
    46a0:	eb00 4010 	add.w	r0, r0, r0, lsr #16
		chk_sum        = ~chk_sum;
		iphdr->_chksum = chk_sum; /* network order */
    46a4:	43c0      	mvns	r0, r0
    46a6:	8160      	strh	r0, [r4, #10]
	}
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
	/* don't fragment if interface has mtu set to 0 [loopif] */
	if (netif->mtu && (p->tot_len > netif->mtu)) {
    46a8:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
    46aa:	b113      	cbz	r3, 46b2 <ip_output_if+0xb6>
    46ac:	892a      	ldrh	r2, [r5, #8]
    46ae:	429a      	cmp	r2, r3
    46b0:	d810      	bhi.n	46d4 <ip_output_if+0xd8>
		return ip_frag(p, netif, dest);
	}
#endif /* IP_FRAG */

	LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
	return netif->output(netif, p, dest);
    46b2:	6973      	ldr	r3, [r6, #20]
    46b4:	9a01      	ldr	r2, [sp, #4]
    46b6:	4629      	mov	r1, r5
    46b8:	4630      	mov	r0, r6
    46ba:	4798      	blx	r3
}
    46bc:	b007      	add	sp, #28
    46be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ip_addr_copy(iphdr->src, *src);
    46c2:	60e3      	str	r3, [r4, #12]
    46c4:	e7de      	b.n	4684 <ip_output_if+0x88>
		ip_addr_copy(dest_addr, iphdr->dest);
    46c6:	6843      	ldr	r3, [r0, #4]
    46c8:	691b      	ldr	r3, [r3, #16]
    46ca:	aa06      	add	r2, sp, #24
    46cc:	f842 3d04 	str.w	r3, [r2, #-4]!
    46d0:	9201      	str	r2, [sp, #4]
    46d2:	e7e9      	b.n	46a8 <ip_output_if+0xac>
		return ip_frag(p, netif, dest);
    46d4:	9a01      	ldr	r2, [sp, #4]
    46d6:	4631      	mov	r1, r6
    46d8:	4628      	mov	r0, r5
    46da:	4b05      	ldr	r3, [pc, #20]	; (46f0 <ip_output_if+0xf4>)
    46dc:	4798      	blx	r3
    46de:	e7ed      	b.n	46bc <ip_output_if+0xc0>
			return ERR_BUF;
    46e0:	f06f 0001 	mvn.w	r0, #1
    46e4:	e7ea      	b.n	46bc <ip_output_if+0xc0>
    46e6:	bf00      	nop
    46e8:	00005435 	.word	0x00005435
    46ec:	000026e5 	.word	0x000026e5
    46f0:	00004d0d 	.word	0x00004d0d
    46f4:	2000162c 	.word	0x2000162c

000046f8 <ip_output>:
 *
 * @return ERR_RTE if no route is found
 *         see ip_output_if() for more return values
 */
err_t ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, u8_t ttl, u8_t tos, u8_t proto)
{
    46f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    46fa:	b085      	sub	sp, #20
    46fc:	4605      	mov	r5, r0
    46fe:	460e      	mov	r6, r1
    4700:	4614      	mov	r4, r2
    4702:	461f      	mov	r7, r3

	/* pbufs passed to IP must have a ref-count of 1 as their payload pointer
	   gets altered as the packet is passed down the stack */
	LWIP_ASSERT("p->ref == 1", p->ref == 1);

	if ((netif = ip_route(dest)) == NULL) {
    4704:	4610      	mov	r0, r2
    4706:	4b0a      	ldr	r3, [pc, #40]	; (4730 <ip_output+0x38>)
    4708:	4798      	blx	r3
    470a:	b170      	cbz	r0, 472a <ip_output+0x32>
		             ip4_addr4_16(dest)));
		IP_STATS_INC(ip.rterr);
		return ERR_RTE;
	}

	return ip_output_if(p, src, dest, ttl, tos, proto, netif);
    470c:	9002      	str	r0, [sp, #8]
    470e:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    4712:	9301      	str	r3, [sp, #4]
    4714:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    4718:	9300      	str	r3, [sp, #0]
    471a:	463b      	mov	r3, r7
    471c:	4622      	mov	r2, r4
    471e:	4631      	mov	r1, r6
    4720:	4628      	mov	r0, r5
    4722:	4c04      	ldr	r4, [pc, #16]	; (4734 <ip_output+0x3c>)
    4724:	47a0      	blx	r4
}
    4726:	b005      	add	sp, #20
    4728:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_RTE;
    472a:	f06f 0003 	mvn.w	r0, #3
    472e:	e7fa      	b.n	4726 <ip_output+0x2e>
    4730:	000043cd 	.word	0x000043cd
    4734:	000045fd 	.word	0x000045fd

00004738 <ip4_addr_isbroadcast>:
{
	ip_addr_t ipaddr;
	ip4_addr_set_u32(&ipaddr, addr);

	/* all ones (broadcast) or all zeroes (old skool broadcast) */
	if ((~addr == IPADDR_ANY) || (addr == IPADDR_ANY)) {
    4738:	1e43      	subs	r3, r0, #1
    473a:	f113 0f03 	cmn.w	r3, #3
    473e:	d812      	bhi.n	4766 <ip4_addr_isbroadcast+0x2e>
		return 1;
		/* no broadcast support on this network interface? */
	} else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
    4740:	f891 3035 	ldrb.w	r3, [r1, #53]	; 0x35
    4744:	f013 0f02 	tst.w	r3, #2
    4748:	d00f      	beq.n	476a <ip4_addr_isbroadcast+0x32>
		/* the given address cannot be a broadcast address
		 * nor can we check against any broadcast addresses */
		return 0;
		/* address matches network interface address exactly? => no broadcast */
	} else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    474a:	684b      	ldr	r3, [r1, #4]
    474c:	4298      	cmp	r0, r3
    474e:	d00e      	beq.n	476e <ip4_addr_isbroadcast+0x36>
		return 0;
		/*  on the same (sub) network... */
	} else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
    4750:	688a      	ldr	r2, [r1, #8]
    4752:	4043      	eors	r3, r0
    4754:	4213      	tst	r3, r2
    4756:	d10c      	bne.n	4772 <ip4_addr_isbroadcast+0x3a>
	           /* ...and host identifier bits are all ones? =>... */
	           && ((addr & ~ip4_addr_get_u32(&netif->netmask))
    4758:	43d2      	mvns	r2, r2
    475a:	ea32 0300 	bics.w	r3, r2, r0
		return 1;
    475e:	bf0c      	ite	eq
    4760:	2001      	moveq	r0, #1
    4762:	2000      	movne	r0, #0
    4764:	4770      	bx	lr
    4766:	2001      	movs	r0, #1
    4768:	4770      	bx	lr
		return 0;
    476a:	2000      	movs	r0, #0
    476c:	4770      	bx	lr
		return 0;
    476e:	2000      	movs	r0, #0
    4770:	4770      	bx	lr
	               == (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
		/* => network broadcast address */
		return 1;
	} else {
		return 0;
    4772:	2000      	movs	r0, #0
	}
}
    4774:	4770      	bx	lr
	...

00004778 <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
    4778:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    477c:	b085      	sub	sp, #20
    477e:	9101      	str	r1, [sp, #4]
	u8_t  rem;
	u8_t  n;
	u8_t  i;
	int   len = 0;

	s_addr = ip4_addr_get_u32(addr);
    4780:	6803      	ldr	r3, [r0, #0]
    4782:	f10d 0c10 	add.w	ip, sp, #16
    4786:	f84c 3d04 	str.w	r3, [ip, #-4]!

	rp = buf;
    478a:	460c      	mov	r4, r1
	int   len = 0;
    478c:	f04f 0800 	mov.w	r8, #0
    4790:	46c1      	mov	r9, r8
	ap = (u8_t *)&s_addr;
	for (n = 0; n < 4; n++) {
		i = 0;
		do {
			rem = *ap % (u8_t)10;
    4792:	4f27      	ldr	r7, [pc, #156]	; (4830 <ipaddr_ntoa_r+0xb8>)
    4794:	f102 0e01 	add.w	lr, r2, #1
			*rp++ = inv[i];
		}
		if (len++ >= buflen) {
			return NULL;
		}
		*rp++ = '.';
    4798:	f04f 0b2e 	mov.w	fp, #46	; 0x2e
    479c:	4666      	mov	r6, ip
    479e:	f89c 3000 	ldrb.w	r3, [ip]
	int   len = 0;
    47a2:	4648      	mov	r0, r9
    47a4:	469a      	mov	sl, r3
    47a6:	e000      	b.n	47aa <ipaddr_ntoa_r+0x32>
			inv[i++] = '0' + rem;
    47a8:	4628      	mov	r0, r5
			rem = *ap % (u8_t)10;
    47aa:	fba7 310a 	umull	r3, r1, r7, sl
    47ae:	08c9      	lsrs	r1, r1, #3
    47b0:	eb01 0381 	add.w	r3, r1, r1, lsl #2
    47b4:	ebaa 0343 	sub.w	r3, sl, r3, lsl #1
			inv[i++] = '0' + rem;
    47b8:	1c45      	adds	r5, r0, #1
    47ba:	b2ed      	uxtb	r5, r5
    47bc:	3330      	adds	r3, #48	; 0x30
    47be:	f10d 0a10 	add.w	sl, sp, #16
    47c2:	4482      	add	sl, r0
    47c4:	f80a 3c08 	strb.w	r3, [sl, #-8]
		} while (*ap);
    47c8:	f001 0aff 	and.w	sl, r1, #255	; 0xff
    47cc:	2900      	cmp	r1, #0
    47ce:	d1eb      	bne.n	47a8 <ipaddr_ntoa_r+0x30>
    47d0:	f886 9000 	strb.w	r9, [r6]
    47d4:	f10c 0c01 	add.w	ip, ip, #1
		while (i--) {
    47d8:	b1ad      	cbz	r5, 4806 <ipaddr_ntoa_r+0x8e>
			if (len++ >= buflen) {
    47da:	f108 0101 	add.w	r1, r8, #1
    47de:	4542      	cmp	r2, r8
    47e0:	dd21      	ble.n	4826 <ipaddr_ntoa_r+0xae>
    47e2:	ab02      	add	r3, sp, #8
    47e4:	181d      	adds	r5, r3, r0
    47e6:	1e63      	subs	r3, r4, #1
    47e8:	4420      	add	r0, r4
    47ea:	1c9e      	adds	r6, r3, #2
			*rp++ = inv[i];
    47ec:	f815 4901 	ldrb.w	r4, [r5], #-1
    47f0:	f803 4f01 	strb.w	r4, [r3, #1]!
		while (i--) {
    47f4:	4298      	cmp	r0, r3
    47f6:	d008      	beq.n	480a <ipaddr_ntoa_r+0x92>
			if (len++ >= buflen) {
    47f8:	3101      	adds	r1, #1
    47fa:	4571      	cmp	r1, lr
    47fc:	d1f5      	bne.n	47ea <ipaddr_ntoa_r+0x72>
				return NULL;
    47fe:	2000      	movs	r0, #0
		ap++;
	}
	*--rp = 0;
	return buf;
}
    4800:	b005      	add	sp, #20
    4802:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		while (i--) {
    4806:	4641      	mov	r1, r8
    4808:	4626      	mov	r6, r4
		if (len++ >= buflen) {
    480a:	f101 0801 	add.w	r8, r1, #1
    480e:	428a      	cmp	r2, r1
    4810:	dd0b      	ble.n	482a <ipaddr_ntoa_r+0xb2>
		*rp++ = '.';
    4812:	1c74      	adds	r4, r6, #1
    4814:	f886 b000 	strb.w	fp, [r6]
	for (n = 0; n < 4; n++) {
    4818:	ab04      	add	r3, sp, #16
    481a:	459c      	cmp	ip, r3
    481c:	d1be      	bne.n	479c <ipaddr_ntoa_r+0x24>
	*--rp = 0;
    481e:	2300      	movs	r3, #0
    4820:	7033      	strb	r3, [r6, #0]
	return buf;
    4822:	9801      	ldr	r0, [sp, #4]
    4824:	e7ec      	b.n	4800 <ipaddr_ntoa_r+0x88>
				return NULL;
    4826:	2000      	movs	r0, #0
    4828:	e7ea      	b.n	4800 <ipaddr_ntoa_r+0x88>
			return NULL;
    482a:	2000      	movs	r0, #0
    482c:	e7e8      	b.n	4800 <ipaddr_ntoa_r+0x88>
    482e:	bf00      	nop
    4830:	cccccccd 	.word	0xcccccccd

00004834 <ip_reass_free_complete_datagram>:
 * @param ipr datagram to free
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    4834:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    4838:	4681      	mov	r9, r0
    483a:	468a      	mov	sl, r1
		LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
	}

	snmp_inc_ipreasmfails();
#if LWIP_ICMP
	iprh = (struct ip_reass_helper *)ipr->p->payload;
    483c:	6845      	ldr	r5, [r0, #4]
    483e:	686b      	ldr	r3, [r5, #4]
	if (iprh->start == 0) {
    4840:	889a      	ldrh	r2, [r3, #4]
    4842:	b322      	cbz	r2, 488e <ip_reass_free_complete_datagram+0x5a>
	u16_t                   pbufs_freed = 0;
    4844:	2400      	movs	r4, #0
	}
#endif /* LWIP_ICMP */

	/* First, free all received pbufs.  The individual pbufs need to be released
	   separately as they have not yet been chained */
	p = ipr->p;
    4846:	f8d9 6004 	ldr.w	r6, [r9, #4]
	while (p != NULL) {
    484a:	b16e      	cbz	r6, 4868 <ip_reass_free_complete_datagram+0x34>
		struct pbuf *pcur;
		iprh = (struct ip_reass_helper *)p->payload;
		pcur = p;
		/* get the next pointer before freeing */
		p    = iprh->next_pbuf;
		clen = pbuf_clen(pcur);
    484c:	f8df 8090 	ldr.w	r8, [pc, #144]	; 48e0 <ip_reass_free_complete_datagram+0xac>
		LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
		pbufs_freed += clen;
		pbuf_free(pcur);
    4850:	4f1f      	ldr	r7, [pc, #124]	; (48d0 <ip_reass_free_complete_datagram+0x9c>)
		iprh = (struct ip_reass_helper *)p->payload;
    4852:	6873      	ldr	r3, [r6, #4]
		p    = iprh->next_pbuf;
    4854:	681d      	ldr	r5, [r3, #0]
		clen = pbuf_clen(pcur);
    4856:	4630      	mov	r0, r6
    4858:	47c0      	blx	r8
		pbufs_freed += clen;
    485a:	4404      	add	r4, r0
    485c:	b2a4      	uxth	r4, r4
		pbuf_free(pcur);
    485e:	4630      	mov	r0, r6
    4860:	47b8      	blx	r7
		p    = iprh->next_pbuf;
    4862:	462e      	mov	r6, r5
	while (p != NULL) {
    4864:	2d00      	cmp	r5, #0
    4866:	d1f4      	bne.n	4852 <ip_reass_free_complete_datagram+0x1e>
 */
static void ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{

	/* dequeue the reass struct  */
	if (reassdatagrams == ipr) {
    4868:	4b1a      	ldr	r3, [pc, #104]	; (48d4 <ip_reass_free_complete_datagram+0xa0>)
    486a:	681b      	ldr	r3, [r3, #0]
    486c:	4599      	cmp	r9, r3
    486e:	d029      	beq.n	48c4 <ip_reass_free_complete_datagram+0x90>
		/* it was the first in the list */
		reassdatagrams = ipr->next;
	} else {
		/* it wasn't the first, so it must have a valid 'prev' */
		LWIP_ASSERT("sanity check linked list", prev != NULL);
		prev->next = ipr->next;
    4870:	f8d9 3000 	ldr.w	r3, [r9]
    4874:	f8ca 3000 	str.w	r3, [sl]
	}

	/* now we can free the ip_reass struct */
	memp_free(MEMP_REASSDATA, ipr);
    4878:	4649      	mov	r1, r9
    487a:	2005      	movs	r0, #5
    487c:	4b16      	ldr	r3, [pc, #88]	; (48d8 <ip_reass_free_complete_datagram+0xa4>)
    487e:	4798      	blx	r3
	ip_reass_pbufcount -= pbufs_freed;
    4880:	4a14      	ldr	r2, [pc, #80]	; (48d4 <ip_reass_free_complete_datagram+0xa0>)
    4882:	8893      	ldrh	r3, [r2, #4]
    4884:	1b1b      	subs	r3, r3, r4
    4886:	8093      	strh	r3, [r2, #4]
}
    4888:	4620      	mov	r0, r4
    488a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		ipr->p = iprh->next_pbuf;
    488e:	681b      	ldr	r3, [r3, #0]
    4890:	6043      	str	r3, [r0, #4]
		SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    4892:	686a      	ldr	r2, [r5, #4]
    4894:	4603      	mov	r3, r0
    4896:	f853 1f08 	ldr.w	r1, [r3, #8]!
    489a:	685e      	ldr	r6, [r3, #4]
    489c:	689c      	ldr	r4, [r3, #8]
    489e:	68d8      	ldr	r0, [r3, #12]
    48a0:	6011      	str	r1, [r2, #0]
    48a2:	6056      	str	r6, [r2, #4]
    48a4:	6094      	str	r4, [r2, #8]
    48a6:	60d0      	str	r0, [r2, #12]
    48a8:	6919      	ldr	r1, [r3, #16]
    48aa:	6111      	str	r1, [r2, #16]
		icmp_time_exceeded(p, ICMP_TE_FRAG);
    48ac:	2101      	movs	r1, #1
    48ae:	4628      	mov	r0, r5
    48b0:	4b0a      	ldr	r3, [pc, #40]	; (48dc <ip_reass_free_complete_datagram+0xa8>)
    48b2:	4798      	blx	r3
		clen = pbuf_clen(p);
    48b4:	4628      	mov	r0, r5
    48b6:	4b0a      	ldr	r3, [pc, #40]	; (48e0 <ip_reass_free_complete_datagram+0xac>)
    48b8:	4798      	blx	r3
		pbufs_freed += clen;
    48ba:	b284      	uxth	r4, r0
		pbuf_free(p);
    48bc:	4628      	mov	r0, r5
    48be:	4b04      	ldr	r3, [pc, #16]	; (48d0 <ip_reass_free_complete_datagram+0x9c>)
    48c0:	4798      	blx	r3
    48c2:	e7c0      	b.n	4846 <ip_reass_free_complete_datagram+0x12>
		reassdatagrams = ipr->next;
    48c4:	f8d9 2000 	ldr.w	r2, [r9]
    48c8:	4b02      	ldr	r3, [pc, #8]	; (48d4 <ip_reass_free_complete_datagram+0xa0>)
    48ca:	601a      	str	r2, [r3, #0]
    48cc:	e7d4      	b.n	4878 <ip_reass_free_complete_datagram+0x44>
    48ce:	bf00      	nop
    48d0:	000054c9 	.word	0x000054c9
    48d4:	20001630 	.word	0x20001630
    48d8:	00005201 	.word	0x00005201
    48dc:	00004249 	.word	0x00004249
    48e0:	000056cd 	.word	0x000056cd

000048e4 <ip_reass_remove_oldest_datagram>:
{
    48e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    48e8:	4605      	mov	r5, r0
    48ea:	4688      	mov	r8, r1
	int                  pbufs_freed = 0, pbufs_freed_current;
    48ec:	2600      	movs	r6, #0
		r               = reassdatagrams;
    48ee:	4f19      	ldr	r7, [pc, #100]	; (4954 <ip_reass_remove_oldest_datagram+0x70>)
			pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    48f0:	f8df 9064 	ldr.w	r9, [pc, #100]	; 4958 <ip_reass_remove_oldest_datagram+0x74>
    48f4:	e022      	b.n	493c <ip_reass_remove_oldest_datagram+0x58>
				other_datagrams++;
    48f6:	3401      	adds	r4, #1
				if (oldest == NULL) {
    48f8:	b1b8      	cbz	r0, 492a <ip_reass_remove_oldest_datagram+0x46>
				} else if (r->timer <= oldest->timer) {
    48fa:	f893 c01f 	ldrb.w	ip, [r3, #31]
    48fe:	7fc2      	ldrb	r2, [r0, #31]
    4900:	4594      	cmp	ip, r2
    4902:	bf98      	it	ls
    4904:	4618      	movls	r0, r3
			if (r->next != NULL) {
    4906:	681a      	ldr	r2, [r3, #0]
    4908:	b18a      	cbz	r2, 492e <ip_reass_remove_oldest_datagram+0x4a>
    490a:	4619      	mov	r1, r3
    490c:	4613      	mov	r3, r2
			if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    490e:	695a      	ldr	r2, [r3, #20]
    4910:	4572      	cmp	r2, lr
    4912:	d1f0      	bne.n	48f6 <ip_reass_remove_oldest_datagram+0x12>
    4914:	f8d5 c010 	ldr.w	ip, [r5, #16]
    4918:	699a      	ldr	r2, [r3, #24]
    491a:	4562      	cmp	r2, ip
    491c:	d1eb      	bne.n	48f6 <ip_reass_remove_oldest_datagram+0x12>
    491e:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
    4922:	88aa      	ldrh	r2, [r5, #4]
    4924:	4594      	cmp	ip, r2
    4926:	d1e6      	bne.n	48f6 <ip_reass_remove_oldest_datagram+0x12>
    4928:	e7ed      	b.n	4906 <ip_reass_remove_oldest_datagram+0x22>
    492a:	4618      	mov	r0, r3
    492c:	e7eb      	b.n	4906 <ip_reass_remove_oldest_datagram+0x22>
		if (oldest != NULL) {
    492e:	b108      	cbz	r0, 4934 <ip_reass_remove_oldest_datagram+0x50>
			pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    4930:	47c8      	blx	r9
			pbufs_freed += pbufs_freed_current;
    4932:	4406      	add	r6, r0
	} while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    4934:	4546      	cmp	r6, r8
    4936:	da09      	bge.n	494c <ip_reass_remove_oldest_datagram+0x68>
    4938:	2c01      	cmp	r4, #1
    493a:	dd07      	ble.n	494c <ip_reass_remove_oldest_datagram+0x68>
		r               = reassdatagrams;
    493c:	683b      	ldr	r3, [r7, #0]
		while (r != NULL) {
    493e:	b12b      	cbz	r3, 494c <ip_reass_remove_oldest_datagram+0x68>
			if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    4940:	f8d5 e00c 	ldr.w	lr, [r5, #12]
    4944:	2400      	movs	r4, #0
    4946:	4621      	mov	r1, r4
    4948:	4620      	mov	r0, r4
    494a:	e7e0      	b.n	490e <ip_reass_remove_oldest_datagram+0x2a>
}
    494c:	4630      	mov	r0, r6
    494e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    4952:	bf00      	nop
    4954:	20001630 	.word	0x20001630
    4958:	00004835 	.word	0x00004835

0000495c <ipfrag_free_pbuf_custom>:
}

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void ipfrag_free_pbuf_custom(struct pbuf *p)
{
    495c:	b510      	push	{r4, lr}
    495e:	4604      	mov	r4, r0
	struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
	LWIP_ASSERT("pcr != NULL", pcr != NULL);
	LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
	if (pcr->original != NULL) {
    4960:	6940      	ldr	r0, [r0, #20]
    4962:	b108      	cbz	r0, 4968 <ipfrag_free_pbuf_custom+0xc>
		pbuf_free(pcr->original);
    4964:	4b03      	ldr	r3, [pc, #12]	; (4974 <ipfrag_free_pbuf_custom+0x18>)
    4966:	4798      	blx	r3
	memp_free(MEMP_FRAG_PBUF, p);
    4968:	4621      	mov	r1, r4
    496a:	2006      	movs	r0, #6
    496c:	4b02      	ldr	r3, [pc, #8]	; (4978 <ipfrag_free_pbuf_custom+0x1c>)
    496e:	4798      	blx	r3
    4970:	bd10      	pop	{r4, pc}
    4972:	bf00      	nop
    4974:	000054c9 	.word	0x000054c9
    4978:	00005201 	.word	0x00005201

0000497c <ip_reass_tmr>:
	r = reassdatagrams;
    497c:	4b0a      	ldr	r3, [pc, #40]	; (49a8 <ip_reass_tmr+0x2c>)
    497e:	6818      	ldr	r0, [r3, #0]
	while (r != NULL) {
    4980:	b188      	cbz	r0, 49a6 <ip_reass_tmr+0x2a>
{
    4982:	b570      	push	{r4, r5, r6, lr}
	while (r != NULL) {
    4984:	2400      	movs	r4, #0
			ip_reass_free_complete_datagram(tmp, prev);
    4986:	4e09      	ldr	r6, [pc, #36]	; (49ac <ip_reass_tmr+0x30>)
    4988:	e004      	b.n	4994 <ip_reass_tmr+0x18>
			r = r->next;
    498a:	6805      	ldr	r5, [r0, #0]
			ip_reass_free_complete_datagram(tmp, prev);
    498c:	4621      	mov	r1, r4
    498e:	47b0      	blx	r6
			r = r->next;
    4990:	4628      	mov	r0, r5
	while (r != NULL) {
    4992:	b138      	cbz	r0, 49a4 <ip_reass_tmr+0x28>
		if (r->timer > 0) {
    4994:	7fc3      	ldrb	r3, [r0, #31]
    4996:	2b00      	cmp	r3, #0
    4998:	d0f7      	beq.n	498a <ip_reass_tmr+0xe>
			r->timer--;
    499a:	3b01      	subs	r3, #1
    499c:	77c3      	strb	r3, [r0, #31]
    499e:	4604      	mov	r4, r0
			r    = r->next;
    49a0:	6800      	ldr	r0, [r0, #0]
    49a2:	e7f6      	b.n	4992 <ip_reass_tmr+0x16>
    49a4:	bd70      	pop	{r4, r5, r6, pc}
    49a6:	4770      	bx	lr
    49a8:	20001630 	.word	0x20001630
    49ac:	00004835 	.word	0x00004835

000049b0 <ip_reass>:
{
    49b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    49b4:	b083      	sub	sp, #12
    49b6:	4607      	mov	r7, r0
	fraghdr = (struct ip_hdr *)p->payload;
    49b8:	6846      	ldr	r6, [r0, #4]
	if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    49ba:	7833      	ldrb	r3, [r6, #0]
    49bc:	f003 030f 	and.w	r3, r3, #15
    49c0:	2b05      	cmp	r3, #5
    49c2:	d122      	bne.n	4a0a <ip_reass+0x5a>
	offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    49c4:	88f0      	ldrh	r0, [r6, #6]
    49c6:	4ca0      	ldr	r4, [pc, #640]	; (4c48 <ip_reass+0x298>)
    49c8:	47a0      	blx	r4
    49ca:	4683      	mov	fp, r0
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    49cc:	8870      	ldrh	r0, [r6, #2]
    49ce:	47a0      	blx	r4
    49d0:	9001      	str	r0, [sp, #4]
    49d2:	f896 a000 	ldrb.w	sl, [r6]
	clen = pbuf_clen(p);
    49d6:	4638      	mov	r0, r7
    49d8:	4b9c      	ldr	r3, [pc, #624]	; (4c4c <ip_reass+0x29c>)
    49da:	4798      	blx	r3
    49dc:	4680      	mov	r8, r0
	if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    49de:	4b9c      	ldr	r3, [pc, #624]	; (4c50 <ip_reass+0x2a0>)
    49e0:	889b      	ldrh	r3, [r3, #4]
    49e2:	4403      	add	r3, r0
    49e4:	2b0a      	cmp	r3, #10
    49e6:	dc06      	bgt.n	49f6 <ip_reass+0x46>
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    49e8:	4b99      	ldr	r3, [pc, #612]	; (4c50 <ip_reass+0x2a0>)
    49ea:	681c      	ldr	r4, [r3, #0]
    49ec:	2c00      	cmp	r4, #0
    49ee:	d079      	beq.n	4ae4 <ip_reass+0x134>
		if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    49f0:	68f2      	ldr	r2, [r6, #12]
    49f2:	2500      	movs	r5, #0
    49f4:	e014      	b.n	4a20 <ip_reass+0x70>
		if (!ip_reass_remove_oldest_datagram(fraghdr, clen) || ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
    49f6:	4601      	mov	r1, r0
    49f8:	4630      	mov	r0, r6
    49fa:	4b96      	ldr	r3, [pc, #600]	; (4c54 <ip_reass+0x2a4>)
    49fc:	4798      	blx	r3
    49fe:	b120      	cbz	r0, 4a0a <ip_reass+0x5a>
    4a00:	4b93      	ldr	r3, [pc, #588]	; (4c50 <ip_reass+0x2a0>)
    4a02:	889b      	ldrh	r3, [r3, #4]
    4a04:	4443      	add	r3, r8
    4a06:	2b0a      	cmp	r3, #10
    4a08:	ddee      	ble.n	49e8 <ip_reass+0x38>
	pbuf_free(p);
    4a0a:	4638      	mov	r0, r7
    4a0c:	4b92      	ldr	r3, [pc, #584]	; (4c58 <ip_reass+0x2a8>)
    4a0e:	4798      	blx	r3
	return NULL;
    4a10:	f04f 0800 	mov.w	r8, #0
    4a14:	e101      	b.n	4c1a <ip_reass+0x26a>
	for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    4a16:	6823      	ldr	r3, [r4, #0]
    4a18:	4625      	mov	r5, r4
    4a1a:	2b00      	cmp	r3, #0
    4a1c:	d062      	beq.n	4ae4 <ip_reass+0x134>
    4a1e:	461c      	mov	r4, r3
		if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    4a20:	6963      	ldr	r3, [r4, #20]
    4a22:	4293      	cmp	r3, r2
    4a24:	d1f7      	bne.n	4a16 <ip_reass+0x66>
    4a26:	6933      	ldr	r3, [r6, #16]
    4a28:	69a1      	ldr	r1, [r4, #24]
    4a2a:	4299      	cmp	r1, r3
    4a2c:	d1f3      	bne.n	4a16 <ip_reass+0x66>
    4a2e:	89a1      	ldrh	r1, [r4, #12]
    4a30:	88b3      	ldrh	r3, [r6, #4]
    4a32:	4299      	cmp	r1, r3
    4a34:	d1ef      	bne.n	4a16 <ip_reass+0x66>
	if (ipr == NULL) {
    4a36:	2c00      	cmp	r4, #0
    4a38:	d053      	beq.n	4ae2 <ip_reass+0x132>
		if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    4a3a:	88f0      	ldrh	r0, [r6, #6]
    4a3c:	4b82      	ldr	r3, [pc, #520]	; (4c48 <ip_reass+0x298>)
    4a3e:	4798      	blx	r3
    4a40:	f3c0 000c 	ubfx	r0, r0, #0, #13
    4a44:	2800      	cmp	r0, #0
    4a46:	f000 8084 	beq.w	4b52 <ip_reass+0x1a2>
	ip_reass_pbufcount += clen;
    4a4a:	4b81      	ldr	r3, [pc, #516]	; (4c50 <ip_reass+0x2a0>)
    4a4c:	889a      	ldrh	r2, [r3, #4]
    4a4e:	4490      	add	r8, r2
    4a50:	f8a3 8004 	strh.w	r8, [r3, #4]
	if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    4a54:	88f3      	ldrh	r3, [r6, #6]
    4a56:	f013 0f20 	tst.w	r3, #32
    4a5a:	d10c      	bne.n	4a76 <ip_reass+0xc6>
		ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    4a5c:	7fa3      	ldrb	r3, [r4, #30]
    4a5e:	f043 0301 	orr.w	r3, r3, #1
    4a62:	77a3      	strb	r3, [r4, #30]
	len    = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    4a64:	f00a 0a0f 	and.w	sl, sl, #15
    4a68:	9b01      	ldr	r3, [sp, #4]
    4a6a:	eba3 098a 	sub.w	r9, r3, sl, lsl #2
		ipr->datagram_len = offset + len;
    4a6e:	eb09 0bcb 	add.w	fp, r9, fp, lsl #3
    4a72:	f8a4 b01c 	strh.w	fp, [r4, #28]
	fraghdr = (struct ip_hdr *)new_p->payload;
    4a76:	687e      	ldr	r6, [r7, #4]
	len     = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    4a78:	8870      	ldrh	r0, [r6, #2]
    4a7a:	f8df 91cc 	ldr.w	r9, [pc, #460]	; 4c48 <ip_reass+0x298>
    4a7e:	47c8      	blx	r9
    4a80:	f896 8000 	ldrb.w	r8, [r6]
    4a84:	f008 080f 	and.w	r8, r8, #15
    4a88:	eba0 0888 	sub.w	r8, r0, r8, lsl #2
    4a8c:	fa1f f888 	uxth.w	r8, r8
	offset  = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    4a90:	88f0      	ldrh	r0, [r6, #6]
    4a92:	47c8      	blx	r9
    4a94:	f3c0 000c 	ubfx	r0, r0, #0, #13
    4a98:	00c0      	lsls	r0, r0, #3
	iprh            = (struct ip_reass_helper *)new_p->payload;
    4a9a:	f8d7 c004 	ldr.w	ip, [r7, #4]
	iprh->next_pbuf = NULL;
    4a9e:	2300      	movs	r3, #0
    4aa0:	f88c 3000 	strb.w	r3, [ip]
    4aa4:	f88c 3001 	strb.w	r3, [ip, #1]
    4aa8:	f88c 3002 	strb.w	r3, [ip, #2]
    4aac:	f88c 3003 	strb.w	r3, [ip, #3]
	iprh->start     = offset;
    4ab0:	f8ac 0004 	strh.w	r0, [ip, #4]
	iprh->end       = offset + len;
    4ab4:	4480      	add	r8, r0
    4ab6:	fa1f f888 	uxth.w	r8, r8
    4aba:	f8ac 8006 	strh.w	r8, [ip, #6]
	for (q = ipr->p; q != NULL;) {
    4abe:	6862      	ldr	r2, [r4, #4]
    4ac0:	2a00      	cmp	r2, #0
    4ac2:	f000 809a 	beq.w	4bfa <ip_reass+0x24a>
		iprh_tmp = (struct ip_reass_helper *)q->payload;
    4ac6:	6853      	ldr	r3, [r2, #4]
		if (iprh->start < iprh_tmp->start) {
    4ac8:	8899      	ldrh	r1, [r3, #4]
    4aca:	4288      	cmp	r0, r1
    4acc:	f0c0 80ad 	bcc.w	4c2a <ip_reass+0x27a>
		} else if (iprh->start == iprh_tmp->start) {
    4ad0:	f000 8097 	beq.w	4c02 <ip_reass+0x252>
		} else if (iprh->start < iprh_tmp->end) {
    4ad4:	88da      	ldrh	r2, [r3, #6]
    4ad6:	4282      	cmp	r2, r0
    4ad8:	f200 8093 	bhi.w	4c02 <ip_reass+0x252>
    4adc:	f04f 0e01 	mov.w	lr, #1
    4ae0:	e078      	b.n	4bd4 <ip_reass+0x224>
    4ae2:	462c      	mov	r4, r5
	ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    4ae4:	2005      	movs	r0, #5
    4ae6:	4b5d      	ldr	r3, [pc, #372]	; (4c5c <ip_reass+0x2ac>)
    4ae8:	4798      	blx	r3
	if (ipr == NULL) {
    4aea:	4681      	mov	r9, r0
    4aec:	b318      	cbz	r0, 4b36 <ip_reass+0x186>
	memset(ipr, 0, sizeof(struct ip_reassdata));
    4aee:	2220      	movs	r2, #32
    4af0:	2100      	movs	r1, #0
    4af2:	4648      	mov	r0, r9
    4af4:	4b5a      	ldr	r3, [pc, #360]	; (4c60 <ip_reass+0x2b0>)
    4af6:	4798      	blx	r3
	ipr->timer = IP_REASS_MAXAGE;
    4af8:	2303      	movs	r3, #3
    4afa:	f889 301f 	strb.w	r3, [r9, #31]
	ipr->next      = reassdatagrams;
    4afe:	4b54      	ldr	r3, [pc, #336]	; (4c50 <ip_reass+0x2a0>)
    4b00:	681a      	ldr	r2, [r3, #0]
    4b02:	f8c9 2000 	str.w	r2, [r9]
	reassdatagrams = ipr;
    4b06:	f8c3 9000 	str.w	r9, [r3]
	SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    4b0a:	6832      	ldr	r2, [r6, #0]
    4b0c:	6875      	ldr	r5, [r6, #4]
    4b0e:	68b0      	ldr	r0, [r6, #8]
    4b10:	68f1      	ldr	r1, [r6, #12]
    4b12:	f8c9 2008 	str.w	r2, [r9, #8]
    4b16:	f8c9 500c 	str.w	r5, [r9, #12]
    4b1a:	f8c9 0010 	str.w	r0, [r9, #16]
    4b1e:	f8c9 1014 	str.w	r1, [r9, #20]
    4b22:	6932      	ldr	r2, [r6, #16]
    4b24:	f8c9 2018 	str.w	r2, [r9, #24]
		if (ipr == NULL) {
    4b28:	f1b9 0f00 	cmp.w	r9, #0
    4b2c:	f43f af6d 	beq.w	4a0a <ip_reass+0x5a>
    4b30:	4625      	mov	r5, r4
	return ipr;
    4b32:	464c      	mov	r4, r9
    4b34:	e789      	b.n	4a4a <ip_reass+0x9a>
		if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
    4b36:	4641      	mov	r1, r8
    4b38:	4630      	mov	r0, r6
    4b3a:	4b46      	ldr	r3, [pc, #280]	; (4c54 <ip_reass+0x2a4>)
    4b3c:	4798      	blx	r3
    4b3e:	4580      	cmp	r8, r0
    4b40:	f73f af63 	bgt.w	4a0a <ip_reass+0x5a>
			ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    4b44:	2005      	movs	r0, #5
    4b46:	4b45      	ldr	r3, [pc, #276]	; (4c5c <ip_reass+0x2ac>)
    4b48:	4798      	blx	r3
		if (ipr == NULL)
    4b4a:	4681      	mov	r9, r0
    4b4c:	2800      	cmp	r0, #0
    4b4e:	d1ce      	bne.n	4aee <ip_reass+0x13e>
    4b50:	e75b      	b.n	4a0a <ip_reass+0x5a>
		if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    4b52:	89e0      	ldrh	r0, [r4, #14]
    4b54:	4b3c      	ldr	r3, [pc, #240]	; (4c48 <ip_reass+0x298>)
    4b56:	4798      	blx	r3
    4b58:	f3c0 000c 	ubfx	r0, r0, #0, #13
    4b5c:	2800      	cmp	r0, #0
    4b5e:	f43f af74 	beq.w	4a4a <ip_reass+0x9a>
			SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    4b62:	6832      	ldr	r2, [r6, #0]
    4b64:	f8d6 e004 	ldr.w	lr, [r6, #4]
    4b68:	68b0      	ldr	r0, [r6, #8]
    4b6a:	68f1      	ldr	r1, [r6, #12]
    4b6c:	60a2      	str	r2, [r4, #8]
    4b6e:	f8c4 e00c 	str.w	lr, [r4, #12]
    4b72:	6120      	str	r0, [r4, #16]
    4b74:	6161      	str	r1, [r4, #20]
    4b76:	6932      	ldr	r2, [r6, #16]
    4b78:	61a2      	str	r2, [r4, #24]
    4b7a:	e766      	b.n	4a4a <ip_reass+0x9a>
			iprh->next_pbuf = q;
    4b7c:	f8cc 6000 	str.w	r6, [ip]
			if (iprh_prev != NULL) {
    4b80:	2b00      	cmp	r3, #0
    4b82:	d056      	beq.n	4c32 <ip_reass+0x282>
				if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
    4b84:	88d9      	ldrh	r1, [r3, #6]
    4b86:	4281      	cmp	r1, r0
    4b88:	d83b      	bhi.n	4c02 <ip_reass+0x252>
    4b8a:	8892      	ldrh	r2, [r2, #4]
    4b8c:	4542      	cmp	r2, r8
    4b8e:	d338      	bcc.n	4c02 <ip_reass+0x252>
				iprh_prev->next_pbuf = new_p;
    4b90:	601f      	str	r7, [r3, #0]
	if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    4b92:	7fa3      	ldrb	r3, [r4, #30]
    4b94:	f013 0f01 	tst.w	r3, #1
    4b98:	d03d      	beq.n	4c16 <ip_reass+0x266>
		if (valid) {
    4b9a:	f1be 0f00 	cmp.w	lr, #0
    4b9e:	d03a      	beq.n	4c16 <ip_reass+0x266>
			if (((struct ip_reass_helper *)ipr->p->payload)->start != 0) {
    4ba0:	6860      	ldr	r0, [r4, #4]
    4ba2:	6843      	ldr	r3, [r0, #4]
    4ba4:	889b      	ldrh	r3, [r3, #4]
    4ba6:	2b00      	cmp	r3, #0
    4ba8:	d135      	bne.n	4c16 <ip_reass+0x266>
				q         = iprh->next_pbuf;
    4baa:	f8dc 3000 	ldr.w	r3, [ip]
				while (q != NULL) {
    4bae:	2b00      	cmp	r3, #0
    4bb0:	d058      	beq.n	4c64 <ip_reass+0x2b4>
					iprh = (struct ip_reass_helper *)q->payload;
    4bb2:	685b      	ldr	r3, [r3, #4]
					if (iprh_prev->end != iprh->start) {
    4bb4:	8899      	ldrh	r1, [r3, #4]
    4bb6:	f8bc 2006 	ldrh.w	r2, [ip, #6]
    4bba:	4291      	cmp	r1, r2
    4bbc:	d12b      	bne.n	4c16 <ip_reass+0x266>
					q         = iprh->next_pbuf;
    4bbe:	681a      	ldr	r2, [r3, #0]
				while (q != NULL) {
    4bc0:	2a00      	cmp	r2, #0
    4bc2:	d04f      	beq.n	4c64 <ip_reass+0x2b4>
					iprh = (struct ip_reass_helper *)q->payload;
    4bc4:	6852      	ldr	r2, [r2, #4]
					if (iprh_prev->end != iprh->start) {
    4bc6:	88d9      	ldrh	r1, [r3, #6]
    4bc8:	8893      	ldrh	r3, [r2, #4]
    4bca:	4299      	cmp	r1, r3
    4bcc:	d123      	bne.n	4c16 <ip_reass+0x266>
					iprh = (struct ip_reass_helper *)q->payload;
    4bce:	4613      	mov	r3, r2
    4bd0:	e7f5      	b.n	4bbe <ip_reass+0x20e>
		iprh_tmp = (struct ip_reass_helper *)q->payload;
    4bd2:	4613      	mov	r3, r2
		q         = iprh_tmp->next_pbuf;
    4bd4:	681e      	ldr	r6, [r3, #0]
	for (q = ipr->p; q != NULL;) {
    4bd6:	b376      	cbz	r6, 4c36 <ip_reass+0x286>
		iprh_tmp = (struct ip_reass_helper *)q->payload;
    4bd8:	6872      	ldr	r2, [r6, #4]
		if (iprh->start < iprh_tmp->start) {
    4bda:	8891      	ldrh	r1, [r2, #4]
    4bdc:	4288      	cmp	r0, r1
    4bde:	d3cd      	bcc.n	4b7c <ip_reass+0x1cc>
		} else if (iprh->start == iprh_tmp->start) {
    4be0:	4288      	cmp	r0, r1
    4be2:	d00e      	beq.n	4c02 <ip_reass+0x252>
		} else if (iprh->start < iprh_tmp->end) {
    4be4:	88d6      	ldrh	r6, [r2, #6]
    4be6:	4286      	cmp	r6, r0
    4be8:	d80b      	bhi.n	4c02 <ip_reass+0x252>
			if (iprh_prev != NULL) {
    4bea:	2b00      	cmp	r3, #0
    4bec:	d0f1      	beq.n	4bd2 <ip_reass+0x222>
				if (iprh_prev->end != iprh_tmp->start) {
    4bee:	88db      	ldrh	r3, [r3, #6]
					valid = 0;
    4bf0:	428b      	cmp	r3, r1
    4bf2:	bf18      	it	ne
    4bf4:	f04f 0e00 	movne.w	lr, #0
    4bf8:	e7eb      	b.n	4bd2 <ip_reass+0x222>
	int                     valid = 1;
    4bfa:	f04f 0e01 	mov.w	lr, #1
			ipr->p = new_p;
    4bfe:	6067      	str	r7, [r4, #4]
    4c00:	e7c7      	b.n	4b92 <ip_reass+0x1e2>
	ip_reass_pbufcount -= pbuf_clen(new_p);
    4c02:	4638      	mov	r0, r7
    4c04:	4b11      	ldr	r3, [pc, #68]	; (4c4c <ip_reass+0x29c>)
    4c06:	4798      	blx	r3
    4c08:	4a11      	ldr	r2, [pc, #68]	; (4c50 <ip_reass+0x2a0>)
    4c0a:	8893      	ldrh	r3, [r2, #4]
    4c0c:	1a18      	subs	r0, r3, r0
    4c0e:	8090      	strh	r0, [r2, #4]
	pbuf_free(new_p);
    4c10:	4638      	mov	r0, r7
    4c12:	4b11      	ldr	r3, [pc, #68]	; (4c58 <ip_reass+0x2a8>)
    4c14:	4798      	blx	r3
	return NULL;
    4c16:	f04f 0800 	mov.w	r8, #0
}
    4c1a:	4640      	mov	r0, r8
    4c1c:	b003      	add	sp, #12
    4c1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		reassdatagrams = ipr->next;
    4c22:	6822      	ldr	r2, [r4, #0]
    4c24:	4b0a      	ldr	r3, [pc, #40]	; (4c50 <ip_reass+0x2a0>)
    4c26:	601a      	str	r2, [r3, #0]
    4c28:	e056      	b.n	4cd8 <ip_reass+0x328>
			iprh->next_pbuf = q;
    4c2a:	f8cc 2000 	str.w	r2, [ip]
	int                     valid = 1;
    4c2e:	f04f 0e01 	mov.w	lr, #1
				ipr->p = new_p;
    4c32:	6067      	str	r7, [r4, #4]
    4c34:	e7ad      	b.n	4b92 <ip_reass+0x1e2>
		if (iprh_prev != NULL) {
    4c36:	2b00      	cmp	r3, #0
    4c38:	d0e1      	beq.n	4bfe <ip_reass+0x24e>
			iprh_prev->next_pbuf = new_p;
    4c3a:	601f      	str	r7, [r3, #0]
			if (iprh_prev->end != iprh->start) {
    4c3c:	88da      	ldrh	r2, [r3, #6]
    4c3e:	f8bc 3004 	ldrh.w	r3, [ip, #4]
    4c42:	429a      	cmp	r2, r3
    4c44:	d1e7      	bne.n	4c16 <ip_reass+0x266>
    4c46:	e7a4      	b.n	4b92 <ip_reass+0x1e2>
    4c48:	000026ef 	.word	0x000026ef
    4c4c:	000056cd 	.word	0x000056cd
    4c50:	20001630 	.word	0x20001630
    4c54:	000048e5 	.word	0x000048e5
    4c58:	000054c9 	.word	0x000054c9
    4c5c:	000051b9 	.word	0x000051b9
    4c60:	00009805 	.word	0x00009805
		ipr->datagram_len += IP_HLEN;
    4c64:	8ba3      	ldrh	r3, [r4, #28]
    4c66:	3314      	adds	r3, #20
    4c68:	83a3      	strh	r3, [r4, #28]
		r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
    4c6a:	6847      	ldr	r7, [r0, #4]
    4c6c:	683e      	ldr	r6, [r7, #0]
		SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    4c6e:	4623      	mov	r3, r4
    4c70:	f853 2f08 	ldr.w	r2, [r3, #8]!
    4c74:	f8d3 e004 	ldr.w	lr, [r3, #4]
    4c78:	6898      	ldr	r0, [r3, #8]
    4c7a:	68d9      	ldr	r1, [r3, #12]
    4c7c:	603a      	str	r2, [r7, #0]
    4c7e:	f8c7 e004 	str.w	lr, [r7, #4]
    4c82:	60b8      	str	r0, [r7, #8]
    4c84:	60f9      	str	r1, [r7, #12]
    4c86:	691a      	ldr	r2, [r3, #16]
    4c88:	613a      	str	r2, [r7, #16]
		IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    4c8a:	8ba0      	ldrh	r0, [r4, #28]
    4c8c:	4b18      	ldr	r3, [pc, #96]	; (4cf0 <ip_reass+0x340>)
    4c8e:	4798      	blx	r3
    4c90:	8078      	strh	r0, [r7, #2]
		IPH_OFFSET_SET(fraghdr, 0);
    4c92:	2300      	movs	r3, #0
    4c94:	71bb      	strb	r3, [r7, #6]
    4c96:	71fb      	strb	r3, [r7, #7]
		IPH_CHKSUM_SET(fraghdr, 0);
    4c98:	72bb      	strb	r3, [r7, #10]
    4c9a:	72fb      	strb	r3, [r7, #11]
		IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    4c9c:	2114      	movs	r1, #20
    4c9e:	4638      	mov	r0, r7
    4ca0:	4b14      	ldr	r3, [pc, #80]	; (4cf4 <ip_reass+0x344>)
    4ca2:	4798      	blx	r3
    4ca4:	8178      	strh	r0, [r7, #10]
		p = ipr->p;
    4ca6:	f8d4 8004 	ldr.w	r8, [r4, #4]
		while (r != NULL) {
    4caa:	b17e      	cbz	r6, 4ccc <ip_reass+0x31c>
			pbuf_header(r, -IP_HLEN);
    4cac:	f06f 0b13 	mvn.w	fp, #19
    4cb0:	f8df a050 	ldr.w	sl, [pc, #80]	; 4d04 <ip_reass+0x354>
			pbuf_cat(p, r);
    4cb4:	f8df 9050 	ldr.w	r9, [pc, #80]	; 4d08 <ip_reass+0x358>
			iprh = (struct ip_reass_helper *)r->payload;
    4cb8:	6877      	ldr	r7, [r6, #4]
			pbuf_header(r, -IP_HLEN);
    4cba:	4659      	mov	r1, fp
    4cbc:	4630      	mov	r0, r6
    4cbe:	47d0      	blx	sl
			pbuf_cat(p, r);
    4cc0:	4631      	mov	r1, r6
    4cc2:	4640      	mov	r0, r8
    4cc4:	47c8      	blx	r9
			r = iprh->next_pbuf;
    4cc6:	683e      	ldr	r6, [r7, #0]
		while (r != NULL) {
    4cc8:	2e00      	cmp	r6, #0
    4cca:	d1f5      	bne.n	4cb8 <ip_reass+0x308>
	if (reassdatagrams == ipr) {
    4ccc:	4b0a      	ldr	r3, [pc, #40]	; (4cf8 <ip_reass+0x348>)
    4cce:	681b      	ldr	r3, [r3, #0]
    4cd0:	429c      	cmp	r4, r3
    4cd2:	d0a6      	beq.n	4c22 <ip_reass+0x272>
		prev->next = ipr->next;
    4cd4:	6823      	ldr	r3, [r4, #0]
    4cd6:	602b      	str	r3, [r5, #0]
	memp_free(MEMP_REASSDATA, ipr);
    4cd8:	4621      	mov	r1, r4
    4cda:	2005      	movs	r0, #5
    4cdc:	4b07      	ldr	r3, [pc, #28]	; (4cfc <ip_reass+0x34c>)
    4cde:	4798      	blx	r3
		ip_reass_pbufcount -= pbuf_clen(p);
    4ce0:	4640      	mov	r0, r8
    4ce2:	4b07      	ldr	r3, [pc, #28]	; (4d00 <ip_reass+0x350>)
    4ce4:	4798      	blx	r3
    4ce6:	4a04      	ldr	r2, [pc, #16]	; (4cf8 <ip_reass+0x348>)
    4ce8:	8893      	ldrh	r3, [r2, #4]
    4cea:	1a18      	subs	r0, r3, r0
    4cec:	8090      	strh	r0, [r2, #4]
		return p;
    4cee:	e794      	b.n	4c1a <ip_reass+0x26a>
    4cf0:	000026e5 	.word	0x000026e5
    4cf4:	00004369 	.word	0x00004369
    4cf8:	20001630 	.word	0x20001630
    4cfc:	00005201 	.word	0x00005201
    4d00:	000056cd 	.word	0x000056cd
    4d04:	00005435 	.word	0x00005435
    4d08:	000056ed 	.word	0x000056ed

00004d0c <ip_frag>:
 * @param dest destination ip address to which to send
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
    4d0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4d10:	b091      	sub	sp, #68	; 0x44
    4d12:	4605      	mov	r5, r0
    4d14:	910d      	str	r1, [sp, #52]	; 0x34
    4d16:	920e      	str	r2, [sp, #56]	; 0x38
	struct ip_hdr *original_iphdr;
#endif
	struct ip_hdr *iphdr;
	u16_t          nfb;
	u16_t          left, cop;
	u16_t          mtu = netif->mtu;
    4d18:	8d8c      	ldrh	r4, [r1, #44]	; 0x2c

	/* Copy the IP header in it */
	iphdr = (struct ip_hdr *)rambuf->payload;
	SMEMCPY(iphdr, p->payload, IP_HLEN);
#else  /* IP_FRAG_USES_STATIC_BUF */
	original_iphdr = (struct ip_hdr *)p->payload;
    4d1a:	f8d0 b004 	ldr.w	fp, [r0, #4]
	iphdr          = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

	/* Save original offset */
	tmp = ntohs(IPH_OFFSET(iphdr));
    4d1e:	f8bb 0006 	ldrh.w	r0, [fp, #6]
    4d22:	4b65      	ldr	r3, [pc, #404]	; (4eb8 <ip_frag+0x1ac>)
    4d24:	4798      	blx	r3
	ofo = tmp & IP_OFFMASK;
    4d26:	f3c0 030c 	ubfx	r3, r0, #0, #13
    4d2a:	9307      	str	r3, [sp, #28]
	omf = tmp & IP_MF;
    4d2c:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
    4d30:	930b      	str	r3, [sp, #44]	; 0x2c

	left = p->tot_len - IP_HLEN;
    4d32:	f8b5 9008 	ldrh.w	r9, [r5, #8]
    4d36:	f1a9 0914 	sub.w	r9, r9, #20
    4d3a:	fa1f f389 	uxth.w	r3, r9
    4d3e:	9305      	str	r3, [sp, #20]

	nfb = (mtu - IP_HLEN) / 8;
    4d40:	f1a4 0314 	sub.w	r3, r4, #20
    4d44:	930a      	str	r3, [sp, #40]	; 0x28
    4d46:	2b00      	cmp	r3, #0
    4d48:	bfb8      	it	lt
    4d4a:	3307      	addlt	r3, #7
    4d4c:	f3c3 03cf 	ubfx	r3, r3, #3, #16
    4d50:	930c      	str	r3, [sp, #48]	; 0x30

	while (left) {
    4d52:	9a05      	ldr	r2, [sp, #20]
    4d54:	2a00      	cmp	r2, #0
    4d56:	f000 80a9 	beq.w	4eac <ip_frag+0x1a0>
		if (!last) {
			tmp = tmp | IP_MF;
		}

		/* Fill this fragment */
		cop = last ? left : nfb * 8;
    4d5a:	00db      	lsls	r3, r3, #3
    4d5c:	b29b      	uxth	r3, r3
    4d5e:	930f      	str	r3, [sp, #60]	; 0x3c
    4d60:	2400      	movs	r4, #0
    4d62:	2614      	movs	r6, #20
	return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
    4d64:	f8df a170 	ldr.w	sl, [pc, #368]	; 4ed8 <ip_frag+0x1cc>
			if (pcr == NULL) {
				pbuf_free(rambuf);
				return ERR_MEM;
			}
			/* Mirror this pbuf, although we might not need all of it. */
			newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
    4d68:	f8df 9170 	ldr.w	r9, [pc, #368]	; 4edc <ip_frag+0x1d0>
			if (newpbuf == NULL) {
				ip_frag_free_pbuf_custom_ref(pcr);
				pbuf_free(rambuf);
				return ERR_MEM;
			}
			pbuf_ref(p);
    4d6c:	f8df 8170 	ldr.w	r8, [pc, #368]	; 4ee0 <ip_frag+0x1d4>
    4d70:	e052      	b.n	4e18 <ip_frag+0x10c>
	return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
    4d72:	2006      	movs	r0, #6
    4d74:	47d0      	blx	sl
			if (pcr == NULL) {
    4d76:	4607      	mov	r7, r0
    4d78:	2800      	cmp	r0, #0
    4d7a:	f000 8083 	beq.w	4e84 <ip_frag+0x178>
			newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
    4d7e:	9401      	str	r4, [sp, #4]
    4d80:	686b      	ldr	r3, [r5, #4]
    4d82:	9300      	str	r3, [sp, #0]
    4d84:	4603      	mov	r3, r0
    4d86:	2202      	movs	r2, #2
    4d88:	4621      	mov	r1, r4
    4d8a:	2003      	movs	r0, #3
    4d8c:	47c8      	blx	r9
			if (newpbuf == NULL) {
    4d8e:	9003      	str	r0, [sp, #12]
    4d90:	2800      	cmp	r0, #0
    4d92:	d07f      	beq.n	4e94 <ip_frag+0x188>
			pbuf_ref(p);
    4d94:	4628      	mov	r0, r5
    4d96:	47c0      	blx	r8
			pcr->original                = p;
    4d98:	617d      	str	r5, [r7, #20]
			pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
    4d9a:	4b48      	ldr	r3, [pc, #288]	; (4ebc <ip_frag+0x1b0>)
    4d9c:	613b      	str	r3, [r7, #16]

			/* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
			 * so that it is removed when pbuf_dechain is later called on rambuf.
			 */
			pbuf_cat(rambuf, newpbuf);
    4d9e:	9903      	ldr	r1, [sp, #12]
    4da0:	9804      	ldr	r0, [sp, #16]
    4da2:	4b47      	ldr	r3, [pc, #284]	; (4ec0 <ip_frag+0x1b4>)
    4da4:	4798      	blx	r3
			left_to_copy -= newpbuflen;
    4da6:	1b36      	subs	r6, r6, r4
    4da8:	b2b6      	uxth	r6, r6
			if (left_to_copy) {
    4daa:	b15e      	cbz	r6, 4dc4 <ip_frag+0xb8>
				p = p->next;
    4dac:	682d      	ldr	r5, [r5, #0]
			newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
    4dae:	896c      	ldrh	r4, [r5, #10]
    4db0:	42b4      	cmp	r4, r6
    4db2:	bf28      	it	cs
    4db4:	4634      	movcs	r4, r6
    4db6:	b2a4      	uxth	r4, r4
			if (!newpbuflen) {
    4db8:	2c00      	cmp	r4, #0
    4dba:	d1da      	bne.n	4d72 <ip_frag+0x66>
				p = p->next;
    4dbc:	682d      	ldr	r5, [r5, #0]
		while (left_to_copy) {
    4dbe:	2e00      	cmp	r6, #0
    4dc0:	d1f5      	bne.n	4dae <ip_frag+0xa2>
    4dc2:	4634      	mov	r4, r6
		poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

		/* Correct header */
		IPH_OFFSET_SET(iphdr, htons(tmp));
    4dc4:	9808      	ldr	r0, [sp, #32]
    4dc6:	4e3f      	ldr	r6, [pc, #252]	; (4ec4 <ip_frag+0x1b8>)
    4dc8:	47b0      	blx	r6
    4dca:	9f09      	ldr	r7, [sp, #36]	; 0x24
    4dcc:	80f8      	strh	r0, [r7, #6]
		IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    4dce:	9b06      	ldr	r3, [sp, #24]
    4dd0:	f103 0014 	add.w	r0, r3, #20
    4dd4:	b280      	uxth	r0, r0
    4dd6:	47b0      	blx	r6
    4dd8:	8078      	strh	r0, [r7, #2]
		IPH_CHKSUM_SET(iphdr, 0);
    4dda:	2300      	movs	r3, #0
    4ddc:	72bb      	strb	r3, [r7, #10]
    4dde:	4638      	mov	r0, r7
    4de0:	72fb      	strb	r3, [r7, #11]
		IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    4de2:	2114      	movs	r1, #20
    4de4:	4b38      	ldr	r3, [pc, #224]	; (4ec8 <ip_frag+0x1bc>)
    4de6:	4798      	blx	r3
    4de8:	8178      	strh	r0, [r7, #10]
		}
#else  /* IP_FRAG_USES_STATIC_BUF */
        /* No need for separate header pbuf - we allowed room for it in rambuf
         * when allocated.
         */
        netif->output(netif, rambuf, dest);
    4dea:	980d      	ldr	r0, [sp, #52]	; 0x34
    4dec:	6943      	ldr	r3, [r0, #20]
    4dee:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    4df0:	9e04      	ldr	r6, [sp, #16]
    4df2:	4631      	mov	r1, r6
    4df4:	4798      	blx	r3
         * recreate it next time round the loop. If we're lucky the hardware
         * will have already sent the packet, the free will really free, and
         * there will be zero memory penalty.
         */

        pbuf_free(rambuf);
    4df6:	4630      	mov	r0, r6
    4df8:	4b34      	ldr	r3, [pc, #208]	; (4ecc <ip_frag+0x1c0>)
    4dfa:	4798      	blx	r3
#endif /* IP_FRAG_USES_STATIC_BUF */
		left -= cop;
    4dfc:	9a05      	ldr	r2, [sp, #20]
    4dfe:	9b06      	ldr	r3, [sp, #24]
    4e00:	1ad3      	subs	r3, r2, r3
    4e02:	b29b      	uxth	r3, r3
    4e04:	461a      	mov	r2, r3
    4e06:	9305      	str	r3, [sp, #20]
		ofo += nfb;
    4e08:	9b07      	ldr	r3, [sp, #28]
    4e0a:	990c      	ldr	r1, [sp, #48]	; 0x30
    4e0c:	440b      	add	r3, r1
    4e0e:	b29b      	uxth	r3, r3
    4e10:	9307      	str	r3, [sp, #28]
    4e12:	4626      	mov	r6, r4
	while (left) {
    4e14:	2a00      	cmp	r2, #0
    4e16:	d047      	beq.n	4ea8 <ip_frag+0x19c>
		tmp = omf | (IP_OFFMASK & (ofo));
    4e18:	9b07      	ldr	r3, [sp, #28]
    4e1a:	f3c3 030c 	ubfx	r3, r3, #0, #13
    4e1e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    4e20:	4313      	orrs	r3, r2
    4e22:	9308      	str	r3, [sp, #32]
		if (!last) {
    4e24:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    4e26:	9905      	ldr	r1, [sp, #20]
    4e28:	428a      	cmp	r2, r1
			tmp = tmp | IP_MF;
    4e2a:	bfbd      	ittte	lt
    4e2c:	f443 5300 	orrlt.w	r3, r3, #8192	; 0x2000
    4e30:	9308      	strlt	r3, [sp, #32]
		cop = last ? left : nfb * 8;
    4e32:	9b0f      	ldrlt	r3, [sp, #60]	; 0x3c
    4e34:	9b05      	ldrge	r3, [sp, #20]
    4e36:	9306      	str	r3, [sp, #24]
		rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    4e38:	2200      	movs	r2, #0
    4e3a:	2114      	movs	r1, #20
    4e3c:	2002      	movs	r0, #2
    4e3e:	4b24      	ldr	r3, [pc, #144]	; (4ed0 <ip_frag+0x1c4>)
    4e40:	4798      	blx	r3
		if (rambuf == NULL) {
    4e42:	9004      	str	r0, [sp, #16]
    4e44:	2800      	cmp	r0, #0
    4e46:	d033      	beq.n	4eb0 <ip_frag+0x1a4>
		SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    4e48:	6843      	ldr	r3, [r0, #4]
    4e4a:	f8db 2000 	ldr.w	r2, [fp]
    4e4e:	f8db 7004 	ldr.w	r7, [fp, #4]
    4e52:	f8db 0008 	ldr.w	r0, [fp, #8]
    4e56:	f8db 100c 	ldr.w	r1, [fp, #12]
    4e5a:	601a      	str	r2, [r3, #0]
    4e5c:	605f      	str	r7, [r3, #4]
    4e5e:	6098      	str	r0, [r3, #8]
    4e60:	60d9      	str	r1, [r3, #12]
    4e62:	f8db 2010 	ldr.w	r2, [fp, #16]
    4e66:	611a      	str	r2, [r3, #16]
		iphdr = (struct ip_hdr *)rambuf->payload;
    4e68:	9b04      	ldr	r3, [sp, #16]
    4e6a:	685b      	ldr	r3, [r3, #4]
    4e6c:	9309      	str	r3, [sp, #36]	; 0x24
		p->payload = (u8_t *)p->payload + poff;
    4e6e:	686b      	ldr	r3, [r5, #4]
    4e70:	4433      	add	r3, r6
    4e72:	606b      	str	r3, [r5, #4]
		p->len -= poff;
    4e74:	896b      	ldrh	r3, [r5, #10]
    4e76:	1b9e      	subs	r6, r3, r6
    4e78:	816e      	strh	r6, [r5, #10]
		while (left_to_copy) {
    4e7a:	9b06      	ldr	r3, [sp, #24]
    4e7c:	2b00      	cmp	r3, #0
    4e7e:	d0a1      	beq.n	4dc4 <ip_frag+0xb8>
    4e80:	461e      	mov	r6, r3
    4e82:	e794      	b.n	4dae <ip_frag+0xa2>
				pbuf_free(rambuf);
    4e84:	9804      	ldr	r0, [sp, #16]
    4e86:	4b11      	ldr	r3, [pc, #68]	; (4ecc <ip_frag+0x1c0>)
    4e88:	4798      	blx	r3
				return ERR_MEM;
    4e8a:	f04f 30ff 	mov.w	r0, #4294967295
#if IP_FRAG_USES_STATIC_BUF
	pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
	snmp_inc_ipfragoks();
	return ERR_OK;
}
    4e8e:	b011      	add	sp, #68	; 0x44
    4e90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	memp_free(MEMP_FRAG_PBUF, p);
    4e94:	4639      	mov	r1, r7
    4e96:	2006      	movs	r0, #6
    4e98:	4b0e      	ldr	r3, [pc, #56]	; (4ed4 <ip_frag+0x1c8>)
    4e9a:	4798      	blx	r3
				pbuf_free(rambuf);
    4e9c:	9804      	ldr	r0, [sp, #16]
    4e9e:	4b0b      	ldr	r3, [pc, #44]	; (4ecc <ip_frag+0x1c0>)
    4ea0:	4798      	blx	r3
				return ERR_MEM;
    4ea2:	f04f 30ff 	mov.w	r0, #4294967295
    4ea6:	e7f2      	b.n	4e8e <ip_frag+0x182>
	return ERR_OK;
    4ea8:	2000      	movs	r0, #0
    4eaa:	e7f0      	b.n	4e8e <ip_frag+0x182>
    4eac:	2000      	movs	r0, #0
    4eae:	e7ee      	b.n	4e8e <ip_frag+0x182>
			return ERR_MEM;
    4eb0:	f04f 30ff 	mov.w	r0, #4294967295
    4eb4:	e7eb      	b.n	4e8e <ip_frag+0x182>
    4eb6:	bf00      	nop
    4eb8:	000026ef 	.word	0x000026ef
    4ebc:	0000495d 	.word	0x0000495d
    4ec0:	000056ed 	.word	0x000056ed
    4ec4:	000026e5 	.word	0x000026e5
    4ec8:	00004369 	.word	0x00004369
    4ecc:	000054c9 	.word	0x000054c9
    4ed0:	00005531 	.word	0x00005531
    4ed4:	00005201 	.word	0x00005201
    4ed8:	000051b9 	.word	0x000051b9
    4edc:	000053d5 	.word	0x000053d5
    4ee0:	000056e3 	.word	0x000056e3

00004ee4 <mem_init>:
	struct mem *mem;

	LWIP_ASSERT("Sanity check alignment", (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

	/* align the heap */
	ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    4ee4:	4b0a      	ldr	r3, [pc, #40]	; (4f10 <mem_init+0x2c>)
    4ee6:	f023 0303 	bic.w	r3, r3, #3
    4eea:	4a0a      	ldr	r2, [pc, #40]	; (4f14 <mem_init+0x30>)
    4eec:	6013      	str	r3, [r2, #0]
	/* initialize the start of the heap */
	mem       = (struct mem *)(void *)ram;
	mem->next = MEM_SIZE_ALIGNED;
    4eee:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
    4ef2:	8019      	strh	r1, [r3, #0]
	mem->prev = 0;
    4ef4:	2000      	movs	r0, #0
    4ef6:	8058      	strh	r0, [r3, #2]
	mem->used = 0;
    4ef8:	7118      	strb	r0, [r3, #4]
	/* initialize the end of the heap */
	ram_end       = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
    4efa:	1858      	adds	r0, r3, r1
    4efc:	6050      	str	r0, [r2, #4]
	ram_end->used = 1;
    4efe:	2001      	movs	r0, #1
    4f00:	f883 0fa4 	strb.w	r0, [r3, #4004]	; 0xfa4
	ram_end->next = MEM_SIZE_ALIGNED;
    4f04:	f8a3 1fa0 	strh.w	r1, [r3, #4000]	; 0xfa0
	ram_end->prev = MEM_SIZE_ALIGNED;
    4f08:	f8a3 1fa2 	strh.w	r1, [r3, #4002]	; 0xfa2

	/* initialize the lowest-free pointer to the start of the heap */
	lfree = (struct mem *)(void *)ram;
    4f0c:	6093      	str	r3, [r2, #8]
    4f0e:	4770      	bx	lr
    4f10:	2000831f 	.word	0x2000831f
    4f14:	20001638 	.word	0x20001638

00004f18 <mem_free>:
void mem_free(void *rmem)
{
	struct mem *mem;
	LWIP_MEM_FREE_DECL_PROTECT();

	if (rmem == NULL) {
    4f18:	2800      	cmp	r0, #0
    4f1a:	d03f      	beq.n	4f9c <mem_free+0x84>
    4f1c:	4603      	mov	r3, r0
	}
	LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) == 0);

	LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram && (u8_t *)rmem < (u8_t *)ram_end);

	if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    4f1e:	4a20      	ldr	r2, [pc, #128]	; (4fa0 <mem_free+0x88>)
    4f20:	6812      	ldr	r2, [r2, #0]
    4f22:	4290      	cmp	r0, r2
    4f24:	d33a      	bcc.n	4f9c <mem_free+0x84>
    4f26:	491e      	ldr	r1, [pc, #120]	; (4fa0 <mem_free+0x88>)
    4f28:	6848      	ldr	r0, [r1, #4]
    4f2a:	4283      	cmp	r3, r0
    4f2c:	d236      	bcs.n	4f9c <mem_free+0x84>
{
    4f2e:	b470      	push	{r4, r5, r6}
		return;
	}
	/* protect the heap from concurrent access */
	LWIP_MEM_FREE_PROTECT();
	/* Get the corresponding struct mem ... */
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    4f30:	f1a3 0108 	sub.w	r1, r3, #8
	/* ... which has to be in a used state ... */
	LWIP_ASSERT("mem_free: mem->used", mem->used);
	/* ... and is now unused. */
	mem->used = 0;
    4f34:	2400      	movs	r4, #0
    4f36:	f803 4c04 	strb.w	r4, [r3, #-4]

	if (mem < lfree) {
    4f3a:	4c19      	ldr	r4, [pc, #100]	; (4fa0 <mem_free+0x88>)
    4f3c:	68a4      	ldr	r4, [r4, #8]
    4f3e:	42a1      	cmp	r1, r4
		/* the newly freed struct is now the lowest */
		lfree = mem;
    4f40:	bf3c      	itt	cc
    4f42:	4c17      	ldrcc	r4, [pc, #92]	; (4fa0 <mem_free+0x88>)
    4f44:	60a1      	strcc	r1, [r4, #8]
	nmem = (struct mem *)(void *)&ram[mem->next];
    4f46:	f833 5c08 	ldrh.w	r5, [r3, #-8]
    4f4a:	1954      	adds	r4, r2, r5
	if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    4f4c:	42a1      	cmp	r1, r4
    4f4e:	d010      	beq.n	4f72 <mem_free+0x5a>
    4f50:	7926      	ldrb	r6, [r4, #4]
    4f52:	b976      	cbnz	r6, 4f72 <mem_free+0x5a>
    4f54:	42a0      	cmp	r0, r4
    4f56:	d00c      	beq.n	4f72 <mem_free+0x5a>
		if (lfree == nmem) {
    4f58:	4811      	ldr	r0, [pc, #68]	; (4fa0 <mem_free+0x88>)
    4f5a:	6880      	ldr	r0, [r0, #8]
    4f5c:	4284      	cmp	r4, r0
			lfree = mem;
    4f5e:	bf04      	itt	eq
    4f60:	480f      	ldreq	r0, [pc, #60]	; (4fa0 <mem_free+0x88>)
    4f62:	6081      	streq	r1, [r0, #8]
		mem->next                                      = nmem->next;
    4f64:	5b50      	ldrh	r0, [r2, r5]
    4f66:	f823 0c08 	strh.w	r0, [r3, #-8]
		((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    4f6a:	5b50      	ldrh	r0, [r2, r5]
    4f6c:	4410      	add	r0, r2
    4f6e:	1a8c      	subs	r4, r1, r2
    4f70:	8044      	strh	r4, [r0, #2]
	pmem = (struct mem *)(void *)&ram[mem->prev];
    4f72:	f833 0c06 	ldrh.w	r0, [r3, #-6]
    4f76:	1814      	adds	r4, r2, r0
	if (pmem != mem && pmem->used == 0) {
    4f78:	42a1      	cmp	r1, r4
    4f7a:	d00e      	beq.n	4f9a <mem_free+0x82>
    4f7c:	7925      	ldrb	r5, [r4, #4]
    4f7e:	b965      	cbnz	r5, 4f9a <mem_free+0x82>
		if (lfree == mem) {
    4f80:	4d07      	ldr	r5, [pc, #28]	; (4fa0 <mem_free+0x88>)
    4f82:	68ad      	ldr	r5, [r5, #8]
    4f84:	42a9      	cmp	r1, r5
			lfree = pmem;
    4f86:	bf04      	itt	eq
    4f88:	4905      	ldreq	r1, [pc, #20]	; (4fa0 <mem_free+0x88>)
    4f8a:	608c      	streq	r4, [r1, #8]
		pmem->next                                    = mem->next;
    4f8c:	f833 1c08 	ldrh.w	r1, [r3, #-8]
    4f90:	5211      	strh	r1, [r2, r0]
		((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    4f92:	f833 3c08 	ldrh.w	r3, [r3, #-8]
    4f96:	441a      	add	r2, r3
    4f98:	8050      	strh	r0, [r2, #2]
	plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_FREE_UNPROTECT();
}
    4f9a:	bc70      	pop	{r4, r5, r6}
    4f9c:	4770      	bx	lr
    4f9e:	bf00      	nop
    4fa0:	20001638 	.word	0x20001638

00004fa4 <mem_trim>:
	/* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
	LWIP_MEM_FREE_DECL_PROTECT();

	/* Expand the size of the allocated memory region so that we can
	   adjust for alignment. */
	newsize = LWIP_MEM_ALIGN_SIZE(newsize);
    4fa4:	3103      	adds	r1, #3
    4fa6:	f64f 73fc 	movw	r3, #65532	; 0xfffc
    4faa:	400b      	ands	r3, r1
    4fac:	2b0c      	cmp	r3, #12
    4fae:	bf38      	it	cc
    4fb0:	230c      	movcc	r3, #12
	if (newsize < MIN_SIZE_ALIGNED) {
		/* every data block must be at least MIN_SIZE_ALIGNED long */
		newsize = MIN_SIZE_ALIGNED;
	}

	if (newsize > MEM_SIZE_ALIGNED) {
    4fb2:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
    4fb6:	d852      	bhi.n	505e <mem_trim+0xba>
		return NULL;
	}

	LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram && (u8_t *)rmem < (u8_t *)ram_end);

	if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    4fb8:	4a2b      	ldr	r2, [pc, #172]	; (5068 <mem_trim+0xc4>)
    4fba:	6812      	ldr	r2, [r2, #0]
    4fbc:	4282      	cmp	r2, r0
    4fbe:	d82b      	bhi.n	5018 <mem_trim+0x74>
    4fc0:	4929      	ldr	r1, [pc, #164]	; (5068 <mem_trim+0xc4>)
    4fc2:	6849      	ldr	r1, [r1, #4]
    4fc4:	4288      	cmp	r0, r1
    4fc6:	d227      	bcs.n	5018 <mem_trim+0x74>
{
    4fc8:	b4f0      	push	{r4, r5, r6, r7}
		MEM_STATS_INC(illegal);
		SYS_ARCH_UNPROTECT(lev);
		return rmem;
	}
	/* Get the corresponding struct mem ... */
	mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    4fca:	f1a0 0408 	sub.w	r4, r0, #8
	/* ... and its offset pointer */
	ptr = (mem_size_t)((u8_t *)mem - ram);
    4fce:	1aa4      	subs	r4, r4, r2
    4fd0:	b2a4      	uxth	r4, r4

	size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    4fd2:	f830 5c08 	ldrh.w	r5, [r0, #-8]
    4fd6:	f1a5 0108 	sub.w	r1, r5, #8
    4fda:	1b09      	subs	r1, r1, r4
    4fdc:	b289      	uxth	r1, r1
	LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
	if (newsize > size) {
    4fde:	4299      	cmp	r1, r3
    4fe0:	d33f      	bcc.n	5062 <mem_trim+0xbe>
		/* not supported */
		return NULL;
	}
	if (newsize == size) {
    4fe2:	d018      	beq.n	5016 <mem_trim+0x72>
	}

	/* protect the heap from concurrent access */
	LWIP_MEM_FREE_PROTECT();

	mem2 = (struct mem *)(void *)&ram[mem->next];
    4fe4:	1956      	adds	r6, r2, r5
	if (mem2->used == 0) {
    4fe6:	7937      	ldrb	r7, [r6, #4]
    4fe8:	b9df      	cbnz	r7, 5022 <mem_trim+0x7e>
		/* The next struct is unused, we can simply move it at little */
		mem_size_t next;
		/* remember the old next pointer */
		next = mem2->next;
    4fea:	5b55      	ldrh	r5, [r2, r5]
		/* create new struct mem which is moved directly after the shrinked mem */
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    4fec:	f104 0108 	add.w	r1, r4, #8
    4ff0:	440b      	add	r3, r1
    4ff2:	b29b      	uxth	r3, r3
		if (lfree == mem2) {
    4ff4:	491c      	ldr	r1, [pc, #112]	; (5068 <mem_trim+0xc4>)
    4ff6:	6889      	ldr	r1, [r1, #8]
    4ff8:	428e      	cmp	r6, r1
    4ffa:	d00e      	beq.n	501a <mem_trim+0x76>
			lfree = (struct mem *)(void *)&ram[ptr2];
		}
		mem2       = (struct mem *)(void *)&ram[ptr2];
    4ffc:	18d1      	adds	r1, r2, r3
		mem2->used = 0;
    4ffe:	2600      	movs	r6, #0
    5000:	710e      	strb	r6, [r1, #4]
		/* restore the next pointer */
		mem2->next = next;
    5002:	52d5      	strh	r5, [r2, r3]
		/* link it back to mem */
		mem2->prev = ptr;
    5004:	804c      	strh	r4, [r1, #2]
		/* link mem to it */
		mem->next = ptr2;
    5006:	f820 3c08 	strh.w	r3, [r0, #-8]
		/* last thing to restore linked list: as we have moved mem2,
		 * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
		 * the end of the heap */
		if (mem2->next != MEM_SIZE_ALIGNED) {
    500a:	5ad1      	ldrh	r1, [r2, r3]
    500c:	f5b1 6f7a 	cmp.w	r1, #4000	; 0xfa0
    5010:	d001      	beq.n	5016 <mem_trim+0x72>
			((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    5012:	440a      	add	r2, r1
    5014:	8053      	strh	r3, [r2, #2]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_FREE_UNPROTECT();
	return rmem;
}
    5016:	bcf0      	pop	{r4, r5, r6, r7}
    5018:	4770      	bx	lr
			lfree = (struct mem *)(void *)&ram[ptr2];
    501a:	18d1      	adds	r1, r2, r3
    501c:	4e12      	ldr	r6, [pc, #72]	; (5068 <mem_trim+0xc4>)
    501e:	60b1      	str	r1, [r6, #8]
    5020:	e7ec      	b.n	4ffc <mem_trim+0x58>
	} else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
    5022:	f103 0514 	add.w	r5, r3, #20
    5026:	428d      	cmp	r5, r1
    5028:	d8f5      	bhi.n	5016 <mem_trim+0x72>
		ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    502a:	f104 0108 	add.w	r1, r4, #8
    502e:	440b      	add	r3, r1
    5030:	b29b      	uxth	r3, r3
		mem2 = (struct mem *)(void *)&ram[ptr2];
    5032:	18d1      	adds	r1, r2, r3
		if (mem2 < lfree) {
    5034:	4d0c      	ldr	r5, [pc, #48]	; (5068 <mem_trim+0xc4>)
    5036:	68ad      	ldr	r5, [r5, #8]
    5038:	42a9      	cmp	r1, r5
			lfree = mem2;
    503a:	bf3c      	itt	cc
    503c:	4d0a      	ldrcc	r5, [pc, #40]	; (5068 <mem_trim+0xc4>)
    503e:	60a9      	strcc	r1, [r5, #8]
		mem2->used = 0;
    5040:	2500      	movs	r5, #0
    5042:	710d      	strb	r5, [r1, #4]
		mem2->next = mem->next;
    5044:	f830 5c08 	ldrh.w	r5, [r0, #-8]
    5048:	52d5      	strh	r5, [r2, r3]
		mem2->prev = ptr;
    504a:	804c      	strh	r4, [r1, #2]
		mem->next  = ptr2;
    504c:	f820 3c08 	strh.w	r3, [r0, #-8]
		if (mem2->next != MEM_SIZE_ALIGNED) {
    5050:	5ad1      	ldrh	r1, [r2, r3]
    5052:	f5b1 6f7a 	cmp.w	r1, #4000	; 0xfa0
    5056:	d0de      	beq.n	5016 <mem_trim+0x72>
			((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    5058:	440a      	add	r2, r1
    505a:	8053      	strh	r3, [r2, #2]
    505c:	e7db      	b.n	5016 <mem_trim+0x72>
		return NULL;
    505e:	2000      	movs	r0, #0
    5060:	4770      	bx	lr
		return NULL;
    5062:	2000      	movs	r0, #0
    5064:	e7d7      	b.n	5016 <mem_trim+0x72>
    5066:	bf00      	nop
    5068:	20001638 	.word	0x20001638

0000506c <mem_malloc>:
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
	u8_t        local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_MEM_ALLOC_DECL_PROTECT();

	if (size == 0) {
    506c:	2800      	cmp	r0, #0
    506e:	d05f      	beq.n	5130 <mem_malloc+0xc4>
{
    5070:	b5f0      	push	{r4, r5, r6, r7, lr}
    5072:	4603      	mov	r3, r0
		return NULL;
	}

	/* Expand the size of the allocated memory region so that we can
	   adjust for alignment. */
	size = LWIP_MEM_ALIGN_SIZE(size);
    5074:	3303      	adds	r3, #3
    5076:	f64f 74fc 	movw	r4, #65532	; 0xfffc
    507a:	401c      	ands	r4, r3
    507c:	2c0c      	cmp	r4, #12
    507e:	bf38      	it	cc
    5080:	240c      	movcc	r4, #12
	if (size < MIN_SIZE_ALIGNED) {
		/* every data block must be at least MIN_SIZE_ALIGNED long */
		size = MIN_SIZE_ALIGNED;
	}

	if (size > MEM_SIZE_ALIGNED) {
    5082:	f5b4 6f7a 	cmp.w	r4, #4000	; 0xfa0
    5086:	d855      	bhi.n	5134 <mem_malloc+0xc8>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

		/* Scan through the heap searching for a free block that is big enough,
		 * beginning with the lowest free block.
		 */
		for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    5088:	4b2c      	ldr	r3, [pc, #176]	; (513c <mem_malloc+0xd0>)
    508a:	689f      	ldr	r7, [r3, #8]
    508c:	6819      	ldr	r1, [r3, #0]
    508e:	1a7b      	subs	r3, r7, r1
    5090:	b29b      	uxth	r3, r3
    5092:	f5c4 657a 	rsb	r5, r4, #4000	; 0xfa0
    5096:	42ab      	cmp	r3, r5
    5098:	da4e      	bge.n	5138 <mem_malloc+0xcc>
				local_mem_free_count = 1;
				break;
			}
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

			if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    509a:	f06f 0c07 	mvn.w	ip, #7
    509e:	46a6      	mov	lr, r4
    50a0:	e00e      	b.n	50c0 <mem_malloc+0x54>
					 * take care of this).
					 * -> near fit or excact fit: do not split, no mem2 creation
					 * also can't move mem->next directly behind mem, since mem->next
					 * will always be used at this point!
					 */
					mem->used = 1;
    50a2:	2301      	movs	r3, #1
    50a4:	7103      	strb	r3, [r0, #4]
					MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
				}
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
			mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
				if (mem == lfree) {
    50a6:	4b25      	ldr	r3, [pc, #148]	; (513c <mem_malloc+0xd0>)
    50a8:	689b      	ldr	r3, [r3, #8]
    50aa:	4298      	cmp	r0, r3
    50ac:	d02f      	beq.n	510e <mem_malloc+0xa2>
				            (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
				LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
				            ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
				LWIP_ASSERT("mem_malloc: sanity check alignment", (((mem_ptr_t)mem) & (MEM_ALIGNMENT - 1)) == 0);

				return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    50ae:	3008      	adds	r0, #8
    50b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
			mem            = (struct mem *)(void *)&ram[ptr];
    50b2:	4603      	mov	r3, r0
    50b4:	e037      	b.n	5126 <mem_malloc+0xba>
    50b6:	4603      	mov	r3, r0
    50b8:	e035      	b.n	5126 <mem_malloc+0xba>
		     ptr = ((struct mem *)(void *)&ram[ptr])->next) {
    50ba:	8803      	ldrh	r3, [r0, #0]
		for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    50bc:	42ab      	cmp	r3, r5
    50be:	da35      	bge.n	512c <mem_malloc+0xc0>
			mem            = (struct mem *)(void *)&ram[ptr];
    50c0:	18c8      	adds	r0, r1, r3
			if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    50c2:	7902      	ldrb	r2, [r0, #4]
    50c4:	2a00      	cmp	r2, #0
    50c6:	d1f8      	bne.n	50ba <mem_malloc+0x4e>
    50c8:	ebac 0203 	sub.w	r2, ip, r3
    50cc:	5ace      	ldrh	r6, [r1, r3]
    50ce:	4432      	add	r2, r6
    50d0:	4676      	mov	r6, lr
    50d2:	42a2      	cmp	r2, r4
    50d4:	d3f1      	bcc.n	50ba <mem_malloc+0x4e>
				if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
    50d6:	3614      	adds	r6, #20
    50d8:	42b2      	cmp	r2, r6
    50da:	d3e2      	bcc.n	50a2 <mem_malloc+0x36>
					ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    50dc:	f104 0208 	add.w	r2, r4, #8
    50e0:	441a      	add	r2, r3
    50e2:	b292      	uxth	r2, r2
					mem2       = (struct mem *)(void *)&ram[ptr2];
    50e4:	188c      	adds	r4, r1, r2
					mem2->used = 0;
    50e6:	2500      	movs	r5, #0
    50e8:	7125      	strb	r5, [r4, #4]
					mem2->next = mem->next;
    50ea:	8805      	ldrh	r5, [r0, #0]
    50ec:	528d      	strh	r5, [r1, r2]
					mem2->prev = ptr;
    50ee:	8063      	strh	r3, [r4, #2]
					mem->next = ptr2;
    50f0:	8002      	strh	r2, [r0, #0]
					mem->used = 1;
    50f2:	2301      	movs	r3, #1
    50f4:	7103      	strb	r3, [r0, #4]
					if (mem2->next != MEM_SIZE_ALIGNED) {
    50f6:	5a8b      	ldrh	r3, [r1, r2]
    50f8:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
    50fc:	d0d3      	beq.n	50a6 <mem_malloc+0x3a>
						((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    50fe:	4419      	add	r1, r3
    5100:	804a      	strh	r2, [r1, #2]
				if (mem == lfree) {
    5102:	4287      	cmp	r7, r0
    5104:	d1d3      	bne.n	50ae <mem_malloc+0x42>
					while (cur->used && cur != ram_end) {
    5106:	7903      	ldrb	r3, [r0, #4]
    5108:	2b00      	cmp	r3, #0
    510a:	d0d2      	beq.n	50b2 <mem_malloc+0x46>
				if (mem == lfree) {
    510c:	4603      	mov	r3, r0
					while (cur->used && cur != ram_end) {
    510e:	4a0b      	ldr	r2, [pc, #44]	; (513c <mem_malloc+0xd0>)
    5110:	6851      	ldr	r1, [r2, #4]
    5112:	4288      	cmp	r0, r1
    5114:	d0cf      	beq.n	50b6 <mem_malloc+0x4a>
						cur = (struct mem *)(void *)&ram[cur->next];
    5116:	6814      	ldr	r4, [r2, #0]
    5118:	881b      	ldrh	r3, [r3, #0]
    511a:	4423      	add	r3, r4
					while (cur->used && cur != ram_end) {
    511c:	791a      	ldrb	r2, [r3, #4]
    511e:	b112      	cbz	r2, 5126 <mem_malloc+0xba>
    5120:	428b      	cmp	r3, r1
    5122:	d1f9      	bne.n	5118 <mem_malloc+0xac>
						cur = (struct mem *)(void *)&ram[cur->next];
    5124:	460b      	mov	r3, r1
					lfree = cur;
    5126:	4a05      	ldr	r2, [pc, #20]	; (513c <mem_malloc+0xd0>)
    5128:	6093      	str	r3, [r2, #8]
    512a:	e7c0      	b.n	50ae <mem_malloc+0x42>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
	LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %" S16_F " bytes\n", (s16_t)size));
	MEM_STATS_INC(err);
	LWIP_MEM_ALLOC_UNPROTECT();
	sys_mutex_unlock(&mem_mutex);
	return NULL;
    512c:	2000      	movs	r0, #0
    512e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return NULL;
    5130:	2000      	movs	r0, #0
    5132:	4770      	bx	lr
		return NULL;
    5134:	2000      	movs	r0, #0
    5136:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return NULL;
    5138:	2000      	movs	r0, #0
    513a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    513c:	20001638 	.word	0x20001638

00005140 <memp_init>:
 * Initialize this module.
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void memp_init(void)
{
    5140:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		MEMP_STATS_AVAIL(err, i, 0);
		MEMP_STATS_AVAIL(avail, i, memp_num[i]);
	}

#if !MEMP_SEPARATE_POOLS
	memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    5144:	4f19      	ldr	r7, [pc, #100]	; (51ac <memp_init+0x6c>)
    5146:	f027 0703 	bic.w	r7, r7, #3
    514a:	4b19      	ldr	r3, [pc, #100]	; (51b0 <memp_init+0x70>)
    514c:	f503 7655 	add.w	r6, r3, #852	; 0x354
    5150:	f8df c060 	ldr.w	ip, [pc, #96]	; 51b4 <memp_init+0x74>
    5154:	f10c 0e14 	add.w	lr, ip, #20
    5158:	f503 795f 	add.w	r9, r3, #892	; 0x37c
#endif /* !MEMP_SEPARATE_POOLS */
	/* for every pool: */
	for (i = 0; i < MEMP_MAX; ++i) {
		memp_tab[i] = NULL;
    515c:	f04f 0a00 	mov.w	sl, #0
    5160:	e015      	b.n	518e <memp_init+0x4e>
#endif /* MEMP_SEPARATE_POOLS */
		/* create a linked list of memp elements */
		for (j = 0; j < memp_num[i]; ++j) {
			memp->next  = memp_tab[i];
			memp_tab[i] = memp;
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    5162:	4603      	mov	r3, r0
			memp->next  = memp_tab[i];
    5164:	6019      	str	r1, [r3, #0]
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    5166:	1958      	adds	r0, r3, r5
    5168:	3201      	adds	r2, #1
			memp_tab[i] = memp;
    516a:	4619      	mov	r1, r3
		for (j = 0; j < memp_num[i]; ++j) {
    516c:	b293      	uxth	r3, r2
    516e:	429c      	cmp	r4, r3
    5170:	d8f7      	bhi.n	5162 <memp_init+0x22>
    5172:	3c01      	subs	r4, #1
    5174:	b2a4      	uxth	r4, r4
    5176:	fb04 5305 	mla	r3, r4, r5, r5
    517a:	fb04 7405 	mla	r4, r4, r5, r7
    517e:	f8c8 4000 	str.w	r4, [r8]
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    5182:	441f      	add	r7, r3
    5184:	3604      	adds	r6, #4
    5186:	f10e 0e02 	add.w	lr, lr, #2
	for (i = 0; i < MEMP_MAX; ++i) {
    518a:	45b1      	cmp	r9, r6
    518c:	d00c      	beq.n	51a8 <memp_init+0x68>
    518e:	46b0      	mov	r8, r6
		memp_tab[i] = NULL;
    5190:	f8c6 a000 	str.w	sl, [r6]
		for (j = 0; j < memp_num[i]; ++j) {
    5194:	f83c 4b02 	ldrh.w	r4, [ip], #2
    5198:	2c00      	cmp	r4, #0
    519a:	d0f3      	beq.n	5184 <memp_init+0x44>
			memp        = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    519c:	f8be 5000 	ldrh.w	r5, [lr]
    51a0:	463b      	mov	r3, r7
    51a2:	2200      	movs	r2, #0
    51a4:	4611      	mov	r1, r2
    51a6:	e7dd      	b.n	5164 <memp_init+0x24>
#if MEMP_OVERFLOW_CHECK
	memp_overflow_init();
	/* check everything a first time to see if it worked */
	memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
    51a8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    51ac:	20001647 	.word	0x20001647
    51b0:	20007c14 	.word	0x20007c14
    51b4:	0000bac4 	.word	0x0000bac4

000051b8 <memp_malloc>:
#endif
{
	struct memp *memp;
	SYS_ARCH_DECL_PROTECT(old_level);

	LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    51b8:	2809      	cmp	r0, #9
    51ba:	d80d      	bhi.n	51d8 <memp_malloc+0x20>
	SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
	memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

	memp = memp_tab[type];
    51bc:	4b0b      	ldr	r3, [pc, #44]	; (51ec <memp_malloc+0x34>)
    51be:	eb03 0380 	add.w	r3, r3, r0, lsl #2
    51c2:	f8d3 3354 	ldr.w	r3, [r3, #852]	; 0x354

	if (memp != NULL) {
    51c6:	b12b      	cbz	r3, 51d4 <memp_malloc+0x1c>
		memp_tab[type] = memp->next;
    51c8:	6819      	ldr	r1, [r3, #0]
    51ca:	4a08      	ldr	r2, [pc, #32]	; (51ec <memp_malloc+0x34>)
    51cc:	eb02 0280 	add.w	r2, r2, r0, lsl #2
    51d0:	f8c2 1354 	str.w	r1, [r2, #852]	; 0x354
	}

	SYS_ARCH_UNPROTECT(old_level);

	return memp;
}
    51d4:	4618      	mov	r0, r3
    51d6:	4770      	bx	lr
{
    51d8:	b510      	push	{r4, lr}
	LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    51da:	4b05      	ldr	r3, [pc, #20]	; (51f0 <memp_malloc+0x38>)
    51dc:	f240 1289 	movw	r2, #393	; 0x189
    51e0:	4904      	ldr	r1, [pc, #16]	; (51f4 <memp_malloc+0x3c>)
    51e2:	4805      	ldr	r0, [pc, #20]	; (51f8 <memp_malloc+0x40>)
    51e4:	4c05      	ldr	r4, [pc, #20]	; (51fc <memp_malloc+0x44>)
    51e6:	47a0      	blx	r4
    51e8:	e7fe      	b.n	51e8 <memp_malloc+0x30>
    51ea:	bf00      	nop
    51ec:	20007c14 	.word	0x20007c14
    51f0:	0000baec 	.word	0x0000baec
    51f4:	0000bb10 	.word	0x0000bb10
    51f8:	0000ab0c 	.word	0x0000ab0c
    51fc:	00009815 	.word	0x00009815

00005200 <memp_free>:
void memp_free(memp_t type, void *mem)
{
	struct memp *memp;
	SYS_ARCH_DECL_PROTECT(old_level);

	if (mem == NULL) {
    5200:	b139      	cbz	r1, 5212 <memp_free+0x12>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

	MEMP_STATS_DEC(used, type);

	memp->next     = memp_tab[type];
    5202:	4b04      	ldr	r3, [pc, #16]	; (5214 <memp_free+0x14>)
    5204:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    5208:	f8d0 3354 	ldr.w	r3, [r0, #852]	; 0x354
    520c:	600b      	str	r3, [r1, #0]
	memp_tab[type] = memp;
    520e:	f8c0 1354 	str.w	r1, [r0, #852]	; 0x354
    5212:	4770      	bx	lr
    5214:	20007c14 	.word	0x20007c14

00005218 <netif_init>:
	return ERR_OK;
}
#endif /* LWIP_HAVE_LOOPIF */

void netif_init(void)
{
    5218:	4770      	bx	lr
	...

0000521c <netif_set_ipaddr>:
 *
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
    521c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    521e:	4604      	mov	r4, r0
#if LWIP_TCP
	struct tcp_pcb *       pcb;
	struct tcp_pcb_listen *lpcb;

	/* address is actually being changed? */
	if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    5220:	2900      	cmp	r1, #0
    5222:	d027      	beq.n	5274 <netif_set_ipaddr+0x58>
    5224:	460d      	mov	r5, r1
    5226:	680a      	ldr	r2, [r1, #0]
    5228:	6843      	ldr	r3, [r0, #4]
    522a:	429a      	cmp	r2, r3
    522c:	d011      	beq.n	5252 <netif_set_ipaddr+0x36>
		/* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
		pcb = tcp_active_pcbs;
    522e:	4b12      	ldr	r3, [pc, #72]	; (5278 <netif_set_ipaddr+0x5c>)
    5230:	6818      	ldr	r0, [r3, #0]
		while (pcb != NULL) {
    5232:	b158      	cbz	r0, 524c <netif_set_ipaddr+0x30>
#endif /* LWIP_AUTOIP */
			) {
				/* this connection must be aborted */
				struct tcp_pcb *next = pcb->next;
				LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
				tcp_abort(pcb);
    5234:	4f11      	ldr	r7, [pc, #68]	; (527c <netif_set_ipaddr+0x60>)
    5236:	e003      	b.n	5240 <netif_set_ipaddr+0x24>
				struct tcp_pcb *next = pcb->next;
    5238:	68c6      	ldr	r6, [r0, #12]
				tcp_abort(pcb);
    523a:	47b8      	blx	r7
				pcb = next;
    523c:	4630      	mov	r0, r6
		while (pcb != NULL) {
    523e:	b128      	cbz	r0, 524c <netif_set_ipaddr+0x30>
			if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    5240:	6802      	ldr	r2, [r0, #0]
    5242:	6863      	ldr	r3, [r4, #4]
    5244:	429a      	cmp	r2, r3
    5246:	d0f7      	beq.n	5238 <netif_set_ipaddr+0x1c>
			} else {
				pcb = pcb->next;
    5248:	68c0      	ldr	r0, [r0, #12]
    524a:	e7f8      	b.n	523e <netif_set_ipaddr+0x22>
			}
		}
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    524c:	4b0c      	ldr	r3, [pc, #48]	; (5280 <netif_set_ipaddr+0x64>)
    524e:	681b      	ldr	r3, [r3, #0]
    5250:	b92b      	cbnz	r3, 525e <netif_set_ipaddr+0x42>
	}
#endif
	snmp_delete_ipaddridx_tree(netif);
	snmp_delete_iprteidx_tree(0, netif);
	/* set new IP address to netif */
	ip_addr_set(&(netif->ip_addr), ipaddr);
    5252:	682b      	ldr	r3, [r5, #0]
    5254:	6063      	str	r3, [r4, #4]
	             netif->name[1],
	             ip4_addr1_16(&netif->ip_addr),
	             ip4_addr2_16(&netif->ip_addr),
	             ip4_addr3_16(&netif->ip_addr),
	             ip4_addr4_16(&netif->ip_addr)));
}
    5256:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    5258:	68db      	ldr	r3, [r3, #12]
    525a:	2b00      	cmp	r3, #0
    525c:	d0f9      	beq.n	5252 <netif_set_ipaddr+0x36>
			if ((!(ip_addr_isany(&(lpcb->local_ip)))) && (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
    525e:	2b00      	cmp	r3, #0
    5260:	d0fa      	beq.n	5258 <netif_set_ipaddr+0x3c>
    5262:	681a      	ldr	r2, [r3, #0]
    5264:	2a00      	cmp	r2, #0
    5266:	d0f7      	beq.n	5258 <netif_set_ipaddr+0x3c>
    5268:	6861      	ldr	r1, [r4, #4]
    526a:	428a      	cmp	r2, r1
				ip_addr_set(&(lpcb->local_ip), ipaddr);
    526c:	bf04      	itt	eq
    526e:	682a      	ldreq	r2, [r5, #0]
    5270:	601a      	streq	r2, [r3, #0]
    5272:	e7f1      	b.n	5258 <netif_set_ipaddr+0x3c>
	ip_addr_set(&(netif->ip_addr), ipaddr);
    5274:	2300      	movs	r3, #0
    5276:	e7ed      	b.n	5254 <netif_set_ipaddr+0x38>
    5278:	200092e0 	.word	0x200092e0
    527c:	0000625d 	.word	0x0000625d
    5280:	200092e8 	.word	0x200092e8

00005284 <netif_set_addr>:
{
    5284:	b570      	push	{r4, r5, r6, lr}
    5286:	4604      	mov	r4, r0
    5288:	4616      	mov	r6, r2
    528a:	461d      	mov	r5, r3
	netif_set_ipaddr(netif, ipaddr);
    528c:	4b06      	ldr	r3, [pc, #24]	; (52a8 <netif_set_addr+0x24>)
    528e:	4798      	blx	r3
 */
void netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
	snmp_delete_iprteidx_tree(0, netif);
	/* set new netmask to netif */
	ip_addr_set(&(netif->netmask), netmask);
    5290:	b12e      	cbz	r6, 529e <netif_set_addr+0x1a>
    5292:	6833      	ldr	r3, [r6, #0]
    5294:	60a3      	str	r3, [r4, #8]
	ip_addr_set(&(netif->gw), gw);
    5296:	b125      	cbz	r5, 52a2 <netif_set_addr+0x1e>
    5298:	682b      	ldr	r3, [r5, #0]
    529a:	60e3      	str	r3, [r4, #12]
    529c:	bd70      	pop	{r4, r5, r6, pc}
	ip_addr_set(&(netif->netmask), netmask);
    529e:	2300      	movs	r3, #0
    52a0:	e7f8      	b.n	5294 <netif_set_addr+0x10>
	ip_addr_set(&(netif->gw), gw);
    52a2:	2300      	movs	r3, #0
    52a4:	e7f9      	b.n	529a <netif_set_addr+0x16>
    52a6:	bf00      	nop
    52a8:	0000521d 	.word	0x0000521d

000052ac <netif_add>:
{
    52ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    52ae:	4604      	mov	r4, r0
	ip_addr_set_zero(&netif->ip_addr);
    52b0:	2500      	movs	r5, #0
    52b2:	6045      	str	r5, [r0, #4]
	ip_addr_set_zero(&netif->netmask);
    52b4:	6085      	str	r5, [r0, #8]
	ip_addr_set_zero(&netif->gw);
    52b6:	60c5      	str	r5, [r0, #12]
	netif->flags = 0;
    52b8:	f880 5035 	strb.w	r5, [r0, #53]	; 0x35
	netif->dhcp = NULL;
    52bc:	6285      	str	r5, [r0, #40]	; 0x28
	netif->status_callback = NULL;
    52be:	61c5      	str	r5, [r0, #28]
	netif->link_callback = NULL;
    52c0:	6205      	str	r5, [r0, #32]
	netif->state = state;
    52c2:	9d06      	ldr	r5, [sp, #24]
    52c4:	6245      	str	r5, [r0, #36]	; 0x24
	netif->num   = netif_num++;
    52c6:	4e0b      	ldr	r6, [pc, #44]	; (52f4 <netif_add+0x48>)
    52c8:	7835      	ldrb	r5, [r6, #0]
    52ca:	1c6f      	adds	r7, r5, #1
    52cc:	7037      	strb	r7, [r6, #0]
    52ce:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
	netif->input = input;
    52d2:	9d08      	ldr	r5, [sp, #32]
    52d4:	6105      	str	r5, [r0, #16]
	netif_set_addr(netif, ipaddr, netmask, gw);
    52d6:	4d08      	ldr	r5, [pc, #32]	; (52f8 <netif_add+0x4c>)
    52d8:	47a8      	blx	r5
	if (init(netif) != ERR_OK) {
    52da:	4620      	mov	r0, r4
    52dc:	9b07      	ldr	r3, [sp, #28]
    52de:	4798      	blx	r3
    52e0:	b928      	cbnz	r0, 52ee <netif_add+0x42>
	netif->next = netif_list;
    52e2:	4b06      	ldr	r3, [pc, #24]	; (52fc <netif_add+0x50>)
    52e4:	681a      	ldr	r2, [r3, #0]
    52e6:	6022      	str	r2, [r4, #0]
	netif_list  = netif;
    52e8:	601c      	str	r4, [r3, #0]
	return netif;
    52ea:	4620      	mov	r0, r4
    52ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return NULL;
    52ee:	2000      	movs	r0, #0
}
    52f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    52f2:	bf00      	nop
    52f4:	20007f90 	.word	0x20007f90
    52f8:	00005285 	.word	0x00005285
    52fc:	200092d0 	.word	0x200092d0

00005300 <netif_set_gw>:
	ip_addr_set(&(netif->gw), gw);
    5300:	b111      	cbz	r1, 5308 <netif_set_gw+0x8>
    5302:	680b      	ldr	r3, [r1, #0]
    5304:	60c3      	str	r3, [r0, #12]
    5306:	4770      	bx	lr
    5308:	2300      	movs	r3, #0
    530a:	e7fb      	b.n	5304 <netif_set_gw+0x4>

0000530c <netif_set_netmask>:
	ip_addr_set(&(netif->netmask), netmask);
    530c:	b111      	cbz	r1, 5314 <netif_set_netmask+0x8>
    530e:	680b      	ldr	r3, [r1, #0]
    5310:	6083      	str	r3, [r0, #8]
    5312:	4770      	bx	lr
    5314:	2300      	movs	r3, #0
    5316:	e7fb      	b.n	5310 <netif_set_netmask+0x4>

00005318 <netif_set_default>:
		snmp_delete_iprteidx_tree(1, netif);
	} else {
		/* install default route */
		snmp_insert_iprteidx_tree(1, netif);
	}
	netif_default = netif;
    5318:	4b01      	ldr	r3, [pc, #4]	; (5320 <netif_set_default+0x8>)
    531a:	6018      	str	r0, [r3, #0]
    531c:	4770      	bx	lr
    531e:	bf00      	nop
    5320:	200092d4 	.word	0x200092d4

00005324 <netif_set_up>:
 *
 * @see dhcp_start()
 */
void netif_set_up(struct netif *netif)
{
	if (!(netif->flags & NETIF_FLAG_UP)) {
    5324:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
    5328:	f013 0f01 	tst.w	r3, #1
    532c:	d114      	bne.n	5358 <netif_set_up+0x34>
{
    532e:	b510      	push	{r4, lr}
    5330:	4604      	mov	r4, r0
		netif->flags |= NETIF_FLAG_UP;
    5332:	f043 0301 	orr.w	r3, r3, #1
    5336:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35

#if LWIP_SNMP
		snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

		NETIF_STATUS_CALLBACK(netif);
    533a:	69c3      	ldr	r3, [r0, #28]
    533c:	b103      	cbz	r3, 5340 <netif_set_up+0x1c>
    533e:	4798      	blx	r3

		if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
			/* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
			if (netif->flags & (NETIF_FLAG_ETHARP)) {
    5340:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    5344:	f003 0330 	and.w	r3, r3, #48	; 0x30
    5348:	2b30      	cmp	r3, #48	; 0x30
    534a:	d000      	beq.n	534e <netif_set_up+0x2a>
    534c:	bd10      	pop	{r4, pc}
				etharp_gratuitous(netif);
    534e:	1d21      	adds	r1, r4, #4
    5350:	4620      	mov	r0, r4
    5352:	4b02      	ldr	r3, [pc, #8]	; (535c <netif_set_up+0x38>)
    5354:	4798      	blx	r3
				igmp_report_groups(netif);
			}
#endif /* LWIP_IGMP */
		}
	}
}
    5356:	e7f9      	b.n	534c <netif_set_up+0x28>
    5358:	4770      	bx	lr
    535a:	bf00      	nop
    535c:	000088d9 	.word	0x000088d9

00005360 <netif_set_down>:
 *
 * @see dhcp_start()
 */
void netif_set_down(struct netif *netif)
{
	if (netif->flags & NETIF_FLAG_UP) {
    5360:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
    5364:	f013 0f01 	tst.w	r3, #1
    5368:	d010      	beq.n	538c <netif_set_down+0x2c>
{
    536a:	b510      	push	{r4, lr}
    536c:	4604      	mov	r4, r0
		netif->flags &= ~NETIF_FLAG_UP;
    536e:	f023 0201 	bic.w	r2, r3, #1
    5372:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
#if LWIP_SNMP
		snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
		if (netif->flags & NETIF_FLAG_ETHARP) {
    5376:	f013 0f20 	tst.w	r3, #32
    537a:	d104      	bne.n	5386 <netif_set_down+0x26>
			etharp_cleanup_netif(netif);
		}
#endif /* LWIP_ARP */
		NETIF_STATUS_CALLBACK(netif);
    537c:	69e3      	ldr	r3, [r4, #28]
    537e:	b10b      	cbz	r3, 5384 <netif_set_down+0x24>
    5380:	4620      	mov	r0, r4
    5382:	4798      	blx	r3
    5384:	bd10      	pop	{r4, pc}
			etharp_cleanup_netif(netif);
    5386:	4b02      	ldr	r3, [pc, #8]	; (5390 <netif_set_down+0x30>)
    5388:	4798      	blx	r3
    538a:	e7f7      	b.n	537c <netif_set_down+0x1c>
    538c:	4770      	bx	lr
    538e:	bf00      	nop
    5390:	000088a9 	.word	0x000088a9

00005394 <netif_set_status_callback>:
/**
 * Set callback to be called when interface is brought up/down
 */
void netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback)
{
	if (netif) {
    5394:	b100      	cbz	r0, 5398 <netif_set_status_callback+0x4>
		netif->status_callback = status_callback;
    5396:	61c1      	str	r1, [r0, #28]
    5398:	4770      	bx	lr

0000539a <netif_set_link_callback>:
/**
 * Set callback to be called when link is brought up/down
 */
void netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback)
{
	if (netif) {
    539a:	b100      	cbz	r0, 539e <netif_set_link_callback+0x4>
		netif->link_callback = link_callback;
    539c:	6201      	str	r1, [r0, #32]
    539e:	4770      	bx	lr

000053a0 <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
    void
    pbuf_free_ooseq(void)
{
    53a0:	b510      	push	{r4, lr}
	struct tcp_pcb *pcb;
	SYS_ARCH_DECL_PROTECT(old_level);

	SYS_ARCH_PROTECT(old_level);
	pbuf_free_ooseq_pending = 0;
    53a2:	2200      	movs	r2, #0
    53a4:	4b08      	ldr	r3, [pc, #32]	; (53c8 <pbuf_free_ooseq+0x28>)
    53a6:	701a      	strb	r2, [r3, #0]
	SYS_ARCH_UNPROTECT(old_level);

	for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    53a8:	4b08      	ldr	r3, [pc, #32]	; (53cc <pbuf_free_ooseq+0x2c>)
    53aa:	681c      	ldr	r4, [r3, #0]
    53ac:	b15c      	cbz	r4, 53c6 <pbuf_free_ooseq+0x26>
		if (NULL != pcb->ooseq) {
    53ae:	6f60      	ldr	r0, [r4, #116]	; 0x74
    53b0:	b920      	cbnz	r0, 53bc <pbuf_free_ooseq+0x1c>
	for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    53b2:	68e4      	ldr	r4, [r4, #12]
    53b4:	b13c      	cbz	r4, 53c6 <pbuf_free_ooseq+0x26>
		if (NULL != pcb->ooseq) {
    53b6:	6f60      	ldr	r0, [r4, #116]	; 0x74
    53b8:	2800      	cmp	r0, #0
    53ba:	d0fa      	beq.n	53b2 <pbuf_free_ooseq+0x12>
			/** Free the ooseq pbufs of one PCB only */
			LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
			tcp_segs_free(pcb->ooseq);
    53bc:	4b04      	ldr	r3, [pc, #16]	; (53d0 <pbuf_free_ooseq+0x30>)
    53be:	4798      	blx	r3
			pcb->ooseq = NULL;
    53c0:	2300      	movs	r3, #0
    53c2:	6763      	str	r3, [r4, #116]	; 0x74
			return;
    53c4:	bd10      	pop	{r4, pc}
    53c6:	bd10      	pop	{r4, pc}
    53c8:	200092d8 	.word	0x200092d8
    53cc:	200092e0 	.word	0x200092e0
    53d0:	00005a0d 	.word	0x00005a0d

000053d4 <pbuf_alloced_custom>:
 * @param payload_mem_len the size of the 'payload_mem' buffer, must be at least
 *        big enough to hold 'length' plus the header size
 */
struct pbuf *pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p, void *payload_mem,
                                 u16_t payload_mem_len)
{
    53d4:	b470      	push	{r4, r5, r6}
    53d6:	9c03      	ldr	r4, [sp, #12]
	u16_t offset;
	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%" U16_F ")\n", length));

	/* determine header offset */
	switch (l) {
    53d8:	2803      	cmp	r0, #3
    53da:	d826      	bhi.n	542a <pbuf_alloced_custom+0x56>
    53dc:	e8df f000 	tbb	[pc, r0]
    53e0:	06040208 	.word	0x06040208
		/* add room for transport (often TCP) layer header */
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
		break;
	case PBUF_IP:
		/* add room for IP layer header */
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    53e4:	2022      	movs	r0, #34	; 0x22
    53e6:	e004      	b.n	53f2 <pbuf_alloced_custom+0x1e>
		break;
	case PBUF_LINK:
		/* add room for link layer header */
		offset = PBUF_LINK_HLEN;
    53e8:	200e      	movs	r0, #14
		break;
    53ea:	e002      	b.n	53f2 <pbuf_alloced_custom+0x1e>
	case PBUF_RAW:
		offset = 0;
    53ec:	2000      	movs	r0, #0
		break;
    53ee:	e000      	b.n	53f2 <pbuf_alloced_custom+0x1e>
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    53f0:	2036      	movs	r0, #54	; 0x36
	default:
		LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
		return NULL;
	}

	if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
    53f2:	3003      	adds	r0, #3
    53f4:	f020 0503 	bic.w	r5, r0, #3
    53f8:	440d      	add	r5, r1
    53fa:	f8bd 6010 	ldrh.w	r6, [sp, #16]
    53fe:	42b5      	cmp	r5, r6
    5400:	dc15      	bgt.n	542e <pbuf_alloced_custom+0x5a>
		LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING,
		            ("pbuf_alloced_custom(length=%" U16_F ") buffer too short\n", length));
		return NULL;
	}

	p->pbuf.next = NULL;
    5402:	2500      	movs	r5, #0
    5404:	601d      	str	r5, [r3, #0]
	if (payload_mem != NULL) {
    5406:	b16c      	cbz	r4, 5424 <pbuf_alloced_custom+0x50>
		p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
    5408:	f020 0003 	bic.w	r0, r0, #3
    540c:	4420      	add	r0, r4
    540e:	6058      	str	r0, [r3, #4]
	} else {
		p->pbuf.payload = NULL;
	}
	p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
    5410:	2002      	movs	r0, #2
    5412:	7358      	strb	r0, [r3, #13]
	p->pbuf.len = p->pbuf.tot_len = length;
    5414:	8119      	strh	r1, [r3, #8]
    5416:	8159      	strh	r1, [r3, #10]
	p->pbuf.type                  = type;
    5418:	731a      	strb	r2, [r3, #12]
	p->pbuf.ref                   = 1;
    541a:	2201      	movs	r2, #1
    541c:	81da      	strh	r2, [r3, #14]
	return &p->pbuf;
    541e:	4618      	mov	r0, r3
}
    5420:	bc70      	pop	{r4, r5, r6}
    5422:	4770      	bx	lr
		p->pbuf.payload = NULL;
    5424:	2000      	movs	r0, #0
    5426:	6058      	str	r0, [r3, #4]
    5428:	e7f2      	b.n	5410 <pbuf_alloced_custom+0x3c>
		return NULL;
    542a:	2000      	movs	r0, #0
    542c:	e7f8      	b.n	5420 <pbuf_alloced_custom+0x4c>
		return NULL;
    542e:	2000      	movs	r0, #0
    5430:	e7f6      	b.n	5420 <pbuf_alloced_custom+0x4c>
	...

00005434 <pbuf_header>:
	u16_t type;
	void *payload;
	u16_t increment_magnitude;

	LWIP_ASSERT("p != NULL", p != NULL);
	if ((header_size_increment == 0) || (p == NULL)) {
    5434:	2900      	cmp	r1, #0
    5436:	d035      	beq.n	54a4 <pbuf_header+0x70>
    5438:	460b      	mov	r3, r1
    543a:	2800      	cmp	r0, #0
    543c:	d034      	beq.n	54a8 <pbuf_header+0x74>
{
    543e:	b510      	push	{r4, lr}
		return 0;
	}

	if (header_size_increment < 0) {
    5440:	2900      	cmp	r1, #0
    5442:	db0b      	blt.n	545c <pbuf_header+0x28>
		increment_magnitude = -header_size_increment;
		/* Check that we aren't going to move off the end of the pbuf */
		LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
	} else {
		increment_magnitude = header_size_increment;
    5444:	b28c      	uxth	r4, r1
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
	}

	type = p->type;
    5446:	7b01      	ldrb	r1, [r0, #12]
	/* remember current payload pointer */
	payload = p->payload;
    5448:	6842      	ldr	r2, [r0, #4]

	/* pbuf types containing payloads? */
	if (type == PBUF_RAM || type == PBUF_POOL) {
    544a:	b1a1      	cbz	r1, 5476 <pbuf_header+0x42>
    544c:	2903      	cmp	r1, #3
    544e:	d012      	beq.n	5476 <pbuf_header+0x42>
			p->payload = payload;
			/* bail out unsuccesfully */
			return 1;
		}
		/* pbuf types refering to external payloads? */
	} else if (type == PBUF_REF || type == PBUF_ROM) {
    5450:	3901      	subs	r1, #1
    5452:	b289      	uxth	r1, r1
    5454:	2901      	cmp	r1, #1
    5456:	d91d      	bls.n	5494 <pbuf_header+0x60>
			return 1;
		}
	} else {
		/* Unknown type */
		LWIP_ASSERT("bad pbuf type", 0);
		return 1;
    5458:	2001      	movs	r0, #1
    545a:	bd10      	pop	{r4, pc}
		increment_magnitude = -header_size_increment;
    545c:	424c      	negs	r4, r1
    545e:	b2a4      	uxth	r4, r4
		LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    5460:	8942      	ldrh	r2, [r0, #10]
    5462:	42a2      	cmp	r2, r4
    5464:	d2ef      	bcs.n	5446 <pbuf_header+0x12>
    5466:	4b14      	ldr	r3, [pc, #80]	; (54b8 <pbuf_header+0x84>)
    5468:	f240 2202 	movw	r2, #514	; 0x202
    546c:	4913      	ldr	r1, [pc, #76]	; (54bc <pbuf_header+0x88>)
    546e:	4814      	ldr	r0, [pc, #80]	; (54c0 <pbuf_header+0x8c>)
    5470:	4c14      	ldr	r4, [pc, #80]	; (54c4 <pbuf_header+0x90>)
    5472:	47a0      	blx	r4
    5474:	e7fe      	b.n	5474 <pbuf_header+0x40>
		p->payload = (u8_t *)p->payload - header_size_increment;
    5476:	1ad2      	subs	r2, r2, r3
		if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
    5478:	f100 0110 	add.w	r1, r0, #16
    547c:	428a      	cmp	r2, r1
    547e:	d315      	bcc.n	54ac <pbuf_header+0x78>
		p->payload = (u8_t *)p->payload - header_size_increment;
    5480:	6042      	str	r2, [r0, #4]
	}
	/* modify pbuf length fields */
	p->len += header_size_increment;
    5482:	b29b      	uxth	r3, r3
    5484:	8942      	ldrh	r2, [r0, #10]
    5486:	441a      	add	r2, r3
    5488:	8142      	strh	r2, [r0, #10]
	p->tot_len += header_size_increment;
    548a:	8902      	ldrh	r2, [r0, #8]
    548c:	4413      	add	r3, r2
    548e:	8103      	strh	r3, [r0, #8]

	LWIP_DEBUGF(
	    PBUF_DEBUG | LWIP_DBG_TRACE,
	    ("pbuf_header: old %p new %p (%" S16_F ")\n", (void *)payload, (void *)p->payload, header_size_increment));

	return 0;
    5490:	2000      	movs	r0, #0
    5492:	bd10      	pop	{r4, pc}
		if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    5494:	2b00      	cmp	r3, #0
    5496:	da0b      	bge.n	54b0 <pbuf_header+0x7c>
    5498:	8941      	ldrh	r1, [r0, #10]
    549a:	42a1      	cmp	r1, r4
    549c:	d30a      	bcc.n	54b4 <pbuf_header+0x80>
			p->payload = (u8_t *)p->payload - header_size_increment;
    549e:	1ad2      	subs	r2, r2, r3
    54a0:	6042      	str	r2, [r0, #4]
    54a2:	e7ee      	b.n	5482 <pbuf_header+0x4e>
		return 0;
    54a4:	2000      	movs	r0, #0
    54a6:	4770      	bx	lr
    54a8:	2000      	movs	r0, #0
    54aa:	4770      	bx	lr
			return 1;
    54ac:	2001      	movs	r0, #1
    54ae:	bd10      	pop	{r4, pc}
			return 1;
    54b0:	2001      	movs	r0, #1
    54b2:	bd10      	pop	{r4, pc}
    54b4:	2001      	movs	r0, #1
}
    54b6:	bd10      	pop	{r4, pc}
    54b8:	0000bb30 	.word	0x0000bb30
    54bc:	0000bb54 	.word	0x0000bb54
    54c0:	0000ab0c 	.word	0x0000ab0c
    54c4:	00009815 	.word	0x00009815

000054c8 <pbuf_free>:
 * 2->1->1 becomes 1->1->1
 * 1->1->1 becomes .......
 *
 */
u8_t pbuf_free(struct pbuf *p)
{
    54c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u16_t        type;
	struct pbuf *q;
	u8_t         count;

	if (p == NULL) {
    54cc:	b338      	cbz	r0, 551e <pbuf_free+0x56>
    54ce:	4601      	mov	r1, r0
    54d0:	2400      	movs	r4, #0
					/* is this a ROM or RAM referencing pbuf? */
				} else if (type == PBUF_ROM || type == PBUF_REF) {
					memp_free(MEMP_PBUF, p);
					/* type == PBUF_RAM */
				} else {
					mem_free(p);
    54d2:	4d15      	ldr	r5, [pc, #84]	; (5528 <pbuf_free+0x60>)
					memp_free(MEMP_PBUF, p);
    54d4:	f04f 0808 	mov.w	r8, #8
    54d8:	4e14      	ldr	r6, [pc, #80]	; (552c <pbuf_free+0x64>)
    54da:	e006      	b.n	54ea <pbuf_free+0x22>
				pc->custom_free_function(p);
    54dc:	690b      	ldr	r3, [r1, #16]
    54de:	4608      	mov	r0, r1
    54e0:	4798      	blx	r3
				}
			}
			count++;
    54e2:	3401      	adds	r4, #1
    54e4:	b2e4      	uxtb	r4, r4
			/* proceed to next pbuf */
			p = q;
    54e6:	4639      	mov	r1, r7
	while (p != NULL) {
    54e8:	b1d7      	cbz	r7, 5520 <pbuf_free+0x58>
		ref = --(p->ref);
    54ea:	89cb      	ldrh	r3, [r1, #14]
    54ec:	3b01      	subs	r3, #1
    54ee:	b29b      	uxth	r3, r3
    54f0:	81cb      	strh	r3, [r1, #14]
		if (ref == 0) {
    54f2:	b9ab      	cbnz	r3, 5520 <pbuf_free+0x58>
			q = p->next;
    54f4:	680f      	ldr	r7, [r1, #0]
			if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
    54f6:	7b4b      	ldrb	r3, [r1, #13]
    54f8:	f013 0f02 	tst.w	r3, #2
    54fc:	d1ee      	bne.n	54dc <pbuf_free+0x14>
			type = p->type;
    54fe:	7b0b      	ldrb	r3, [r1, #12]
				if (type == PBUF_POOL) {
    5500:	2b03      	cmp	r3, #3
    5502:	d006      	beq.n	5512 <pbuf_free+0x4a>
				} else if (type == PBUF_ROM || type == PBUF_REF) {
    5504:	3b01      	subs	r3, #1
    5506:	b29b      	uxth	r3, r3
    5508:	2b01      	cmp	r3, #1
    550a:	d905      	bls.n	5518 <pbuf_free+0x50>
					mem_free(p);
    550c:	4608      	mov	r0, r1
    550e:	47a8      	blx	r5
    5510:	e7e7      	b.n	54e2 <pbuf_free+0x1a>
					memp_free(MEMP_PBUF_POOL, p);
    5512:	2009      	movs	r0, #9
    5514:	47b0      	blx	r6
    5516:	e7e4      	b.n	54e2 <pbuf_free+0x1a>
					memp_free(MEMP_PBUF, p);
    5518:	4640      	mov	r0, r8
    551a:	47b0      	blx	r6
    551c:	e7e1      	b.n	54e2 <pbuf_free+0x1a>
		return 0;
    551e:	2400      	movs	r4, #0
		}
	}
	PERF_STOP("pbuf_free");
	/* return number of de-allocated pbufs */
	return count;
}
    5520:	4620      	mov	r0, r4
    5522:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5526:	bf00      	nop
    5528:	00004f19 	.word	0x00004f19
    552c:	00005201 	.word	0x00005201

00005530 <pbuf_alloc>:
{
    5530:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	switch (layer) {
    5534:	2803      	cmp	r0, #3
    5536:	f200 808d 	bhi.w	5654 <pbuf_alloc+0x124>
    553a:	e8df f000 	tbb	[pc, r0]
    553e:	0208      	.short	0x0208
    5540:	0604      	.short	0x0604
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    5542:	2422      	movs	r4, #34	; 0x22
    5544:	e004      	b.n	5550 <pbuf_alloc+0x20>
		offset = PBUF_LINK_HLEN;
    5546:	240e      	movs	r4, #14
		break;
    5548:	e002      	b.n	5550 <pbuf_alloc+0x20>
		offset = 0;
    554a:	2400      	movs	r4, #0
		break;
    554c:	e000      	b.n	5550 <pbuf_alloc+0x20>
		offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    554e:	2436      	movs	r4, #54	; 0x36
    5550:	4617      	mov	r7, r2
    5552:	460d      	mov	r5, r1
	switch (type) {
    5554:	2a03      	cmp	r2, #3
    5556:	d87f      	bhi.n	5658 <pbuf_alloc+0x128>
    5558:	e8df f002 	tbb	[pc, r2]
    555c:	026f6f51 	.word	0x026f6f51
		p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    5560:	2009      	movs	r0, #9
    5562:	4b3e      	ldr	r3, [pc, #248]	; (565c <pbuf_alloc+0x12c>)
    5564:	4798      	blx	r3
		if (p == NULL) {
    5566:	4606      	mov	r6, r0
    5568:	2800      	cmp	r0, #0
    556a:	d03c      	beq.n	55e6 <pbuf_alloc+0xb6>
		p->type = type;
    556c:	2303      	movs	r3, #3
    556e:	7303      	strb	r3, [r0, #12]
		p->next = NULL;
    5570:	2300      	movs	r3, #0
    5572:	6003      	str	r3, [r0, #0]
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    5574:	1903      	adds	r3, r0, r4
    5576:	3313      	adds	r3, #19
    5578:	f023 0303 	bic.w	r3, r3, #3
    557c:	6043      	str	r3, [r0, #4]
		p->tot_len = length;
    557e:	8105      	strh	r5, [r0, #8]
		p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    5580:	3403      	adds	r4, #3
    5582:	f024 0403 	bic.w	r4, r4, #3
    5586:	f5c4 64bd 	rsb	r4, r4, #1512	; 0x5e8
    558a:	3404      	adds	r4, #4
    558c:	42ac      	cmp	r4, r5
    558e:	bfa8      	it	ge
    5590:	462c      	movge	r4, r5
    5592:	8144      	strh	r4, [r0, #10]
		p->ref = 1;
    5594:	2301      	movs	r3, #1
    5596:	81c3      	strh	r3, [r0, #14]
		rem_len = length - p->len;
    5598:	b2a4      	uxth	r4, r4
    559a:	1b2d      	subs	r5, r5, r4
		while (rem_len > 0) {
    559c:	2d00      	cmp	r5, #0
    559e:	dd45      	ble.n	562c <pbuf_alloc+0xfc>
    55a0:	4682      	mov	sl, r0
			q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    55a2:	f04f 0809 	mov.w	r8, #9
    55a6:	4f2d      	ldr	r7, [pc, #180]	; (565c <pbuf_alloc+0x12c>)
			q->type  = type;
    55a8:	f04f 0903 	mov.w	r9, #3
			q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    55ac:	4640      	mov	r0, r8
    55ae:	47b8      	blx	r7
			if (q == NULL) {
    55b0:	4604      	mov	r4, r0
    55b2:	b1e0      	cbz	r0, 55ee <pbuf_alloc+0xbe>
			q->type  = type;
    55b4:	f880 900c 	strb.w	r9, [r0, #12]
			q->flags = 0;
    55b8:	2300      	movs	r3, #0
    55ba:	7343      	strb	r3, [r0, #13]
			q->next  = NULL;
    55bc:	6003      	str	r3, [r0, #0]
			r->next = q;
    55be:	f8ca 0000 	str.w	r0, [sl]
			q->tot_len = (u16_t)rem_len;
    55c2:	b2ab      	uxth	r3, r5
    55c4:	8103      	strh	r3, [r0, #8]
			q->len     = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    55c6:	f240 52ec 	movw	r2, #1516	; 0x5ec
    55ca:	4293      	cmp	r3, r2
    55cc:	bf28      	it	cs
    55ce:	4613      	movcs	r3, r2
    55d0:	8143      	strh	r3, [r0, #10]
			q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    55d2:	f100 0210 	add.w	r2, r0, #16
    55d6:	6042      	str	r2, [r0, #4]
			q->ref = 1;
    55d8:	2201      	movs	r2, #1
    55da:	81c2      	strh	r2, [r0, #14]
			rem_len -= q->len;
    55dc:	1aed      	subs	r5, r5, r3
			r = q;
    55de:	4682      	mov	sl, r0
		while (rem_len > 0) {
    55e0:	2d00      	cmp	r5, #0
    55e2:	dce3      	bgt.n	55ac <pbuf_alloc+0x7c>
    55e4:	e022      	b.n	562c <pbuf_alloc+0xfc>
	pbuf_free_ooseq_pending = 1;
    55e6:	2201      	movs	r2, #1
    55e8:	4b1d      	ldr	r3, [pc, #116]	; (5660 <pbuf_alloc+0x130>)
    55ea:	701a      	strb	r2, [r3, #0]
    55ec:	e022      	b.n	5634 <pbuf_alloc+0x104>
    55ee:	2201      	movs	r2, #1
    55f0:	4b1b      	ldr	r3, [pc, #108]	; (5660 <pbuf_alloc+0x130>)
    55f2:	701a      	strb	r2, [r3, #0]
				pbuf_free(p);
    55f4:	4630      	mov	r0, r6
    55f6:	4b1b      	ldr	r3, [pc, #108]	; (5664 <pbuf_alloc+0x134>)
    55f8:	4798      	blx	r3
				return NULL;
    55fa:	4626      	mov	r6, r4
    55fc:	e01a      	b.n	5634 <pbuf_alloc+0x104>
		p = (struct pbuf *)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    55fe:	f104 0013 	add.w	r0, r4, #19
    5602:	f020 0003 	bic.w	r0, r0, #3
    5606:	1ccb      	adds	r3, r1, #3
    5608:	f023 0303 	bic.w	r3, r3, #3
    560c:	4418      	add	r0, r3
    560e:	b280      	uxth	r0, r0
    5610:	4b15      	ldr	r3, [pc, #84]	; (5668 <pbuf_alloc+0x138>)
    5612:	4798      	blx	r3
		if (p == NULL) {
    5614:	4606      	mov	r6, r0
    5616:	b168      	cbz	r0, 5634 <pbuf_alloc+0x104>
		p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    5618:	4404      	add	r4, r0
    561a:	3413      	adds	r4, #19
    561c:	f024 0403 	bic.w	r4, r4, #3
    5620:	6044      	str	r4, [r0, #4]
		p->len = p->tot_len = length;
    5622:	8105      	strh	r5, [r0, #8]
    5624:	8145      	strh	r5, [r0, #10]
		p->next             = NULL;
    5626:	2300      	movs	r3, #0
    5628:	6003      	str	r3, [r0, #0]
		p->type             = type;
    562a:	7303      	strb	r3, [r0, #12]
	p->ref = 1;
    562c:	2301      	movs	r3, #1
    562e:	81f3      	strh	r3, [r6, #14]
	p->flags = 0;
    5630:	2300      	movs	r3, #0
    5632:	7373      	strb	r3, [r6, #13]
}
    5634:	4630      	mov	r0, r6
    5636:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		p = (struct pbuf *)memp_malloc(MEMP_PBUF);
    563a:	2008      	movs	r0, #8
    563c:	4b07      	ldr	r3, [pc, #28]	; (565c <pbuf_alloc+0x12c>)
    563e:	4798      	blx	r3
		if (p == NULL) {
    5640:	4606      	mov	r6, r0
    5642:	2800      	cmp	r0, #0
    5644:	d0f6      	beq.n	5634 <pbuf_alloc+0x104>
		p->payload = NULL;
    5646:	2300      	movs	r3, #0
    5648:	6043      	str	r3, [r0, #4]
		p->len = p->tot_len = length;
    564a:	8105      	strh	r5, [r0, #8]
    564c:	8145      	strh	r5, [r0, #10]
		p->next             = NULL;
    564e:	6003      	str	r3, [r0, #0]
		p->type             = type;
    5650:	7307      	strb	r7, [r0, #12]
		break;
    5652:	e7eb      	b.n	562c <pbuf_alloc+0xfc>
		return NULL;
    5654:	2600      	movs	r6, #0
    5656:	e7ed      	b.n	5634 <pbuf_alloc+0x104>
		return NULL;
    5658:	2600      	movs	r6, #0
    565a:	e7eb      	b.n	5634 <pbuf_alloc+0x104>
    565c:	000051b9 	.word	0x000051b9
    5660:	200092d8 	.word	0x200092d8
    5664:	000054c9 	.word	0x000054c9
    5668:	0000506d 	.word	0x0000506d

0000566c <pbuf_realloc>:
	if (new_len >= p->tot_len) {
    566c:	8902      	ldrh	r2, [r0, #8]
    566e:	428a      	cmp	r2, r1
    5670:	d926      	bls.n	56c0 <pbuf_realloc+0x54>
{
    5672:	b538      	push	{r3, r4, r5, lr}
    5674:	4604      	mov	r4, r0
	while (rem_len > q->len) {
    5676:	8943      	ldrh	r3, [r0, #10]
    5678:	4299      	cmp	r1, r3
    567a:	d91f      	bls.n	56bc <pbuf_realloc+0x50>
    567c:	460d      	mov	r5, r1
		q->tot_len += (u16_t)grow;
    567e:	1a89      	subs	r1, r1, r2
		rem_len -= q->len;
    5680:	1aeb      	subs	r3, r5, r3
    5682:	b29d      	uxth	r5, r3
		q->tot_len += (u16_t)grow;
    5684:	8923      	ldrh	r3, [r4, #8]
    5686:	440b      	add	r3, r1
    5688:	8123      	strh	r3, [r4, #8]
		q = q->next;
    568a:	6824      	ldr	r4, [r4, #0]
	while (rem_len > q->len) {
    568c:	8963      	ldrh	r3, [r4, #10]
    568e:	42ab      	cmp	r3, r5
    5690:	d3f6      	bcc.n	5680 <pbuf_realloc+0x14>
	if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    5692:	7b22      	ldrb	r2, [r4, #12]
    5694:	b94a      	cbnz	r2, 56aa <pbuf_realloc+0x3e>
    5696:	429d      	cmp	r5, r3
    5698:	d007      	beq.n	56aa <pbuf_realloc+0x3e>
		q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    569a:	6863      	ldr	r3, [r4, #4]
    569c:	1b1b      	subs	r3, r3, r4
    569e:	18e9      	adds	r1, r5, r3
    56a0:	b289      	uxth	r1, r1
    56a2:	4620      	mov	r0, r4
    56a4:	4b07      	ldr	r3, [pc, #28]	; (56c4 <pbuf_realloc+0x58>)
    56a6:	4798      	blx	r3
    56a8:	4604      	mov	r4, r0
	q->len     = rem_len;
    56aa:	8165      	strh	r5, [r4, #10]
	q->tot_len = q->len;
    56ac:	8125      	strh	r5, [r4, #8]
	if (q->next != NULL) {
    56ae:	6820      	ldr	r0, [r4, #0]
    56b0:	b108      	cbz	r0, 56b6 <pbuf_realloc+0x4a>
		pbuf_free(q->next);
    56b2:	4b05      	ldr	r3, [pc, #20]	; (56c8 <pbuf_realloc+0x5c>)
    56b4:	4798      	blx	r3
	q->next = NULL;
    56b6:	2300      	movs	r3, #0
    56b8:	6023      	str	r3, [r4, #0]
    56ba:	bd38      	pop	{r3, r4, r5, pc}
	while (rem_len > q->len) {
    56bc:	460d      	mov	r5, r1
    56be:	e7e8      	b.n	5692 <pbuf_realloc+0x26>
    56c0:	4770      	bx	lr
    56c2:	bf00      	nop
    56c4:	00004fa5 	.word	0x00004fa5
    56c8:	000054c9 	.word	0x000054c9

000056cc <pbuf_clen>:
u8_t pbuf_clen(struct pbuf *p)
{
	u8_t len;

	len = 0;
	while (p != NULL) {
    56cc:	4603      	mov	r3, r0
    56ce:	b130      	cbz	r0, 56de <pbuf_clen+0x12>
    56d0:	2000      	movs	r0, #0
		++len;
    56d2:	3001      	adds	r0, #1
    56d4:	b2c0      	uxtb	r0, r0
		p = p->next;
    56d6:	681b      	ldr	r3, [r3, #0]
	while (p != NULL) {
    56d8:	2b00      	cmp	r3, #0
    56da:	d1fa      	bne.n	56d2 <pbuf_clen+0x6>
    56dc:	4770      	bx	lr
	len = 0;
    56de:	2000      	movs	r0, #0
	}
	return len;
}
    56e0:	4770      	bx	lr

000056e2 <pbuf_ref>:
 */
void pbuf_ref(struct pbuf *p)
{
	SYS_ARCH_DECL_PROTECT(old_level);
	/* pbuf given? */
	if (p != NULL) {
    56e2:	b110      	cbz	r0, 56ea <pbuf_ref+0x8>
		SYS_ARCH_PROTECT(old_level);
		++(p->ref);
    56e4:	89c3      	ldrh	r3, [r0, #14]
    56e6:	3301      	adds	r3, #1
    56e8:	81c3      	strh	r3, [r0, #14]
    56ea:	4770      	bx	lr

000056ec <pbuf_cat>:
 *
 * @see pbuf_chain()
 */

void pbuf_cat(struct pbuf *h, struct pbuf *t)
{
    56ec:	b510      	push	{r4, lr}
	struct pbuf *p;

	LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)", ((h != NULL) && (t != NULL)), return;);
    56ee:	b128      	cbz	r0, 56fc <pbuf_cat+0x10>
    56f0:	4602      	mov	r2, r0
    56f2:	b119      	cbz	r1, 56fc <pbuf_cat+0x10>

	/* proceed to last pbuf of chain */
	for (p = h; p->next != NULL; p = p->next) {
    56f4:	6803      	ldr	r3, [r0, #0]
    56f6:	b953      	cbnz	r3, 570e <pbuf_cat+0x22>
    56f8:	4603      	mov	r3, r0
    56fa:	e010      	b.n	571e <pbuf_cat+0x32>
	LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)", ((h != NULL) && (t != NULL)), return;);
    56fc:	4b0b      	ldr	r3, [pc, #44]	; (572c <pbuf_cat+0x40>)
    56fe:	f240 22df 	movw	r2, #735	; 0x2df
    5702:	490b      	ldr	r1, [pc, #44]	; (5730 <pbuf_cat+0x44>)
    5704:	480b      	ldr	r0, [pc, #44]	; (5734 <pbuf_cat+0x48>)
    5706:	4c0c      	ldr	r4, [pc, #48]	; (5738 <pbuf_cat+0x4c>)
    5708:	47a0      	blx	r4
    570a:	e7fe      	b.n	570a <pbuf_cat+0x1e>
	for (p = h; p->next != NULL; p = p->next) {
    570c:	4603      	mov	r3, r0
		/* add total length of second chain to all totals of first chain */
		p->tot_len += t->tot_len;
    570e:	8910      	ldrh	r0, [r2, #8]
    5710:	890c      	ldrh	r4, [r1, #8]
    5712:	4420      	add	r0, r4
    5714:	8110      	strh	r0, [r2, #8]
	for (p = h; p->next != NULL; p = p->next) {
    5716:	6818      	ldr	r0, [r3, #0]
    5718:	461a      	mov	r2, r3
    571a:	2800      	cmp	r0, #0
    571c:	d1f6      	bne.n	570c <pbuf_cat+0x20>
	}
	/* { p is last pbuf of first h chain, p->next == NULL } */
	LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
	LWIP_ASSERT("p->next == NULL", p->next == NULL);
	/* add total length of second chain to last pbuf total of first chain */
	p->tot_len += t->tot_len;
    571e:	891a      	ldrh	r2, [r3, #8]
    5720:	8908      	ldrh	r0, [r1, #8]
    5722:	4402      	add	r2, r0
    5724:	811a      	strh	r2, [r3, #8]
	/* chain last pbuf of head (p) with first of tail (t) */
	p->next = t;
    5726:	6019      	str	r1, [r3, #0]
    5728:	bd10      	pop	{r4, pc}
    572a:	bf00      	nop
    572c:	0000bb30 	.word	0x0000bb30
    5730:	0000bb74 	.word	0x0000bb74
    5734:	0000ab0c 	.word	0x0000ab0c
    5738:	00009815 	.word	0x00009815

0000573c <pbuf_chain>:
 * The ->next field of the last pbuf of the head chain is adjusted.
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void pbuf_chain(struct pbuf *h, struct pbuf *t)
{
    573c:	b510      	push	{r4, lr}
    573e:	460c      	mov	r4, r1
	pbuf_cat(h, t);
    5740:	4b02      	ldr	r3, [pc, #8]	; (574c <pbuf_chain+0x10>)
    5742:	4798      	blx	r3
	/* t is now referenced by h */
	pbuf_ref(t);
    5744:	4620      	mov	r0, r4
    5746:	4b02      	ldr	r3, [pc, #8]	; (5750 <pbuf_chain+0x14>)
    5748:	4798      	blx	r3
    574a:	bd10      	pop	{r4, pc}
    574c:	000056ed 	.word	0x000056ed
    5750:	000056e3 	.word	0x000056e3

00005754 <pbuf_copy>:
 * @return ERR_OK if pbuf was copied
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
    5754:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	u16_t offset_to = 0, offset_from = 0, len;

	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n", (void *)p_to, (void *)p_from));

	/* is the target big enough to hold the source? */
	LWIP_ERROR("pbuf_copy: target not big enough to hold source",
    5758:	b130      	cbz	r0, 5768 <pbuf_copy+0x14>
    575a:	460d      	mov	r5, r1
    575c:	4604      	mov	r4, r0
    575e:	b119      	cbz	r1, 5768 <pbuf_copy+0x14>
    5760:	8902      	ldrh	r2, [r0, #8]
    5762:	890b      	ldrh	r3, [r1, #8]
    5764:	429a      	cmp	r2, r3
    5766:	d207      	bcs.n	5778 <pbuf_copy+0x24>
    5768:	4b33      	ldr	r3, [pc, #204]	; (5838 <pbuf_copy+0xe4>)
    576a:	f240 324b 	movw	r2, #843	; 0x34b
    576e:	4933      	ldr	r1, [pc, #204]	; (583c <pbuf_copy+0xe8>)
    5770:	4833      	ldr	r0, [pc, #204]	; (5840 <pbuf_copy+0xec>)
    5772:	4c34      	ldr	r4, [pc, #208]	; (5844 <pbuf_copy+0xf0>)
    5774:	47a0      	blx	r4
    5776:	e7fe      	b.n	5776 <pbuf_copy+0x22>
    5778:	f04f 0a00 	mov.w	sl, #0
    577c:	4657      	mov	r7, sl
			len = p_from->len - offset_from;
		} else {
			/* current p_from does not fit into current p_to */
			len = p_to->len - offset_to;
		}
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    577e:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 5850 <pbuf_copy+0xfc>
		offset_from += len;
		LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
		LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
		if (offset_from >= p_from->len) {
			/* on to next p_from (if any) */
			offset_from = 0;
    5782:	46d0      	mov	r8, sl
    5784:	e02d      	b.n	57e2 <pbuf_copy+0x8e>
			p_from      = p_from->next;
		}
		if (offset_to == p_to->len) {
			/* on to next p_to (if any) */
			offset_to = 0;
			p_to      = p_to->next;
    5786:	6824      	ldr	r4, [r4, #0]
			LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
    5788:	b10c      	cbz	r4, 578e <pbuf_copy+0x3a>
			offset_to = 0;
    578a:	4647      	mov	r7, r8
    578c:	e047      	b.n	581e <pbuf_copy+0xca>
			LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
    578e:	b915      	cbnz	r5, 5796 <pbuf_copy+0x42>
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_to->next == NULL), return ERR_VAL;);
		}
	} while (p_from);
	LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
	return ERR_OK;
}
    5790:	2000      	movs	r0, #0
    5792:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
    5796:	4b28      	ldr	r3, [pc, #160]	; (5838 <pbuf_copy+0xe4>)
    5798:	f240 3265 	movw	r2, #869	; 0x365
    579c:	492a      	ldr	r1, [pc, #168]	; (5848 <pbuf_copy+0xf4>)
    579e:	4828      	ldr	r0, [pc, #160]	; (5840 <pbuf_copy+0xec>)
    57a0:	4c28      	ldr	r4, [pc, #160]	; (5844 <pbuf_copy+0xf0>)
    57a2:	47a0      	blx	r4
    57a4:	e7fe      	b.n	57a4 <pbuf_copy+0x50>
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_from->next == NULL), return ERR_VAL;);
    57a6:	682b      	ldr	r3, [r5, #0]
    57a8:	2b00      	cmp	r3, #0
    57aa:	d03e      	beq.n	582a <pbuf_copy+0xd6>
    57ac:	4b22      	ldr	r3, [pc, #136]	; (5838 <pbuf_copy+0xe4>)
    57ae:	f240 326a 	movw	r2, #874	; 0x36a
    57b2:	4926      	ldr	r1, [pc, #152]	; (584c <pbuf_copy+0xf8>)
    57b4:	4822      	ldr	r0, [pc, #136]	; (5840 <pbuf_copy+0xec>)
    57b6:	4c23      	ldr	r4, [pc, #140]	; (5844 <pbuf_copy+0xf0>)
    57b8:	47a0      	blx	r4
    57ba:	e7fe      	b.n	57ba <pbuf_copy+0x66>
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_to->next == NULL), return ERR_VAL;);
    57bc:	4b1e      	ldr	r3, [pc, #120]	; (5838 <pbuf_copy+0xe4>)
    57be:	f240 326e 	movw	r2, #878	; 0x36e
    57c2:	4922      	ldr	r1, [pc, #136]	; (584c <pbuf_copy+0xf8>)
    57c4:	481e      	ldr	r0, [pc, #120]	; (5840 <pbuf_copy+0xec>)
    57c6:	4c1f      	ldr	r4, [pc, #124]	; (5844 <pbuf_copy+0xf0>)
    57c8:	47a0      	blx	r4
    57ca:	e7fe      	b.n	57ca <pbuf_copy+0x76>
		if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    57cc:	2c00      	cmp	r4, #0
    57ce:	d0df      	beq.n	5790 <pbuf_copy+0x3c>
    57d0:	8962      	ldrh	r2, [r4, #10]
    57d2:	8923      	ldrh	r3, [r4, #8]
    57d4:	429a      	cmp	r2, r3
    57d6:	d1db      	bne.n	5790 <pbuf_copy+0x3c>
			LWIP_ERROR("pbuf_copy() does not allow packet queues!\n", (p_to->next == NULL), return ERR_VAL;);
    57d8:	6823      	ldr	r3, [r4, #0]
    57da:	2b00      	cmp	r3, #0
    57dc:	d1ee      	bne.n	57bc <pbuf_copy+0x68>
	} while (p_from);
    57de:	2d00      	cmp	r5, #0
    57e0:	d0d6      	beq.n	5790 <pbuf_copy+0x3c>
		if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    57e2:	8963      	ldrh	r3, [r4, #10]
    57e4:	896a      	ldrh	r2, [r5, #10]
    57e6:	1bd8      	subs	r0, r3, r7
    57e8:	eba2 010a 	sub.w	r1, r2, sl
    57ec:	4288      	cmp	r0, r1
			len = p_from->len - offset_from;
    57ee:	bfa7      	ittee	ge
    57f0:	460a      	movge	r2, r1
    57f2:	b296      	uxthge	r6, r2
			len = p_to->len - offset_to;
    57f4:	1bdb      	sublt	r3, r3, r7
    57f6:	b29e      	uxthlt	r6, r3
		MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
    57f8:	6860      	ldr	r0, [r4, #4]
    57fa:	6869      	ldr	r1, [r5, #4]
    57fc:	4632      	mov	r2, r6
    57fe:	4451      	add	r1, sl
    5800:	4438      	add	r0, r7
    5802:	47c8      	blx	r9
		offset_to += len;
    5804:	4437      	add	r7, r6
    5806:	b2bf      	uxth	r7, r7
		offset_from += len;
    5808:	4456      	add	r6, sl
    580a:	fa1f fa86 	uxth.w	sl, r6
		if (offset_from >= p_from->len) {
    580e:	896b      	ldrh	r3, [r5, #10]
    5810:	4553      	cmp	r3, sl
			p_from      = p_from->next;
    5812:	bf9c      	itt	ls
    5814:	682d      	ldrls	r5, [r5, #0]
			offset_from = 0;
    5816:	46c2      	movls	sl, r8
		if (offset_to == p_to->len) {
    5818:	8963      	ldrh	r3, [r4, #10]
    581a:	42bb      	cmp	r3, r7
    581c:	d0b3      	beq.n	5786 <pbuf_copy+0x32>
		if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
    581e:	2d00      	cmp	r5, #0
    5820:	d0d4      	beq.n	57cc <pbuf_copy+0x78>
    5822:	896a      	ldrh	r2, [r5, #10]
    5824:	892b      	ldrh	r3, [r5, #8]
    5826:	429a      	cmp	r2, r3
    5828:	d0bd      	beq.n	57a6 <pbuf_copy+0x52>
		if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    582a:	2c00      	cmp	r4, #0
    582c:	d0d9      	beq.n	57e2 <pbuf_copy+0x8e>
    582e:	8962      	ldrh	r2, [r4, #10]
    5830:	8923      	ldrh	r3, [r4, #8]
    5832:	429a      	cmp	r2, r3
    5834:	d1d5      	bne.n	57e2 <pbuf_copy+0x8e>
    5836:	e7cf      	b.n	57d8 <pbuf_copy+0x84>
    5838:	0000bb30 	.word	0x0000bb30
    583c:	0000bbac 	.word	0x0000bbac
    5840:	0000ab0c 	.word	0x0000ab0c
    5844:	00009815 	.word	0x00009815
    5848:	0000bbdc 	.word	0x0000bbdc
    584c:	0000bbec 	.word	0x0000bbec
    5850:	000097ef 	.word	0x000097ef

00005854 <pbuf_copy_partial>:
 * than buf->tot_len will be copied, irrespective of len
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
    5854:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct pbuf *p;
	u16_t        left;
	u16_t        buf_copy_len;
	u16_t        copied_total = 0;

	LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    5858:	b158      	cbz	r0, 5872 <pbuf_copy_partial+0x1e>
    585a:	460f      	mov	r7, r1
    585c:	4692      	mov	sl, r2
    585e:	4605      	mov	r5, r0
	LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    5860:	b179      	cbz	r1, 5882 <pbuf_copy_partial+0x2e>
	if ((buf == NULL) || (dataptr == NULL)) {
		return 0;
	}

	/* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
	for (p = buf; len != 0 && p != NULL; p = p->next) {
    5862:	4616      	mov	r6, r2
    5864:	2a00      	cmp	r2, #0
    5866:	d033      	beq.n	58d0 <pbuf_copy_partial+0x7c>
    5868:	2600      	movs	r6, #0
			/* copy from this buffer. maybe only partially. */
			buf_copy_len = p->len - offset;
			if (buf_copy_len > len)
				buf_copy_len = len;
			/* copy the necessary parts of the buffer */
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    586a:	f8df 9080 	ldr.w	r9, [pc, #128]	; 58ec <pbuf_copy_partial+0x98>
			copied_total += buf_copy_len;
			left += buf_copy_len;
			len -= buf_copy_len;
			offset = 0;
    586e:	46b0      	mov	r8, r6
    5870:	e026      	b.n	58c0 <pbuf_copy_partial+0x6c>
	LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    5872:	4b19      	ldr	r3, [pc, #100]	; (58d8 <pbuf_copy_partial+0x84>)
    5874:	f240 3287 	movw	r2, #903	; 0x387
    5878:	4918      	ldr	r1, [pc, #96]	; (58dc <pbuf_copy_partial+0x88>)
    587a:	4819      	ldr	r0, [pc, #100]	; (58e0 <pbuf_copy_partial+0x8c>)
    587c:	4c19      	ldr	r4, [pc, #100]	; (58e4 <pbuf_copy_partial+0x90>)
    587e:	47a0      	blx	r4
    5880:	e7fe      	b.n	5880 <pbuf_copy_partial+0x2c>
	LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    5882:	4b15      	ldr	r3, [pc, #84]	; (58d8 <pbuf_copy_partial+0x84>)
    5884:	f44f 7262 	mov.w	r2, #904	; 0x388
    5888:	4917      	ldr	r1, [pc, #92]	; (58e8 <pbuf_copy_partial+0x94>)
    588a:	4815      	ldr	r0, [pc, #84]	; (58e0 <pbuf_copy_partial+0x8c>)
    588c:	4c15      	ldr	r4, [pc, #84]	; (58e4 <pbuf_copy_partial+0x90>)
    588e:	47a0      	blx	r4
    5890:	e7fe      	b.n	5890 <pbuf_copy_partial+0x3c>
			buf_copy_len = p->len - offset;
    5892:	896c      	ldrh	r4, [r5, #10]
    5894:	1ae4      	subs	r4, r4, r3
    5896:	b2a4      	uxth	r4, r4
    5898:	4554      	cmp	r4, sl
    589a:	bf28      	it	cs
    589c:	4654      	movcs	r4, sl
			MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
    589e:	6869      	ldr	r1, [r5, #4]
    58a0:	4622      	mov	r2, r4
    58a2:	4419      	add	r1, r3
    58a4:	19b8      	adds	r0, r7, r6
    58a6:	47c8      	blx	r9
			copied_total += buf_copy_len;
    58a8:	4426      	add	r6, r4
    58aa:	b2b6      	uxth	r6, r6
			len -= buf_copy_len;
    58ac:	ebaa 0404 	sub.w	r4, sl, r4
    58b0:	fa1f fa84 	uxth.w	sl, r4
			offset = 0;
    58b4:	4643      	mov	r3, r8
	for (p = buf; len != 0 && p != NULL; p = p->next) {
    58b6:	682d      	ldr	r5, [r5, #0]
    58b8:	f1ba 0f00 	cmp.w	sl, #0
    58bc:	d008      	beq.n	58d0 <pbuf_copy_partial+0x7c>
    58be:	b13d      	cbz	r5, 58d0 <pbuf_copy_partial+0x7c>
		if ((offset != 0) && (offset >= p->len)) {
    58c0:	2b00      	cmp	r3, #0
    58c2:	d0e6      	beq.n	5892 <pbuf_copy_partial+0x3e>
    58c4:	896a      	ldrh	r2, [r5, #10]
    58c6:	429a      	cmp	r2, r3
    58c8:	d8e3      	bhi.n	5892 <pbuf_copy_partial+0x3e>
			offset -= p->len;
    58ca:	1a9b      	subs	r3, r3, r2
    58cc:	b29b      	uxth	r3, r3
    58ce:	e7f2      	b.n	58b6 <pbuf_copy_partial+0x62>
		}
	}
	return copied_total;
}
    58d0:	4630      	mov	r0, r6
    58d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    58d6:	bf00      	nop
    58d8:	0000bb30 	.word	0x0000bb30
    58dc:	0000bc18 	.word	0x0000bc18
    58e0:	0000ab0c 	.word	0x0000ab0c
    58e4:	00009815 	.word	0x00009815
    58e8:	0000bc38 	.word	0x0000bc38
    58ec:	000097ef 	.word	0x000097ef

000058f0 <raw_input>:
 * @return - 0 if packet is not eaten (pbuf is still referenced by the
 *           caller).
 *
 */
u8_t raw_input(struct pbuf *p, struct netif *inp)
{
    58f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	u8_t            eaten = 0;

	LWIP_UNUSED_ARG(inp);

	iphdr = (struct ip_hdr *)p->payload;
	proto = IPH_PROTO(iphdr);
    58f4:	6843      	ldr	r3, [r0, #4]
    58f6:	7a5e      	ldrb	r6, [r3, #9]

	prev = NULL;
	pcb  = raw_pcbs;
    58f8:	4b18      	ldr	r3, [pc, #96]	; (595c <raw_input+0x6c>)
    58fa:	681c      	ldr	r4, [r3, #0]
	/* loop through all raw pcbs until the packet is eaten by one */
	/* this allows multiple pcbs to match against the packet by design */
	while ((eaten == 0) && (pcb != NULL)) {
    58fc:	b35c      	cbz	r4, 5956 <raw_input+0x66>
    58fe:	4682      	mov	sl, r0
    5900:	2500      	movs	r5, #0
#endif /* IP_SOF_BROADCAST_RECV */
			{
				/* receive callback function available? */
				if (pcb->recv != NULL) {
					/* the receive callback function did not eat the packet? */
					if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
    5902:	f8df 805c 	ldr.w	r8, [pc, #92]	; 5960 <raw_input+0x70>
		    && (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
    5906:	f8df 905c 	ldr.w	r9, [pc, #92]	; 5964 <raw_input+0x74>
    590a:	e003      	b.n	5914 <raw_input+0x24>
				/* no receive callback function was set for this raw PCB */
			}
			/* drop the packet */
		}
		prev = pcb;
		pcb  = pcb->next;
    590c:	68e3      	ldr	r3, [r4, #12]
    590e:	4625      	mov	r5, r4
	while ((eaten == 0) && (pcb != NULL)) {
    5910:	b1f3      	cbz	r3, 5950 <raw_input+0x60>
		pcb  = pcb->next;
    5912:	461c      	mov	r4, r3
		if ((pcb->protocol == proto)
    5914:	7c23      	ldrb	r3, [r4, #16]
    5916:	42b3      	cmp	r3, r6
    5918:	d1f8      	bne.n	590c <raw_input+0x1c>
		    && (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
    591a:	b12c      	cbz	r4, 5928 <raw_input+0x38>
    591c:	6823      	ldr	r3, [r4, #0]
    591e:	b11b      	cbz	r3, 5928 <raw_input+0x38>
    5920:	f8d9 2000 	ldr.w	r2, [r9]
    5924:	4293      	cmp	r3, r2
    5926:	d1f1      	bne.n	590c <raw_input+0x1c>
				if (pcb->recv != NULL) {
    5928:	6967      	ldr	r7, [r4, #20]
    592a:	2f00      	cmp	r7, #0
    592c:	d0ee      	beq.n	590c <raw_input+0x1c>
					if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
    592e:	4643      	mov	r3, r8
    5930:	4652      	mov	r2, sl
    5932:	4621      	mov	r1, r4
    5934:	69a0      	ldr	r0, [r4, #24]
    5936:	47b8      	blx	r7
    5938:	2800      	cmp	r0, #0
    593a:	d0e7      	beq.n	590c <raw_input+0x1c>
						if (prev != NULL) {
    593c:	b12d      	cbz	r5, 594a <raw_input+0x5a>
							prev->next = pcb->next;
    593e:	68e3      	ldr	r3, [r4, #12]
    5940:	60eb      	str	r3, [r5, #12]
							pcb->next  = raw_pcbs;
    5942:	4b06      	ldr	r3, [pc, #24]	; (595c <raw_input+0x6c>)
    5944:	681a      	ldr	r2, [r3, #0]
    5946:	60e2      	str	r2, [r4, #12]
							raw_pcbs   = pcb;
    5948:	601c      	str	r4, [r3, #0]
		pcb  = pcb->next;
    594a:	2001      	movs	r0, #1
	}
	return eaten;
}
    594c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5950:	2000      	movs	r0, #0
    5952:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	u8_t            eaten = 0;
    5956:	2000      	movs	r0, #0
    5958:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    595c:	20007f94 	.word	0x20007f94
    5960:	2000830c 	.word	0x2000830c
    5964:	20008314 	.word	0x20008314

00005968 <tcp_init>:

/**
 * Initialize this module.
 */
void tcp_init(void)
{
    5968:	4770      	bx	lr

0000596a <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
    596a:	b470      	push	{r4, r5, r6}
    596c:	4602      	mov	r2, r0
	u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    596e:	6a85      	ldr	r5, [r0, #40]	; 0x28
    5970:	8d84      	ldrh	r4, [r0, #44]	; 0x2c

	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    5972:	6b01      	ldr	r1, [r0, #48]	; 0x30
	u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    5974:	1963      	adds	r3, r4, r5
    5976:	1a58      	subs	r0, r3, r1
	if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    5978:	8ed3      	ldrh	r3, [r2, #54]	; 0x36
    597a:	f640 3668 	movw	r6, #2920	; 0xb68
    597e:	42b3      	cmp	r3, r6
    5980:	bf94      	ite	ls
    5982:	1ac3      	subls	r3, r0, r3
    5984:	1b83      	subhi	r3, r0, r6
    5986:	2b00      	cmp	r3, #0
    5988:	db02      	blt.n	5990 <tcp_update_rcv_ann_wnd+0x26>
		/* we can advertise more window */
		pcb->rcv_ann_wnd = pcb->rcv_wnd;
    598a:	85d4      	strh	r4, [r2, #46]	; 0x2e
			LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
			pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
		}
		return 0;
	}
}
    598c:	bc70      	pop	{r4, r5, r6}
    598e:	4770      	bx	lr
		if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
    5990:	1a6b      	subs	r3, r5, r1
    5992:	2b00      	cmp	r3, #0
    5994:	dd03      	ble.n	599e <tcp_update_rcv_ann_wnd+0x34>
			pcb->rcv_ann_wnd = 0;
    5996:	2300      	movs	r3, #0
    5998:	85d3      	strh	r3, [r2, #46]	; 0x2e
		return 0;
    599a:	4618      	mov	r0, r3
    599c:	e7f6      	b.n	598c <tcp_update_rcv_ann_wnd+0x22>
			u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
    599e:	1b49      	subs	r1, r1, r5
			pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    59a0:	85d1      	strh	r1, [r2, #46]	; 0x2e
		return 0;
    59a2:	2000      	movs	r0, #0
    59a4:	e7f2      	b.n	598c <tcp_update_rcv_ann_wnd+0x22>
	...

000059a8 <tcp_recved>:
 *
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
    59a8:	b510      	push	{r4, lr}
    59aa:	4604      	mov	r4, r0

	/* pcb->state LISTEN not allowed here */
	LWIP_ASSERT("don't call tcp_recved for listen-pcbs", pcb->state != LISTEN);
	LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n", len <= 0xffff - pcb->rcv_wnd);

	pcb->rcv_wnd += len;
    59ac:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
    59ae:	4419      	add	r1, r3
    59b0:	b289      	uxth	r1, r1
	if (pcb->rcv_wnd > TCP_WND) {
    59b2:	f241 63d0 	movw	r3, #5840	; 0x16d0
    59b6:	4299      	cmp	r1, r3
	pcb->rcv_wnd += len;
    59b8:	bf92      	itee	ls
    59ba:	8581      	strhls	r1, [r0, #44]	; 0x2c
		pcb->rcv_wnd = TCP_WND;
    59bc:	f241 63d0 	movwhi	r3, #5840	; 0x16d0
    59c0:	8583      	strhhi	r3, [r0, #44]	; 0x2c
	}

	wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    59c2:	4b07      	ldr	r3, [pc, #28]	; (59e0 <tcp_recved+0x38>)
    59c4:	4798      	blx	r3

	/* If the change in the right edge of window is significant (default
	 * watermark is TCP_WND/4), then send an explicit update now.
	 * Otherwise wait for a packet to be sent in the normal course of
	 * events (or more window to be available later) */
	if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    59c6:	f240 53b3 	movw	r3, #1459	; 0x5b3
    59ca:	4298      	cmp	r0, r3
    59cc:	dc00      	bgt.n	59d0 <tcp_recved+0x28>
    59ce:	bd10      	pop	{r4, pc}
		tcp_ack_now(pcb);
    59d0:	7fa3      	ldrb	r3, [r4, #30]
    59d2:	f043 0302 	orr.w	r3, r3, #2
    59d6:	77a3      	strb	r3, [r4, #30]
		tcp_output(pcb);
    59d8:	4620      	mov	r0, r4
    59da:	4b02      	ldr	r3, [pc, #8]	; (59e4 <tcp_recved+0x3c>)
    59dc:	4798      	blx	r3
	LWIP_DEBUGF(TCP_DEBUG,
	            ("tcp_recved: recveived %" U16_F " bytes, wnd %" U16_F " (%" U16_F ").\n",
	             len,
	             pcb->rcv_wnd,
	             TCP_WND - pcb->rcv_wnd));
}
    59de:	e7f6      	b.n	59ce <tcp_recved+0x26>
    59e0:	0000596b 	.word	0x0000596b
    59e4:	00007a49 	.word	0x00007a49

000059e8 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void tcp_seg_free(struct tcp_seg *seg)
{
	if (seg != NULL) {
    59e8:	b150      	cbz	r0, 5a00 <tcp_seg_free+0x18>
{
    59ea:	b510      	push	{r4, lr}
    59ec:	4604      	mov	r4, r0
		if (seg->p != NULL) {
    59ee:	6840      	ldr	r0, [r0, #4]
    59f0:	b108      	cbz	r0, 59f6 <tcp_seg_free+0xe>
			pbuf_free(seg->p);
    59f2:	4b04      	ldr	r3, [pc, #16]	; (5a04 <tcp_seg_free+0x1c>)
    59f4:	4798      	blx	r3
#if TCP_DEBUG
			seg->p = NULL;
#endif /* TCP_DEBUG */
		}
		memp_free(MEMP_TCP_SEG, seg);
    59f6:	4621      	mov	r1, r4
    59f8:	2004      	movs	r0, #4
    59fa:	4b03      	ldr	r3, [pc, #12]	; (5a08 <tcp_seg_free+0x20>)
    59fc:	4798      	blx	r3
    59fe:	bd10      	pop	{r4, pc}
    5a00:	4770      	bx	lr
    5a02:	bf00      	nop
    5a04:	000054c9 	.word	0x000054c9
    5a08:	00005201 	.word	0x00005201

00005a0c <tcp_segs_free>:
	while (seg != NULL) {
    5a0c:	b148      	cbz	r0, 5a22 <tcp_segs_free+0x16>
{
    5a0e:	b538      	push	{r3, r4, r5, lr}
    5a10:	4603      	mov	r3, r0
		tcp_seg_free(seg);
    5a12:	4d04      	ldr	r5, [pc, #16]	; (5a24 <tcp_segs_free+0x18>)
		struct tcp_seg *next = seg->next;
    5a14:	681c      	ldr	r4, [r3, #0]
		tcp_seg_free(seg);
    5a16:	4618      	mov	r0, r3
    5a18:	47a8      	blx	r5
		seg = next;
    5a1a:	4623      	mov	r3, r4
	while (seg != NULL) {
    5a1c:	2c00      	cmp	r4, #0
    5a1e:	d1f9      	bne.n	5a14 <tcp_segs_free+0x8>
    5a20:	bd38      	pop	{r3, r4, r5, pc}
    5a22:	4770      	bx	lr
    5a24:	000059e9 	.word	0x000059e9

00005a28 <tcp_seg_copy>:
 *
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *tcp_seg_copy(struct tcp_seg *seg)
{
    5a28:	b538      	push	{r3, r4, r5, lr}
    5a2a:	4605      	mov	r5, r0
	struct tcp_seg *cseg;

	cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    5a2c:	2004      	movs	r0, #4
    5a2e:	4b09      	ldr	r3, [pc, #36]	; (5a54 <tcp_seg_copy+0x2c>)
    5a30:	4798      	blx	r3
	if (cseg == NULL) {
    5a32:	4604      	mov	r4, r0
    5a34:	b160      	cbz	r0, 5a50 <tcp_seg_copy+0x28>
		return NULL;
	}
	SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
    5a36:	682b      	ldr	r3, [r5, #0]
    5a38:	6868      	ldr	r0, [r5, #4]
    5a3a:	68a9      	ldr	r1, [r5, #8]
    5a3c:	68ea      	ldr	r2, [r5, #12]
    5a3e:	6023      	str	r3, [r4, #0]
    5a40:	6060      	str	r0, [r4, #4]
    5a42:	60a1      	str	r1, [r4, #8]
    5a44:	60e2      	str	r2, [r4, #12]
    5a46:	692b      	ldr	r3, [r5, #16]
    5a48:	6123      	str	r3, [r4, #16]
	pbuf_ref(cseg->p);
    5a4a:	6860      	ldr	r0, [r4, #4]
    5a4c:	4b02      	ldr	r3, [pc, #8]	; (5a58 <tcp_seg_copy+0x30>)
    5a4e:	4798      	blx	r3
	return cseg;
}
    5a50:	4620      	mov	r0, r4
    5a52:	bd38      	pop	{r3, r4, r5, pc}
    5a54:	000051b9 	.word	0x000051b9
    5a58:	000056e3 	.word	0x000056e3

00005a5c <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void tcp_pcb_purge(struct tcp_pcb *pcb)
{
	if (pcb->state != CLOSED && pcb->state != TIME_WAIT && pcb->state != LISTEN) {
    5a5c:	7e03      	ldrb	r3, [r0, #24]
    5a5e:	2b01      	cmp	r3, #1
    5a60:	d91a      	bls.n	5a98 <tcp_pcb_purge+0x3c>
    5a62:	2b0a      	cmp	r3, #10
    5a64:	d018      	beq.n	5a98 <tcp_pcb_purge+0x3c>
{
    5a66:	b570      	push	{r4, r5, r6, lr}
    5a68:	4604      	mov	r4, r0
				}
			}
		}
#endif /* TCP_LISTEN_BACKLOG */

		if (pcb->refused_data != NULL) {
    5a6a:	6f80      	ldr	r0, [r0, #120]	; 0x78
    5a6c:	b118      	cbz	r0, 5a76 <tcp_pcb_purge+0x1a>
			LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
			pbuf_free(pcb->refused_data);
    5a6e:	4b0b      	ldr	r3, [pc, #44]	; (5a9c <tcp_pcb_purge+0x40>)
    5a70:	4798      	blx	r3
			pcb->refused_data = NULL;
    5a72:	2300      	movs	r3, #0
    5a74:	67a3      	str	r3, [r4, #120]	; 0x78
		}
#if TCP_QUEUE_OOSEQ
		if (pcb->ooseq != NULL) {
			LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
		}
		tcp_segs_free(pcb->ooseq);
    5a76:	6f60      	ldr	r0, [r4, #116]	; 0x74
    5a78:	4e09      	ldr	r6, [pc, #36]	; (5aa0 <tcp_pcb_purge+0x44>)
    5a7a:	47b0      	blx	r6
		pcb->ooseq = NULL;
    5a7c:	2500      	movs	r5, #0
    5a7e:	6765      	str	r5, [r4, #116]	; 0x74
#endif /* TCP_QUEUE_OOSEQ */

		/* Stop the retransmission timer as it will expect data on unacked
		   queue if it fires */
		pcb->rtime = -1;
    5a80:	f64f 73ff 	movw	r3, #65535	; 0xffff
    5a84:	86a3      	strh	r3, [r4, #52]	; 0x34

		tcp_segs_free(pcb->unsent);
    5a86:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    5a88:	47b0      	blx	r6
		tcp_segs_free(pcb->unacked);
    5a8a:	6f20      	ldr	r0, [r4, #112]	; 0x70
    5a8c:	47b0      	blx	r6
		pcb->unacked = pcb->unsent = NULL;
    5a8e:	66e5      	str	r5, [r4, #108]	; 0x6c
    5a90:	6725      	str	r5, [r4, #112]	; 0x70
#if TCP_OVERSIZE
		pcb->unsent_oversize = 0;
    5a92:	f8a4 506a 	strh.w	r5, [r4, #106]	; 0x6a
    5a96:	bd70      	pop	{r4, r5, r6, pc}
    5a98:	4770      	bx	lr
    5a9a:	bf00      	nop
    5a9c:	000054c9 	.word	0x000054c9
    5aa0:	00005a0d 	.word	0x00005a0d

00005aa4 <tcp_slowtmr>:
{
    5aa4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5aa8:	b083      	sub	sp, #12
	++tcp_ticks;
    5aaa:	4ab6      	ldr	r2, [pc, #728]	; (5d84 <tcp_slowtmr+0x2e0>)
    5aac:	6813      	ldr	r3, [r2, #0]
    5aae:	3301      	adds	r3, #1
    5ab0:	6013      	str	r3, [r2, #0]
	++tcp_timer_ctr;
    5ab2:	4ab5      	ldr	r2, [pc, #724]	; (5d88 <tcp_slowtmr+0x2e4>)
    5ab4:	7813      	ldrb	r3, [r2, #0]
    5ab6:	3301      	adds	r3, #1
    5ab8:	7013      	strb	r3, [r2, #0]
		if (pcb->last_timer == tcp_timer_ctr) {
    5aba:	4615      	mov	r5, r2
				tcp_active_pcbs_changed = 0;
    5abc:	4fb3      	ldr	r7, [pc, #716]	; (5d8c <tcp_slowtmr+0x2e8>)
			if ((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
    5abe:	f8df b2f8 	ldr.w	fp, [pc, #760]	; 5db8 <tcp_slowtmr+0x314>
	pcb  = tcp_active_pcbs;
    5ac2:	4bb3      	ldr	r3, [pc, #716]	; (5d90 <tcp_slowtmr+0x2ec>)
    5ac4:	681c      	ldr	r4, [r3, #0]
	while (pcb != NULL) {
    5ac6:	2c00      	cmp	r4, #0
    5ac8:	f000 817d 	beq.w	5dc6 <tcp_slowtmr+0x322>
    5acc:	2600      	movs	r6, #0
    5ace:	e003      	b.n	5ad8 <tcp_slowtmr+0x34>
			pcb = pcb->next;
    5ad0:	68e4      	ldr	r4, [r4, #12]
	while (pcb != NULL) {
    5ad2:	2c00      	cmp	r4, #0
    5ad4:	f000 8177 	beq.w	5dc6 <tcp_slowtmr+0x322>
		if (pcb->last_timer == tcp_timer_ctr) {
    5ad8:	782b      	ldrb	r3, [r5, #0]
    5ada:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    5ade:	429a      	cmp	r2, r3
    5ae0:	d0f6      	beq.n	5ad0 <tcp_slowtmr+0x2c>
		pcb->last_timer = tcp_timer_ctr;
    5ae2:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
		if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    5ae6:	7e22      	ldrb	r2, [r4, #24]
    5ae8:	2a02      	cmp	r2, #2
    5aea:	d023      	beq.n	5b34 <tcp_slowtmr+0x90>
		} else if (pcb->nrtx == TCP_MAXRTX) {
    5aec:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
    5af0:	2b0c      	cmp	r3, #12
    5af2:	d061      	beq.n	5bb8 <tcp_slowtmr+0x114>
			if (pcb->persist_backoff > 0) {
    5af4:	f894 8095 	ldrb.w	r8, [r4, #149]	; 0x95
    5af8:	f1b8 0f00 	cmp.w	r8, #0
    5afc:	d026      	beq.n	5b4c <tcp_slowtmr+0xa8>
				pcb->persist_cnt++;
    5afe:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
    5b02:	3301      	adds	r3, #1
    5b04:	b2db      	uxtb	r3, r3
    5b06:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
				if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff - 1]) {
    5b0a:	4aa2      	ldr	r2, [pc, #648]	; (5d94 <tcp_slowtmr+0x2f0>)
    5b0c:	4442      	add	r2, r8
    5b0e:	7bd2      	ldrb	r2, [r2, #15]
    5b10:	429a      	cmp	r2, r3
    5b12:	d874      	bhi.n	5bfe <tcp_slowtmr+0x15a>
					pcb->persist_cnt = 0;
    5b14:	2300      	movs	r3, #0
    5b16:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
					if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
    5b1a:	f1b8 0f06 	cmp.w	r8, #6
						pcb->persist_backoff++;
    5b1e:	bf9c      	itt	ls
    5b20:	f108 0801 	addls.w	r8, r8, #1
    5b24:	f884 8095 	strbls.w	r8, [r4, #149]	; 0x95
					tcp_zero_window_probe(pcb);
    5b28:	4620      	mov	r0, r4
    5b2a:	4b9b      	ldr	r3, [pc, #620]	; (5d98 <tcp_slowtmr+0x2f4>)
    5b2c:	4798      	blx	r3
		pcb_remove = 0;
    5b2e:	f04f 0800 	mov.w	r8, #0
    5b32:	e043      	b.n	5bbc <tcp_slowtmr+0x118>
		if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    5b34:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
    5b38:	2b06      	cmp	r3, #6
    5b3a:	f000 8090 	beq.w	5c5e <tcp_slowtmr+0x1ba>
		} else if (pcb->nrtx == TCP_MAXRTX) {
    5b3e:	2b0c      	cmp	r3, #12
    5b40:	d1d8      	bne.n	5af4 <tcp_slowtmr+0x50>
		pcb_reset  = 0;
    5b42:	f04f 0900 	mov.w	r9, #0
		} else if (pcb->nrtx == TCP_MAXRTX) {
    5b46:	f04f 0801 	mov.w	r8, #1
    5b4a:	e08f      	b.n	5c6c <tcp_slowtmr+0x1c8>
				if (pcb->rtime >= 0) {
    5b4c:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
    5b50:	2900      	cmp	r1, #0
					++pcb->rtime;
    5b52:	bfa4      	itt	ge
    5b54:	3101      	addge	r1, #1
    5b56:	86a1      	strhge	r1, [r4, #52]	; 0x34
				if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
    5b58:	6f21      	ldr	r1, [r4, #112]	; 0x70
    5b5a:	b379      	cbz	r1, 5bbc <tcp_slowtmr+0x118>
    5b5c:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
    5b60:	f9b4 1044 	ldrsh.w	r1, [r4, #68]	; 0x44
    5b64:	4288      	cmp	r0, r1
    5b66:	db29      	blt.n	5bbc <tcp_slowtmr+0x118>
					if (pcb->state != SYN_SENT) {
    5b68:	2a02      	cmp	r2, #2
    5b6a:	d00c      	beq.n	5b86 <tcp_slowtmr+0xe2>
						pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    5b6c:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
    5b70:	f9b4 2042 	ldrsh.w	r2, [r4, #66]	; 0x42
    5b74:	eb02 02e1 	add.w	r2, r2, r1, asr #3
    5b78:	4986      	ldr	r1, [pc, #536]	; (5d94 <tcp_slowtmr+0x2f0>)
    5b7a:	440b      	add	r3, r1
    5b7c:	7e1b      	ldrb	r3, [r3, #24]
    5b7e:	fa02 f303 	lsl.w	r3, r2, r3
    5b82:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
					pcb->rtime = 0;
    5b86:	2300      	movs	r3, #0
    5b88:	86a3      	strh	r3, [r4, #52]	; 0x34
					eff_wnd       = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    5b8a:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    5b8e:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
					pcb->ssthresh = eff_wnd >> 1;
    5b92:	4293      	cmp	r3, r2
    5b94:	bf28      	it	cs
    5b96:	4613      	movcs	r3, r2
    5b98:	085b      	lsrs	r3, r3, #1
    5b9a:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
					if (pcb->ssthresh < (pcb->mss << 1)) {
    5b9e:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
    5ba0:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
						pcb->ssthresh = (pcb->mss << 1);
    5ba4:	bfbc      	itt	lt
    5ba6:	0053      	lsllt	r3, r2, #1
    5ba8:	f8a4 304e 	strhlt.w	r3, [r4, #78]	; 0x4e
					pcb->cwnd = pcb->mss;
    5bac:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
					tcp_rexmit_rto(pcb);
    5bb0:	4620      	mov	r0, r4
    5bb2:	4b7a      	ldr	r3, [pc, #488]	; (5d9c <tcp_slowtmr+0x2f8>)
    5bb4:	4798      	blx	r3
    5bb6:	e001      	b.n	5bbc <tcp_slowtmr+0x118>
			++pcb_remove;
    5bb8:	f04f 0801 	mov.w	r8, #1
		if (pcb->state == FIN_WAIT_2) {
    5bbc:	7e23      	ldrb	r3, [r4, #24]
    5bbe:	2b06      	cmp	r3, #6
    5bc0:	d020      	beq.n	5c04 <tcp_slowtmr+0x160>
		if (ip_get_option(pcb, SOF_KEEPALIVE) && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    5bc2:	7a22      	ldrb	r2, [r4, #8]
    5bc4:	f012 0f08 	tst.w	r2, #8
    5bc8:	d04e      	beq.n	5c68 <tcp_slowtmr+0x1c4>
    5bca:	2b04      	cmp	r3, #4
    5bcc:	d001      	beq.n	5bd2 <tcp_slowtmr+0x12e>
    5bce:	2b07      	cmp	r3, #7
    5bd0:	d17f      	bne.n	5cd2 <tcp_slowtmr+0x22e>
			if ((u32_t)(tcp_ticks - pcb->tmr) > (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
    5bd2:	4b6c      	ldr	r3, [pc, #432]	; (5d84 <tcp_slowtmr+0x2e0>)
    5bd4:	681a      	ldr	r2, [r3, #0]
    5bd6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5bd8:	1ad2      	subs	r2, r2, r3
    5bda:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
    5bde:	f501 2324 	add.w	r3, r1, #671744	; 0xa4000
    5be2:	f603 43b8 	addw	r3, r3, #3256	; 0xcb8
    5be6:	fbab 0303 	umull	r0, r3, fp, r3
    5bea:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
    5bee:	d91e      	bls.n	5c2e <tcp_slowtmr+0x18a>
				++pcb_remove;
    5bf0:	f108 0801 	add.w	r8, r8, #1
    5bf4:	fa5f f888 	uxtb.w	r8, r8
				++pcb_reset;
    5bf8:	f04f 0901 	mov.w	r9, #1
    5bfc:	e036      	b.n	5c6c <tcp_slowtmr+0x1c8>
		pcb_remove = 0;
    5bfe:	f04f 0800 	mov.w	r8, #0
    5c02:	e7db      	b.n	5bbc <tcp_slowtmr+0x118>
			if (pcb->flags & TF_RXCLOSED) {
    5c04:	7fa3      	ldrb	r3, [r4, #30]
    5c06:	f013 0f10 	tst.w	r3, #16
    5c0a:	d009      	beq.n	5c20 <tcp_slowtmr+0x17c>
				if ((u32_t)(tcp_ticks - pcb->tmr) > TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
    5c0c:	4b5d      	ldr	r3, [pc, #372]	; (5d84 <tcp_slowtmr+0x2e0>)
    5c0e:	681b      	ldr	r3, [r3, #0]
    5c10:	6a62      	ldr	r2, [r4, #36]	; 0x24
    5c12:	1a9b      	subs	r3, r3, r2
    5c14:	2b28      	cmp	r3, #40	; 0x28
    5c16:	d903      	bls.n	5c20 <tcp_slowtmr+0x17c>
					++pcb_remove;
    5c18:	f108 0801 	add.w	r8, r8, #1
    5c1c:	fa5f f888 	uxtb.w	r8, r8
		if (pcb->ooseq != NULL && (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    5c20:	6f60      	ldr	r0, [r4, #116]	; 0x74
    5c22:	2800      	cmp	r0, #0
    5c24:	f000 80f1 	beq.w	5e0a <tcp_slowtmr+0x366>
		pcb_reset  = 0;
    5c28:	f04f 0900 	mov.w	r9, #0
    5c2c:	e020      	b.n	5c70 <tcp_slowtmr+0x1cc>
			           > (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb)) / TCP_SLOW_INTERVAL) {
    5c2e:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
    5c32:	485b      	ldr	r0, [pc, #364]	; (5da0 <tcp_slowtmr+0x2fc>)
    5c34:	fb00 1303 	mla	r3, r0, r3, r1
    5c38:	fbab 1303 	umull	r1, r3, fp, r3
			} else if ((u32_t)(tcp_ticks - pcb->tmr)
    5c3c:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
    5c40:	d802      	bhi.n	5c48 <tcp_slowtmr+0x1a4>
		pcb_reset  = 0;
    5c42:	f04f 0900 	mov.w	r9, #0
    5c46:	e011      	b.n	5c6c <tcp_slowtmr+0x1c8>
				tcp_keepalive(pcb);
    5c48:	4620      	mov	r0, r4
    5c4a:	4b56      	ldr	r3, [pc, #344]	; (5da4 <tcp_slowtmr+0x300>)
    5c4c:	4798      	blx	r3
				pcb->keep_cnt_sent++;
    5c4e:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
    5c52:	3301      	adds	r3, #1
    5c54:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
		pcb_reset  = 0;
    5c58:	f04f 0900 	mov.w	r9, #0
    5c5c:	e006      	b.n	5c6c <tcp_slowtmr+0x1c8>
    5c5e:	f04f 0900 	mov.w	r9, #0
    5c62:	f04f 0801 	mov.w	r8, #1
    5c66:	e001      	b.n	5c6c <tcp_slowtmr+0x1c8>
    5c68:	f04f 0900 	mov.w	r9, #0
		if (pcb->ooseq != NULL && (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    5c6c:	6f60      	ldr	r0, [r4, #116]	; 0x74
    5c6e:	b150      	cbz	r0, 5c86 <tcp_slowtmr+0x1e2>
    5c70:	4b44      	ldr	r3, [pc, #272]	; (5d84 <tcp_slowtmr+0x2e0>)
    5c72:	681a      	ldr	r2, [r3, #0]
    5c74:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5c76:	1ad2      	subs	r2, r2, r3
    5c78:	f9b4 3044 	ldrsh.w	r3, [r4, #68]	; 0x44
    5c7c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    5c80:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
    5c84:	d228      	bcs.n	5cd8 <tcp_slowtmr+0x234>
		if (pcb->state == SYN_RCVD) {
    5c86:	7e23      	ldrb	r3, [r4, #24]
    5c88:	2b03      	cmp	r3, #3
    5c8a:	d02a      	beq.n	5ce2 <tcp_slowtmr+0x23e>
		if (pcb->state == LAST_ACK) {
    5c8c:	2b09      	cmp	r3, #9
    5c8e:	d033      	beq.n	5cf8 <tcp_slowtmr+0x254>
		if (pcb_remove) {
    5c90:	f1b8 0f00 	cmp.w	r8, #0
    5c94:	d13b      	bne.n	5d0e <tcp_slowtmr+0x26a>
			pcb  = pcb->next;
    5c96:	f8d4 800c 	ldr.w	r8, [r4, #12]
			++prev->polltmr;
    5c9a:	7fe3      	ldrb	r3, [r4, #31]
    5c9c:	3301      	adds	r3, #1
    5c9e:	b2db      	uxtb	r3, r3
    5ca0:	77e3      	strb	r3, [r4, #31]
			if (prev->polltmr >= prev->pollinterval) {
    5ca2:	f894 2020 	ldrb.w	r2, [r4, #32]
    5ca6:	429a      	cmp	r2, r3
    5ca8:	f200 808a 	bhi.w	5dc0 <tcp_slowtmr+0x31c>
				prev->polltmr = 0;
    5cac:	2300      	movs	r3, #0
    5cae:	77e3      	strb	r3, [r4, #31]
				tcp_active_pcbs_changed = 0;
    5cb0:	703b      	strb	r3, [r7, #0]
				TCP_EVENT_POLL(prev, err);
    5cb2:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    5cb6:	2b00      	cmp	r3, #0
    5cb8:	d05b      	beq.n	5d72 <tcp_slowtmr+0x2ce>
    5cba:	4621      	mov	r1, r4
    5cbc:	6920      	ldr	r0, [r4, #16]
    5cbe:	4798      	blx	r3
				if (tcp_active_pcbs_changed) {
    5cc0:	783b      	ldrb	r3, [r7, #0]
    5cc2:	2b00      	cmp	r3, #0
    5cc4:	f47f aefd 	bne.w	5ac2 <tcp_slowtmr+0x1e>
				if (err == ERR_OK) {
    5cc8:	2800      	cmp	r0, #0
    5cca:	d052      	beq.n	5d72 <tcp_slowtmr+0x2ce>
    5ccc:	4626      	mov	r6, r4
			pcb  = pcb->next;
    5cce:	4644      	mov	r4, r8
    5cd0:	e6ff      	b.n	5ad2 <tcp_slowtmr+0x2e>
		pcb_reset  = 0;
    5cd2:	f04f 0900 	mov.w	r9, #0
    5cd6:	e7c9      	b.n	5c6c <tcp_slowtmr+0x1c8>
			tcp_segs_free(pcb->ooseq);
    5cd8:	4b33      	ldr	r3, [pc, #204]	; (5da8 <tcp_slowtmr+0x304>)
    5cda:	4798      	blx	r3
			pcb->ooseq = NULL;
    5cdc:	2300      	movs	r3, #0
    5cde:	6763      	str	r3, [r4, #116]	; 0x74
    5ce0:	e7d1      	b.n	5c86 <tcp_slowtmr+0x1e2>
			if ((u32_t)(tcp_ticks - pcb->tmr) > TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
    5ce2:	4b28      	ldr	r3, [pc, #160]	; (5d84 <tcp_slowtmr+0x2e0>)
    5ce4:	681b      	ldr	r3, [r3, #0]
    5ce6:	6a62      	ldr	r2, [r4, #36]	; 0x24
    5ce8:	1a9b      	subs	r3, r3, r2
    5cea:	2b28      	cmp	r3, #40	; 0x28
    5cec:	d9d0      	bls.n	5c90 <tcp_slowtmr+0x1ec>
				++pcb_remove;
    5cee:	f108 0801 	add.w	r8, r8, #1
    5cf2:	fa5f f888 	uxtb.w	r8, r8
    5cf6:	e7cb      	b.n	5c90 <tcp_slowtmr+0x1ec>
			if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    5cf8:	4b22      	ldr	r3, [pc, #136]	; (5d84 <tcp_slowtmr+0x2e0>)
    5cfa:	681b      	ldr	r3, [r3, #0]
    5cfc:	6a62      	ldr	r2, [r4, #36]	; 0x24
    5cfe:	1a9b      	subs	r3, r3, r2
    5d00:	2bf0      	cmp	r3, #240	; 0xf0
				++pcb_remove;
    5d02:	bf84      	itt	hi
    5d04:	f108 0801 	addhi.w	r8, r8, #1
    5d08:	fa5f f888 	uxtbhi.w	r8, r8
    5d0c:	e7c0      	b.n	5c90 <tcp_slowtmr+0x1ec>
			tcp_pcb_purge(pcb);
    5d0e:	4620      	mov	r0, r4
    5d10:	4b26      	ldr	r3, [pc, #152]	; (5dac <tcp_slowtmr+0x308>)
    5d12:	4798      	blx	r3
			if (prev != NULL) {
    5d14:	b1ee      	cbz	r6, 5d52 <tcp_slowtmr+0x2ae>
				prev->next = pcb->next;
    5d16:	68e3      	ldr	r3, [r4, #12]
    5d18:	60f3      	str	r3, [r6, #12]
			if (pcb_reset) {
    5d1a:	f1b9 0f00 	cmp.w	r9, #0
    5d1e:	d11c      	bne.n	5d5a <tcp_slowtmr+0x2b6>
			err_fn  = pcb->errf;
    5d20:	f8d4 808c 	ldr.w	r8, [r4, #140]	; 0x8c
			err_arg = pcb->callback_arg;
    5d24:	f8d4 a010 	ldr.w	sl, [r4, #16]
			pcb     = pcb->next;
    5d28:	f8d4 900c 	ldr.w	r9, [r4, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    5d2c:	4621      	mov	r1, r4
    5d2e:	2002      	movs	r0, #2
    5d30:	4b1f      	ldr	r3, [pc, #124]	; (5db0 <tcp_slowtmr+0x30c>)
    5d32:	4798      	blx	r3
			tcp_active_pcbs_changed = 0;
    5d34:	2300      	movs	r3, #0
    5d36:	703b      	strb	r3, [r7, #0]
			TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
    5d38:	f1b8 0f00 	cmp.w	r8, #0
    5d3c:	d01f      	beq.n	5d7e <tcp_slowtmr+0x2da>
    5d3e:	f06f 0109 	mvn.w	r1, #9
    5d42:	4650      	mov	r0, sl
    5d44:	47c0      	blx	r8
			if (tcp_active_pcbs_changed) {
    5d46:	783b      	ldrb	r3, [r7, #0]
    5d48:	2b00      	cmp	r3, #0
    5d4a:	f47f aeba 	bne.w	5ac2 <tcp_slowtmr+0x1e>
			pcb     = pcb->next;
    5d4e:	464c      	mov	r4, r9
    5d50:	e6bf      	b.n	5ad2 <tcp_slowtmr+0x2e>
				tcp_active_pcbs = pcb->next;
    5d52:	68e3      	ldr	r3, [r4, #12]
    5d54:	4a0e      	ldr	r2, [pc, #56]	; (5d90 <tcp_slowtmr+0x2ec>)
    5d56:	6013      	str	r3, [r2, #0]
    5d58:	e7df      	b.n	5d1a <tcp_slowtmr+0x276>
				tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    5d5a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    5d5c:	6d20      	ldr	r0, [r4, #80]	; 0x50
    5d5e:	8ba3      	ldrh	r3, [r4, #28]
    5d60:	9301      	str	r3, [sp, #4]
    5d62:	8b63      	ldrh	r3, [r4, #26]
    5d64:	9300      	str	r3, [sp, #0]
    5d66:	1d23      	adds	r3, r4, #4
    5d68:	4622      	mov	r2, r4
    5d6a:	f8df 8050 	ldr.w	r8, [pc, #80]	; 5dbc <tcp_slowtmr+0x318>
    5d6e:	47c0      	blx	r8
    5d70:	e7d6      	b.n	5d20 <tcp_slowtmr+0x27c>
					tcp_output(prev);
    5d72:	4620      	mov	r0, r4
    5d74:	4b0f      	ldr	r3, [pc, #60]	; (5db4 <tcp_slowtmr+0x310>)
    5d76:	4798      	blx	r3
    5d78:	4626      	mov	r6, r4
			pcb  = pcb->next;
    5d7a:	4644      	mov	r4, r8
    5d7c:	e6a9      	b.n	5ad2 <tcp_slowtmr+0x2e>
			pcb     = pcb->next;
    5d7e:	464c      	mov	r4, r9
    5d80:	e6a7      	b.n	5ad2 <tcp_slowtmr+0x2e>
    5d82:	bf00      	nop
    5d84:	200092e4 	.word	0x200092e4
    5d88:	20007f98 	.word	0x20007f98
    5d8c:	200092dc 	.word	0x200092dc
    5d90:	200092e0 	.word	0x200092e0
    5d94:	0000bc90 	.word	0x0000bc90
    5d98:	00007f19 	.word	0x00007f19
    5d9c:	00007dc1 	.word	0x00007dc1
    5da0:	000124f8 	.word	0x000124f8
    5da4:	00007ead 	.word	0x00007ead
    5da8:	00005a0d 	.word	0x00005a0d
    5dac:	00005a5d 	.word	0x00005a5d
    5db0:	00005201 	.word	0x00005201
    5db4:	00007a49 	.word	0x00007a49
    5db8:	10624dd3 	.word	0x10624dd3
    5dbc:	00007d1d 	.word	0x00007d1d
    5dc0:	4626      	mov	r6, r4
			pcb  = pcb->next;
    5dc2:	4644      	mov	r4, r8
    5dc4:	e685      	b.n	5ad2 <tcp_slowtmr+0x2e>
	pcb  = tcp_tw_pcbs;
    5dc6:	4b14      	ldr	r3, [pc, #80]	; (5e18 <tcp_slowtmr+0x374>)
    5dc8:	681c      	ldr	r4, [r3, #0]
	while (pcb != NULL) {
    5dca:	b30c      	cbz	r4, 5e10 <tcp_slowtmr+0x36c>
    5dcc:	2500      	movs	r5, #0
		if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    5dce:	4e13      	ldr	r6, [pc, #76]	; (5e1c <tcp_slowtmr+0x378>)
			tcp_pcb_purge(pcb);
    5dd0:	f8df 8050 	ldr.w	r8, [pc, #80]	; 5e24 <tcp_slowtmr+0x380>
			memp_free(MEMP_TCP_PCB, pcb2);
    5dd4:	4f12      	ldr	r7, [pc, #72]	; (5e20 <tcp_slowtmr+0x37c>)
    5dd6:	e006      	b.n	5de6 <tcp_slowtmr+0x342>
				tcp_tw_pcbs = pcb->next;
    5dd8:	68e2      	ldr	r2, [r4, #12]
    5dda:	4b0f      	ldr	r3, [pc, #60]	; (5e18 <tcp_slowtmr+0x374>)
    5ddc:	601a      	str	r2, [r3, #0]
    5dde:	e00d      	b.n	5dfc <tcp_slowtmr+0x358>
			pcb  = pcb->next;
    5de0:	4625      	mov	r5, r4
    5de2:	68e4      	ldr	r4, [r4, #12]
	while (pcb != NULL) {
    5de4:	b1a4      	cbz	r4, 5e10 <tcp_slowtmr+0x36c>
		if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    5de6:	6a62      	ldr	r2, [r4, #36]	; 0x24
    5de8:	6833      	ldr	r3, [r6, #0]
    5dea:	1a9b      	subs	r3, r3, r2
		if (pcb_remove) {
    5dec:	2bf0      	cmp	r3, #240	; 0xf0
    5dee:	d9f7      	bls.n	5de0 <tcp_slowtmr+0x33c>
			tcp_pcb_purge(pcb);
    5df0:	4620      	mov	r0, r4
    5df2:	47c0      	blx	r8
			if (prev != NULL) {
    5df4:	2d00      	cmp	r5, #0
    5df6:	d0ef      	beq.n	5dd8 <tcp_slowtmr+0x334>
				prev->next = pcb->next;
    5df8:	68e3      	ldr	r3, [r4, #12]
    5dfa:	60eb      	str	r3, [r5, #12]
			pcb  = pcb->next;
    5dfc:	f8d4 900c 	ldr.w	r9, [r4, #12]
			memp_free(MEMP_TCP_PCB, pcb2);
    5e00:	4621      	mov	r1, r4
    5e02:	2002      	movs	r0, #2
    5e04:	47b8      	blx	r7
			pcb  = pcb->next;
    5e06:	464c      	mov	r4, r9
    5e08:	e7ec      	b.n	5de4 <tcp_slowtmr+0x340>
		pcb_reset  = 0;
    5e0a:	f04f 0900 	mov.w	r9, #0
    5e0e:	e73f      	b.n	5c90 <tcp_slowtmr+0x1ec>
}
    5e10:	b003      	add	sp, #12
    5e12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5e16:	bf00      	nop
    5e18:	200092f4 	.word	0x200092f4
    5e1c:	200092e4 	.word	0x200092e4
    5e20:	00005201 	.word	0x00005201
    5e24:	00005a5d 	.word	0x00005a5d

00005e28 <tcp_pcb_remove>:
 *
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
    5e28:	b510      	push	{r4, lr}
    5e2a:	460c      	mov	r4, r1
	TCP_RMV(pcblist, pcb);
    5e2c:	6802      	ldr	r2, [r0, #0]
    5e2e:	428a      	cmp	r2, r1
    5e30:	d00b      	beq.n	5e4a <tcp_pcb_remove+0x22>
    5e32:	4b18      	ldr	r3, [pc, #96]	; (5e94 <tcp_pcb_remove+0x6c>)
    5e34:	601a      	str	r2, [r3, #0]
    5e36:	b17a      	cbz	r2, 5e58 <tcp_pcb_remove+0x30>
    5e38:	68d3      	ldr	r3, [r2, #12]
    5e3a:	4299      	cmp	r1, r3
    5e3c:	d01d      	beq.n	5e7a <tcp_pcb_remove+0x52>
    5e3e:	b1f3      	cbz	r3, 5e7e <tcp_pcb_remove+0x56>
    5e40:	68da      	ldr	r2, [r3, #12]
    5e42:	4294      	cmp	r4, r2
    5e44:	d004      	beq.n	5e50 <tcp_pcb_remove+0x28>
    5e46:	4613      	mov	r3, r2
    5e48:	e7f9      	b.n	5e3e <tcp_pcb_remove+0x16>
    5e4a:	68d3      	ldr	r3, [r2, #12]
    5e4c:	6003      	str	r3, [r0, #0]
    5e4e:	e003      	b.n	5e58 <tcp_pcb_remove+0x30>
    5e50:	4a10      	ldr	r2, [pc, #64]	; (5e94 <tcp_pcb_remove+0x6c>)
    5e52:	6013      	str	r3, [r2, #0]
    5e54:	68e2      	ldr	r2, [r4, #12]
    5e56:	60da      	str	r2, [r3, #12]
    5e58:	2300      	movs	r3, #0
    5e5a:	60e3      	str	r3, [r4, #12]

	tcp_pcb_purge(pcb);
    5e5c:	4620      	mov	r0, r4
    5e5e:	4b0e      	ldr	r3, [pc, #56]	; (5e98 <tcp_pcb_remove+0x70>)
    5e60:	4798      	blx	r3

	/* if there is an outstanding delayed ACKs, send it */
	if (pcb->state != TIME_WAIT && pcb->state != LISTEN && pcb->flags & TF_ACK_DELAY) {
    5e62:	7e23      	ldrb	r3, [r4, #24]
    5e64:	2b0a      	cmp	r3, #10
    5e66:	d005      	beq.n	5e74 <tcp_pcb_remove+0x4c>
    5e68:	2b01      	cmp	r3, #1
    5e6a:	d003      	beq.n	5e74 <tcp_pcb_remove+0x4c>
    5e6c:	7fa3      	ldrb	r3, [r4, #30]
    5e6e:	f013 0f01 	tst.w	r3, #1
    5e72:	d108      	bne.n	5e86 <tcp_pcb_remove+0x5e>
#if TCP_QUEUE_OOSEQ
		LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
	}

	pcb->state = CLOSED;
    5e74:	2300      	movs	r3, #0
    5e76:	7623      	strb	r3, [r4, #24]
    5e78:	bd10      	pop	{r4, pc}
	TCP_RMV(pcblist, pcb);
    5e7a:	4613      	mov	r3, r2
    5e7c:	e7ea      	b.n	5e54 <tcp_pcb_remove+0x2c>
    5e7e:	2200      	movs	r2, #0
    5e80:	4b04      	ldr	r3, [pc, #16]	; (5e94 <tcp_pcb_remove+0x6c>)
    5e82:	601a      	str	r2, [r3, #0]
    5e84:	e7e8      	b.n	5e58 <tcp_pcb_remove+0x30>
		pcb->flags |= TF_ACK_NOW;
    5e86:	f043 0302 	orr.w	r3, r3, #2
    5e8a:	77a3      	strb	r3, [r4, #30]
		tcp_output(pcb);
    5e8c:	4620      	mov	r0, r4
    5e8e:	4b03      	ldr	r3, [pc, #12]	; (5e9c <tcp_pcb_remove+0x74>)
    5e90:	4798      	blx	r3
    5e92:	e7ef      	b.n	5e74 <tcp_pcb_remove+0x4c>
    5e94:	200092ec 	.word	0x200092ec
    5e98:	00005a5d 	.word	0x00005a5d
    5e9c:	00007a49 	.word	0x00007a49

00005ea0 <tcp_close_shutdown>:
{
    5ea0:	b530      	push	{r4, r5, lr}
    5ea2:	b083      	sub	sp, #12
    5ea4:	4604      	mov	r4, r0
	if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    5ea6:	b121      	cbz	r1, 5eb2 <tcp_close_shutdown+0x12>
    5ea8:	7e03      	ldrb	r3, [r0, #24]
    5eaa:	2b04      	cmp	r3, #4
    5eac:	d00b      	beq.n	5ec6 <tcp_close_shutdown+0x26>
    5eae:	2b07      	cmp	r3, #7
    5eb0:	d009      	beq.n	5ec6 <tcp_close_shutdown+0x26>
	switch (pcb->state) {
    5eb2:	7e23      	ldrb	r3, [r4, #24]
    5eb4:	2b07      	cmp	r3, #7
    5eb6:	f200 80ae 	bhi.w	6016 <tcp_close_shutdown+0x176>
    5eba:	e8df f003 	tbb	[pc, r3]
    5ebe:	774e      	.short	0x774e
    5ec0:	ac9a8c80 	.word	0xac9a8c80
    5ec4:	a3ac      	.short	0xa3ac
		if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    5ec6:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    5ec8:	b1e3      	cbz	r3, 5f04 <tcp_close_shutdown+0x64>
			tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    5eca:	8ba3      	ldrh	r3, [r4, #28]
    5ecc:	9301      	str	r3, [sp, #4]
    5ece:	8b63      	ldrh	r3, [r4, #26]
    5ed0:	9300      	str	r3, [sp, #0]
    5ed2:	1d23      	adds	r3, r4, #4
    5ed4:	4622      	mov	r2, r4
    5ed6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    5ed8:	6d20      	ldr	r0, [r4, #80]	; 0x50
    5eda:	4d51      	ldr	r5, [pc, #324]	; (6020 <tcp_close_shutdown+0x180>)
    5edc:	47a8      	blx	r5
			tcp_pcb_purge(pcb);
    5ede:	4620      	mov	r0, r4
    5ee0:	4b50      	ldr	r3, [pc, #320]	; (6024 <tcp_close_shutdown+0x184>)
    5ee2:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    5ee4:	4b50      	ldr	r3, [pc, #320]	; (6028 <tcp_close_shutdown+0x188>)
    5ee6:	681a      	ldr	r2, [r3, #0]
    5ee8:	4294      	cmp	r4, r2
    5eea:	d011      	beq.n	5f10 <tcp_close_shutdown+0x70>
    5eec:	4b4f      	ldr	r3, [pc, #316]	; (602c <tcp_close_shutdown+0x18c>)
    5eee:	601a      	str	r2, [r3, #0]
    5ef0:	b1aa      	cbz	r2, 5f1e <tcp_close_shutdown+0x7e>
    5ef2:	68d3      	ldr	r3, [r2, #12]
    5ef4:	429c      	cmp	r4, r3
    5ef6:	d020      	beq.n	5f3a <tcp_close_shutdown+0x9a>
    5ef8:	b30b      	cbz	r3, 5f3e <tcp_close_shutdown+0x9e>
    5efa:	68da      	ldr	r2, [r3, #12]
    5efc:	4294      	cmp	r4, r2
    5efe:	d00a      	beq.n	5f16 <tcp_close_shutdown+0x76>
    5f00:	4613      	mov	r3, r2
    5f02:	e7f9      	b.n	5ef8 <tcp_close_shutdown+0x58>
		if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    5f04:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    5f06:	f241 63d0 	movw	r3, #5840	; 0x16d0
    5f0a:	429a      	cmp	r2, r3
    5f0c:	d1dd      	bne.n	5eca <tcp_close_shutdown+0x2a>
    5f0e:	e7d0      	b.n	5eb2 <tcp_close_shutdown+0x12>
			TCP_RMV_ACTIVE(pcb);
    5f10:	68d2      	ldr	r2, [r2, #12]
    5f12:	601a      	str	r2, [r3, #0]
    5f14:	e003      	b.n	5f1e <tcp_close_shutdown+0x7e>
    5f16:	4a45      	ldr	r2, [pc, #276]	; (602c <tcp_close_shutdown+0x18c>)
    5f18:	6013      	str	r3, [r2, #0]
    5f1a:	68e2      	ldr	r2, [r4, #12]
    5f1c:	60da      	str	r2, [r3, #12]
    5f1e:	2300      	movs	r3, #0
    5f20:	60e3      	str	r3, [r4, #12]
    5f22:	2201      	movs	r2, #1
    5f24:	4b42      	ldr	r3, [pc, #264]	; (6030 <tcp_close_shutdown+0x190>)
    5f26:	701a      	strb	r2, [r3, #0]
			if (pcb->state == ESTABLISHED) {
    5f28:	7e23      	ldrb	r3, [r4, #24]
    5f2a:	2b04      	cmp	r3, #4
    5f2c:	d00b      	beq.n	5f46 <tcp_close_shutdown+0xa6>
				memp_free(MEMP_TCP_PCB, pcb);
    5f2e:	4621      	mov	r1, r4
    5f30:	2002      	movs	r0, #2
    5f32:	4b40      	ldr	r3, [pc, #256]	; (6034 <tcp_close_shutdown+0x194>)
    5f34:	4798      	blx	r3
			return ERR_OK;
    5f36:	2300      	movs	r3, #0
    5f38:	e02f      	b.n	5f9a <tcp_close_shutdown+0xfa>
			TCP_RMV_ACTIVE(pcb);
    5f3a:	4613      	mov	r3, r2
    5f3c:	e7ed      	b.n	5f1a <tcp_close_shutdown+0x7a>
    5f3e:	2200      	movs	r2, #0
    5f40:	4b3a      	ldr	r3, [pc, #232]	; (602c <tcp_close_shutdown+0x18c>)
    5f42:	601a      	str	r2, [r3, #0]
    5f44:	e7eb      	b.n	5f1e <tcp_close_shutdown+0x7e>
				pcb->state = TIME_WAIT;
    5f46:	230a      	movs	r3, #10
    5f48:	7623      	strb	r3, [r4, #24]
				TCP_REG(&tcp_tw_pcbs, pcb);
    5f4a:	4b3b      	ldr	r3, [pc, #236]	; (6038 <tcp_close_shutdown+0x198>)
    5f4c:	681a      	ldr	r2, [r3, #0]
    5f4e:	60e2      	str	r2, [r4, #12]
    5f50:	601c      	str	r4, [r3, #0]
    5f52:	4b3a      	ldr	r3, [pc, #232]	; (603c <tcp_close_shutdown+0x19c>)
    5f54:	4798      	blx	r3
			return ERR_OK;
    5f56:	2300      	movs	r3, #0
    5f58:	e01f      	b.n	5f9a <tcp_close_shutdown+0xfa>
		if (pcb->local_port != 0) {
    5f5a:	8b63      	ldrh	r3, [r4, #26]
    5f5c:	b1c3      	cbz	r3, 5f90 <tcp_close_shutdown+0xf0>
			TCP_RMV(&tcp_bound_pcbs, pcb);
    5f5e:	4b38      	ldr	r3, [pc, #224]	; (6040 <tcp_close_shutdown+0x1a0>)
    5f60:	681a      	ldr	r2, [r3, #0]
    5f62:	4294      	cmp	r4, r2
    5f64:	d00b      	beq.n	5f7e <tcp_close_shutdown+0xde>
    5f66:	4b31      	ldr	r3, [pc, #196]	; (602c <tcp_close_shutdown+0x18c>)
    5f68:	601a      	str	r2, [r3, #0]
    5f6a:	b17a      	cbz	r2, 5f8c <tcp_close_shutdown+0xec>
    5f6c:	68d3      	ldr	r3, [r2, #12]
    5f6e:	429c      	cmp	r4, r3
    5f70:	d016      	beq.n	5fa0 <tcp_close_shutdown+0x100>
    5f72:	b1bb      	cbz	r3, 5fa4 <tcp_close_shutdown+0x104>
    5f74:	68da      	ldr	r2, [r3, #12]
    5f76:	4294      	cmp	r4, r2
    5f78:	d004      	beq.n	5f84 <tcp_close_shutdown+0xe4>
    5f7a:	4613      	mov	r3, r2
    5f7c:	e7f9      	b.n	5f72 <tcp_close_shutdown+0xd2>
    5f7e:	68d2      	ldr	r2, [r2, #12]
    5f80:	601a      	str	r2, [r3, #0]
    5f82:	e003      	b.n	5f8c <tcp_close_shutdown+0xec>
    5f84:	4a29      	ldr	r2, [pc, #164]	; (602c <tcp_close_shutdown+0x18c>)
    5f86:	6013      	str	r3, [r2, #0]
    5f88:	68e2      	ldr	r2, [r4, #12]
    5f8a:	60da      	str	r2, [r3, #12]
    5f8c:	2300      	movs	r3, #0
    5f8e:	60e3      	str	r3, [r4, #12]
		memp_free(MEMP_TCP_PCB, pcb);
    5f90:	4621      	mov	r1, r4
    5f92:	2002      	movs	r0, #2
    5f94:	4b27      	ldr	r3, [pc, #156]	; (6034 <tcp_close_shutdown+0x194>)
    5f96:	4798      	blx	r3
		err = ERR_OK;
    5f98:	2300      	movs	r3, #0
}
    5f9a:	4618      	mov	r0, r3
    5f9c:	b003      	add	sp, #12
    5f9e:	bd30      	pop	{r4, r5, pc}
			TCP_RMV(&tcp_bound_pcbs, pcb);
    5fa0:	4613      	mov	r3, r2
    5fa2:	e7f1      	b.n	5f88 <tcp_close_shutdown+0xe8>
    5fa4:	2200      	movs	r2, #0
    5fa6:	4b21      	ldr	r3, [pc, #132]	; (602c <tcp_close_shutdown+0x18c>)
    5fa8:	601a      	str	r2, [r3, #0]
    5faa:	e7ef      	b.n	5f8c <tcp_close_shutdown+0xec>
		tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
    5fac:	4621      	mov	r1, r4
    5fae:	4825      	ldr	r0, [pc, #148]	; (6044 <tcp_close_shutdown+0x1a4>)
    5fb0:	4b25      	ldr	r3, [pc, #148]	; (6048 <tcp_close_shutdown+0x1a8>)
    5fb2:	4798      	blx	r3
		memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    5fb4:	4621      	mov	r1, r4
    5fb6:	2003      	movs	r0, #3
    5fb8:	4b1e      	ldr	r3, [pc, #120]	; (6034 <tcp_close_shutdown+0x194>)
    5fba:	4798      	blx	r3
		break;
    5fbc:	e7ec      	b.n	5f98 <tcp_close_shutdown+0xf8>
		TCP_PCB_REMOVE_ACTIVE(pcb);
    5fbe:	4621      	mov	r1, r4
    5fc0:	4819      	ldr	r0, [pc, #100]	; (6028 <tcp_close_shutdown+0x188>)
    5fc2:	4b21      	ldr	r3, [pc, #132]	; (6048 <tcp_close_shutdown+0x1a8>)
    5fc4:	4798      	blx	r3
    5fc6:	2201      	movs	r2, #1
    5fc8:	4b19      	ldr	r3, [pc, #100]	; (6030 <tcp_close_shutdown+0x190>)
    5fca:	701a      	strb	r2, [r3, #0]
		memp_free(MEMP_TCP_PCB, pcb);
    5fcc:	4621      	mov	r1, r4
    5fce:	2002      	movs	r0, #2
    5fd0:	4b18      	ldr	r3, [pc, #96]	; (6034 <tcp_close_shutdown+0x194>)
    5fd2:	4798      	blx	r3
		break;
    5fd4:	e7e0      	b.n	5f98 <tcp_close_shutdown+0xf8>
		err = tcp_send_fin(pcb);
    5fd6:	4620      	mov	r0, r4
    5fd8:	4b1c      	ldr	r3, [pc, #112]	; (604c <tcp_close_shutdown+0x1ac>)
    5fda:	4798      	blx	r3
		if (err == ERR_OK) {
    5fdc:	4603      	mov	r3, r0
    5fde:	2800      	cmp	r0, #0
    5fe0:	d1db      	bne.n	5f9a <tcp_close_shutdown+0xfa>
			pcb->state = FIN_WAIT_1;
    5fe2:	2305      	movs	r3, #5
    5fe4:	7623      	strb	r3, [r4, #24]
	if (pcb != NULL && err == ERR_OK) {
    5fe6:	b1c4      	cbz	r4, 601a <tcp_close_shutdown+0x17a>
		tcp_output(pcb);
    5fe8:	4620      	mov	r0, r4
    5fea:	4b19      	ldr	r3, [pc, #100]	; (6050 <tcp_close_shutdown+0x1b0>)
    5fec:	4798      	blx	r3
	return err;
    5fee:	2300      	movs	r3, #0
    5ff0:	e7d3      	b.n	5f9a <tcp_close_shutdown+0xfa>
		err = tcp_send_fin(pcb);
    5ff2:	4620      	mov	r0, r4
    5ff4:	4b15      	ldr	r3, [pc, #84]	; (604c <tcp_close_shutdown+0x1ac>)
    5ff6:	4798      	blx	r3
		if (err == ERR_OK) {
    5ff8:	4603      	mov	r3, r0
    5ffa:	2800      	cmp	r0, #0
    5ffc:	d1cd      	bne.n	5f9a <tcp_close_shutdown+0xfa>
			pcb->state = FIN_WAIT_1;
    5ffe:	2305      	movs	r3, #5
    6000:	7623      	strb	r3, [r4, #24]
    6002:	e7f0      	b.n	5fe6 <tcp_close_shutdown+0x146>
		err = tcp_send_fin(pcb);
    6004:	4620      	mov	r0, r4
    6006:	4b11      	ldr	r3, [pc, #68]	; (604c <tcp_close_shutdown+0x1ac>)
    6008:	4798      	blx	r3
		if (err == ERR_OK) {
    600a:	4603      	mov	r3, r0
    600c:	2800      	cmp	r0, #0
    600e:	d1c4      	bne.n	5f9a <tcp_close_shutdown+0xfa>
			pcb->state = LAST_ACK;
    6010:	2309      	movs	r3, #9
    6012:	7623      	strb	r3, [r4, #24]
    6014:	e7e7      	b.n	5fe6 <tcp_close_shutdown+0x146>
		err = ERR_OK;
    6016:	2300      	movs	r3, #0
    6018:	e7bf      	b.n	5f9a <tcp_close_shutdown+0xfa>
	if (pcb != NULL && err == ERR_OK) {
    601a:	2300      	movs	r3, #0
    601c:	e7bd      	b.n	5f9a <tcp_close_shutdown+0xfa>
    601e:	bf00      	nop
    6020:	00007d1d 	.word	0x00007d1d
    6024:	00005a5d 	.word	0x00005a5d
    6028:	200092e0 	.word	0x200092e0
    602c:	200092ec 	.word	0x200092ec
    6030:	200092dc 	.word	0x200092dc
    6034:	00005201 	.word	0x00005201
    6038:	200092f4 	.word	0x200092f4
    603c:	00008061 	.word	0x00008061
    6040:	200092f0 	.word	0x200092f0
    6044:	200092e8 	.word	0x200092e8
    6048:	00005e29 	.word	0x00005e29
    604c:	00007981 	.word	0x00007981
    6050:	00007a49 	.word	0x00007a49

00006054 <tcp_close>:
{
    6054:	b508      	push	{r3, lr}
	if (pcb->state != LISTEN) {
    6056:	7e03      	ldrb	r3, [r0, #24]
    6058:	2b01      	cmp	r3, #1
    605a:	d003      	beq.n	6064 <tcp_close+0x10>
		pcb->flags |= TF_RXCLOSED;
    605c:	7f83      	ldrb	r3, [r0, #30]
    605e:	f043 0310 	orr.w	r3, r3, #16
    6062:	7783      	strb	r3, [r0, #30]
	return tcp_close_shutdown(pcb, 1);
    6064:	2101      	movs	r1, #1
    6066:	4b01      	ldr	r3, [pc, #4]	; (606c <tcp_close+0x18>)
    6068:	4798      	blx	r3
}
    606a:	bd08      	pop	{r3, pc}
    606c:	00005ea1 	.word	0x00005ea1

00006070 <tcp_recv_null>:
{
    6070:	b510      	push	{r4, lr}
    6072:	4608      	mov	r0, r1
	if (p != NULL) {
    6074:	b142      	cbz	r2, 6088 <tcp_recv_null+0x18>
    6076:	4614      	mov	r4, r2
		tcp_recved(pcb, p->tot_len);
    6078:	8911      	ldrh	r1, [r2, #8]
    607a:	4b06      	ldr	r3, [pc, #24]	; (6094 <tcp_recv_null+0x24>)
    607c:	4798      	blx	r3
		pbuf_free(p);
    607e:	4620      	mov	r0, r4
    6080:	4b05      	ldr	r3, [pc, #20]	; (6098 <tcp_recv_null+0x28>)
    6082:	4798      	blx	r3
	return ERR_OK;
    6084:	2000      	movs	r0, #0
    6086:	bd10      	pop	{r4, pc}
	} else if (err == ERR_OK) {
    6088:	b10b      	cbz	r3, 608e <tcp_recv_null+0x1e>
	return ERR_OK;
    608a:	2000      	movs	r0, #0
}
    608c:	bd10      	pop	{r4, pc}
		return tcp_close(pcb);
    608e:	4b03      	ldr	r3, [pc, #12]	; (609c <tcp_recv_null+0x2c>)
    6090:	4798      	blx	r3
    6092:	bd10      	pop	{r4, pc}
    6094:	000059a9 	.word	0x000059a9
    6098:	000054c9 	.word	0x000054c9
    609c:	00006055 	.word	0x00006055

000060a0 <tcp_process_refused_data>:
{
    60a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    60a2:	4604      	mov	r4, r0
	u8_t  refused_flags = pcb->refused_data->flags;
    60a4:	6f86      	ldr	r6, [r0, #120]	; 0x78
    60a6:	7b77      	ldrb	r7, [r6, #13]
	pcb->refused_data         = NULL;
    60a8:	2300      	movs	r3, #0
    60aa:	6783      	str	r3, [r0, #120]	; 0x78
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    60ac:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
    60b0:	b1e5      	cbz	r5, 60ec <tcp_process_refused_data+0x4c>
    60b2:	4632      	mov	r2, r6
    60b4:	4601      	mov	r1, r0
    60b6:	6900      	ldr	r0, [r0, #16]
    60b8:	47a8      	blx	r5
    60ba:	4605      	mov	r5, r0
	if (err == ERR_OK) {
    60bc:	b9f5      	cbnz	r5, 60fc <tcp_process_refused_data+0x5c>
		if (refused_flags & PBUF_FLAG_TCP_FIN) {
    60be:	f017 0f20 	tst.w	r7, #32
    60c2:	d020      	beq.n	6106 <tcp_process_refused_data+0x66>
			if (pcb->rcv_wnd != TCP_WND) {
    60c4:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    60c6:	f241 62d0 	movw	r2, #5840	; 0x16d0
    60ca:	4293      	cmp	r3, r2
				pcb->rcv_wnd++;
    60cc:	bf1c      	itt	ne
    60ce:	3301      	addne	r3, #1
    60d0:	85a3      	strhne	r3, [r4, #44]	; 0x2c
			TCP_EVENT_CLOSED(pcb, err);
    60d2:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
    60d6:	b1b6      	cbz	r6, 6106 <tcp_process_refused_data+0x66>
    60d8:	2300      	movs	r3, #0
    60da:	461a      	mov	r2, r3
    60dc:	4621      	mov	r1, r4
    60de:	6920      	ldr	r0, [r4, #16]
    60e0:	47b0      	blx	r6
				return ERR_ABRT;
    60e2:	f110 0f0a 	cmn.w	r0, #10
    60e6:	bf08      	it	eq
    60e8:	4605      	moveq	r5, r0
    60ea:	e00c      	b.n	6106 <tcp_process_refused_data+0x66>
	TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    60ec:	2300      	movs	r3, #0
    60ee:	4632      	mov	r2, r6
    60f0:	4601      	mov	r1, r0
    60f2:	4618      	mov	r0, r3
    60f4:	4d05      	ldr	r5, [pc, #20]	; (610c <tcp_process_refused_data+0x6c>)
    60f6:	47a8      	blx	r5
    60f8:	4605      	mov	r5, r0
    60fa:	e7df      	b.n	60bc <tcp_process_refused_data+0x1c>
	} else if (err == ERR_ABRT) {
    60fc:	f115 0f0a 	cmn.w	r5, #10
		pcb->refused_data = refused_data;
    6100:	bf1c      	itt	ne
    6102:	67a6      	strne	r6, [r4, #120]	; 0x78
	return ERR_OK;
    6104:	2500      	movne	r5, #0
}
    6106:	4628      	mov	r0, r5
    6108:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    610a:	bf00      	nop
    610c:	00006071 	.word	0x00006071

00006110 <tcp_fasttmr>:
{
    6110:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	++tcp_timer_ctr;
    6114:	4a18      	ldr	r2, [pc, #96]	; (6178 <tcp_fasttmr+0x68>)
    6116:	7813      	ldrb	r3, [r2, #0]
    6118:	3301      	adds	r3, #1
    611a:	7013      	strb	r3, [r2, #0]
	pcb = tcp_active_pcbs;
    611c:	4f17      	ldr	r7, [pc, #92]	; (617c <tcp_fasttmr+0x6c>)
		if (pcb->last_timer != tcp_timer_ctr) {
    611e:	4615      	mov	r5, r2
				tcp_output(pcb);
    6120:	f8df 8064 	ldr.w	r8, [pc, #100]	; 6188 <tcp_fasttmr+0x78>
				tcp_active_pcbs_changed = 0;
    6124:	4e16      	ldr	r6, [pc, #88]	; (6180 <tcp_fasttmr+0x70>)
	pcb = tcp_active_pcbs;
    6126:	683c      	ldr	r4, [r7, #0]
	while (pcb != NULL) {
    6128:	b31c      	cbz	r4, 6172 <tcp_fasttmr+0x62>
		if (pcb->last_timer != tcp_timer_ctr) {
    612a:	782b      	ldrb	r3, [r5, #0]
    612c:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
    6130:	429a      	cmp	r2, r3
    6132:	d100      	bne.n	6136 <tcp_fasttmr+0x26>
    6134:	e7fe      	b.n	6134 <tcp_fasttmr+0x24>
			pcb->last_timer = tcp_timer_ctr;
    6136:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
			if (pcb->flags & TF_ACK_DELAY) {
    613a:	7fa3      	ldrb	r3, [r4, #30]
    613c:	f013 0f01 	tst.w	r3, #1
    6140:	d10d      	bne.n	615e <tcp_fasttmr+0x4e>
			next = pcb->next;
    6142:	f8d4 900c 	ldr.w	r9, [r4, #12]
			if (pcb->refused_data != NULL) {
    6146:	6fa3      	ldr	r3, [r4, #120]	; 0x78
    6148:	b13b      	cbz	r3, 615a <tcp_fasttmr+0x4a>
				tcp_active_pcbs_changed = 0;
    614a:	2300      	movs	r3, #0
    614c:	7033      	strb	r3, [r6, #0]
				tcp_process_refused_data(pcb);
    614e:	4620      	mov	r0, r4
    6150:	4b0c      	ldr	r3, [pc, #48]	; (6184 <tcp_fasttmr+0x74>)
    6152:	4798      	blx	r3
				if (tcp_active_pcbs_changed) {
    6154:	7833      	ldrb	r3, [r6, #0]
    6156:	2b00      	cmp	r3, #0
    6158:	d1e5      	bne.n	6126 <tcp_fasttmr+0x16>
{
    615a:	464c      	mov	r4, r9
    615c:	e7e4      	b.n	6128 <tcp_fasttmr+0x18>
				tcp_ack_now(pcb);
    615e:	f043 0302 	orr.w	r3, r3, #2
    6162:	77a3      	strb	r3, [r4, #30]
				tcp_output(pcb);
    6164:	4620      	mov	r0, r4
    6166:	47c0      	blx	r8
				pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    6168:	7fa3      	ldrb	r3, [r4, #30]
    616a:	f023 0303 	bic.w	r3, r3, #3
    616e:	77a3      	strb	r3, [r4, #30]
    6170:	e7e7      	b.n	6142 <tcp_fasttmr+0x32>
    6172:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6176:	bf00      	nop
    6178:	20007f98 	.word	0x20007f98
    617c:	200092e0 	.word	0x200092e0
    6180:	200092dc 	.word	0x200092dc
    6184:	000060a1 	.word	0x000060a1
    6188:	00007a49 	.word	0x00007a49

0000618c <tcp_tmr>:
{
    618c:	b508      	push	{r3, lr}
	tcp_fasttmr();
    618e:	4b07      	ldr	r3, [pc, #28]	; (61ac <tcp_tmr+0x20>)
    6190:	4798      	blx	r3
	if (++tcp_timer & 1) {
    6192:	4a07      	ldr	r2, [pc, #28]	; (61b0 <tcp_tmr+0x24>)
    6194:	7853      	ldrb	r3, [r2, #1]
    6196:	3301      	adds	r3, #1
    6198:	b2db      	uxtb	r3, r3
    619a:	7053      	strb	r3, [r2, #1]
    619c:	f013 0f01 	tst.w	r3, #1
    61a0:	d100      	bne.n	61a4 <tcp_tmr+0x18>
    61a2:	bd08      	pop	{r3, pc}
		tcp_slowtmr();
    61a4:	4b03      	ldr	r3, [pc, #12]	; (61b4 <tcp_tmr+0x28>)
    61a6:	4798      	blx	r3
}
    61a8:	e7fb      	b.n	61a2 <tcp_tmr+0x16>
    61aa:	bf00      	nop
    61ac:	00006111 	.word	0x00006111
    61b0:	20007f98 	.word	0x20007f98
    61b4:	00005aa5 	.word	0x00005aa5

000061b8 <tcp_abandon>:
{
    61b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    61bc:	b083      	sub	sp, #12
    61be:	4604      	mov	r4, r0
	if (pcb->state == TIME_WAIT) {
    61c0:	7e03      	ldrb	r3, [r0, #24]
    61c2:	2b0a      	cmp	r3, #10
    61c4:	d027      	beq.n	6216 <tcp_abandon+0x5e>
    61c6:	460e      	mov	r6, r1
		seqno = pcb->snd_nxt;
    61c8:	f8d0 8050 	ldr.w	r8, [r0, #80]	; 0x50
		ackno = pcb->rcv_nxt;
    61cc:	f8d0 9028 	ldr.w	r9, [r0, #40]	; 0x28
		errf = pcb->errf;
    61d0:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
		errf_arg = pcb->callback_arg;
    61d4:	6907      	ldr	r7, [r0, #16]
		TCP_PCB_REMOVE_ACTIVE(pcb);
    61d6:	4601      	mov	r1, r0
    61d8:	4819      	ldr	r0, [pc, #100]	; (6240 <tcp_abandon+0x88>)
    61da:	4b1a      	ldr	r3, [pc, #104]	; (6244 <tcp_abandon+0x8c>)
    61dc:	4798      	blx	r3
    61de:	2201      	movs	r2, #1
    61e0:	4b19      	ldr	r3, [pc, #100]	; (6248 <tcp_abandon+0x90>)
    61e2:	701a      	strb	r2, [r3, #0]
		if (pcb->unacked != NULL) {
    61e4:	6f20      	ldr	r0, [r4, #112]	; 0x70
    61e6:	b108      	cbz	r0, 61ec <tcp_abandon+0x34>
			tcp_segs_free(pcb->unacked);
    61e8:	4b18      	ldr	r3, [pc, #96]	; (624c <tcp_abandon+0x94>)
    61ea:	4798      	blx	r3
		if (pcb->unsent != NULL) {
    61ec:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    61ee:	b108      	cbz	r0, 61f4 <tcp_abandon+0x3c>
			tcp_segs_free(pcb->unsent);
    61f0:	4b16      	ldr	r3, [pc, #88]	; (624c <tcp_abandon+0x94>)
    61f2:	4798      	blx	r3
		if (pcb->ooseq != NULL) {
    61f4:	6f60      	ldr	r0, [r4, #116]	; 0x74
    61f6:	b108      	cbz	r0, 61fc <tcp_abandon+0x44>
			tcp_segs_free(pcb->ooseq);
    61f8:	4b14      	ldr	r3, [pc, #80]	; (624c <tcp_abandon+0x94>)
    61fa:	4798      	blx	r3
		if (reset) {
    61fc:	b9a6      	cbnz	r6, 6228 <tcp_abandon+0x70>
		memp_free(MEMP_TCP_PCB, pcb);
    61fe:	4621      	mov	r1, r4
    6200:	2002      	movs	r0, #2
    6202:	4b13      	ldr	r3, [pc, #76]	; (6250 <tcp_abandon+0x98>)
    6204:	4798      	blx	r3
		TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    6206:	b11d      	cbz	r5, 6210 <tcp_abandon+0x58>
    6208:	f06f 0109 	mvn.w	r1, #9
    620c:	4638      	mov	r0, r7
    620e:	47a8      	blx	r5
}
    6210:	b003      	add	sp, #12
    6212:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    6216:	4601      	mov	r1, r0
    6218:	480e      	ldr	r0, [pc, #56]	; (6254 <tcp_abandon+0x9c>)
    621a:	4b0a      	ldr	r3, [pc, #40]	; (6244 <tcp_abandon+0x8c>)
    621c:	4798      	blx	r3
		memp_free(MEMP_TCP_PCB, pcb);
    621e:	4621      	mov	r1, r4
    6220:	2002      	movs	r0, #2
    6222:	4b0b      	ldr	r3, [pc, #44]	; (6250 <tcp_abandon+0x98>)
    6224:	4798      	blx	r3
    6226:	e7f3      	b.n	6210 <tcp_abandon+0x58>
			tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    6228:	8ba3      	ldrh	r3, [r4, #28]
    622a:	9301      	str	r3, [sp, #4]
    622c:	8b63      	ldrh	r3, [r4, #26]
    622e:	9300      	str	r3, [sp, #0]
    6230:	1d23      	adds	r3, r4, #4
    6232:	4622      	mov	r2, r4
    6234:	4649      	mov	r1, r9
    6236:	4640      	mov	r0, r8
    6238:	4e07      	ldr	r6, [pc, #28]	; (6258 <tcp_abandon+0xa0>)
    623a:	47b0      	blx	r6
    623c:	e7df      	b.n	61fe <tcp_abandon+0x46>
    623e:	bf00      	nop
    6240:	200092e0 	.word	0x200092e0
    6244:	00005e29 	.word	0x00005e29
    6248:	200092dc 	.word	0x200092dc
    624c:	00005a0d 	.word	0x00005a0d
    6250:	00005201 	.word	0x00005201
    6254:	200092f4 	.word	0x200092f4
    6258:	00007d1d 	.word	0x00007d1d

0000625c <tcp_abort>:
{
    625c:	b508      	push	{r3, lr}
	tcp_abandon(pcb, 1);
    625e:	2101      	movs	r1, #1
    6260:	4b01      	ldr	r3, [pc, #4]	; (6268 <tcp_abort+0xc>)
    6262:	4798      	blx	r3
    6264:	bd08      	pop	{r3, pc}
    6266:	bf00      	nop
    6268:	000061b9 	.word	0x000061b9

0000626c <tcp_next_iss>:
 */
u32_t tcp_next_iss(void)
{
	static u32_t iss = 6510;

	iss += tcp_ticks; /* XXX */
    626c:	4b03      	ldr	r3, [pc, #12]	; (627c <tcp_next_iss+0x10>)
    626e:	6858      	ldr	r0, [r3, #4]
    6270:	4a03      	ldr	r2, [pc, #12]	; (6280 <tcp_next_iss+0x14>)
    6272:	6812      	ldr	r2, [r2, #0]
    6274:	4410      	add	r0, r2
    6276:	6058      	str	r0, [r3, #4]
	return iss;
}
    6278:	4770      	bx	lr
    627a:	bf00      	nop
    627c:	20000004 	.word	0x20000004
    6280:	200092e4 	.word	0x200092e4

00006284 <tcp_alloc>:
{
    6284:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6286:	4605      	mov	r5, r0
	pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6288:	2002      	movs	r0, #2
    628a:	4b3e      	ldr	r3, [pc, #248]	; (6384 <tcp_alloc+0x100>)
    628c:	4798      	blx	r3
	if (pcb == NULL) {
    628e:	4604      	mov	r4, r0
    6290:	2800      	cmp	r0, #0
    6292:	d03b      	beq.n	630c <tcp_alloc+0x88>
		memset(pcb, 0, sizeof(struct tcp_pcb));
    6294:	2298      	movs	r2, #152	; 0x98
    6296:	2100      	movs	r1, #0
    6298:	4620      	mov	r0, r4
    629a:	4b3b      	ldr	r3, [pc, #236]	; (6388 <tcp_alloc+0x104>)
    629c:	4798      	blx	r3
		pcb->prio         = prio;
    629e:	7665      	strb	r5, [r4, #25]
		pcb->snd_buf      = TCP_SND_BUF;
    62a0:	f640 3368 	movw	r3, #2920	; 0xb68
    62a4:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
		pcb->snd_queuelen = 0;
    62a8:	2500      	movs	r5, #0
    62aa:	f8a4 5068 	strh.w	r5, [r4, #104]	; 0x68
		pcb->rcv_wnd      = TCP_WND;
    62ae:	f241 63d0 	movw	r3, #5840	; 0x16d0
    62b2:	85a3      	strh	r3, [r4, #44]	; 0x2c
		pcb->rcv_ann_wnd  = TCP_WND;
    62b4:	85e3      	strh	r3, [r4, #46]	; 0x2e
		pcb->tos          = 0;
    62b6:	7265      	strb	r5, [r4, #9]
		pcb->ttl          = TCP_TTL;
    62b8:	23ff      	movs	r3, #255	; 0xff
    62ba:	72a3      	strb	r3, [r4, #10]
		pcb->mss        = (TCP_MSS > 536) ? 536 : TCP_MSS;
    62bc:	f44f 7306 	mov.w	r3, #536	; 0x218
    62c0:	86e3      	strh	r3, [r4, #54]	; 0x36
		pcb->rto        = 3000 / TCP_SLOW_INTERVAL;
    62c2:	2306      	movs	r3, #6
    62c4:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
		pcb->sa         = 0;
    62c8:	f8a4 5040 	strh.w	r5, [r4, #64]	; 0x40
		pcb->sv         = 3000 / TCP_SLOW_INTERVAL;
    62cc:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
		pcb->rtime      = -1;
    62d0:	f64f 73ff 	movw	r3, #65535	; 0xffff
    62d4:	86a3      	strh	r3, [r4, #52]	; 0x34
		pcb->cwnd       = 1;
    62d6:	2301      	movs	r3, #1
    62d8:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		iss             = tcp_next_iss();
    62dc:	4b2b      	ldr	r3, [pc, #172]	; (638c <tcp_alloc+0x108>)
    62de:	4798      	blx	r3
		pcb->snd_wl2    = iss;
    62e0:	65a0      	str	r0, [r4, #88]	; 0x58
		pcb->snd_nxt    = iss;
    62e2:	6520      	str	r0, [r4, #80]	; 0x50
		pcb->lastack    = iss;
    62e4:	64a0      	str	r0, [r4, #72]	; 0x48
		pcb->snd_lbb    = iss;
    62e6:	65e0      	str	r0, [r4, #92]	; 0x5c
		pcb->tmr        = tcp_ticks;
    62e8:	4b29      	ldr	r3, [pc, #164]	; (6390 <tcp_alloc+0x10c>)
    62ea:	681b      	ldr	r3, [r3, #0]
    62ec:	6263      	str	r3, [r4, #36]	; 0x24
		pcb->last_timer = tcp_timer_ctr;
    62ee:	4b29      	ldr	r3, [pc, #164]	; (6394 <tcp_alloc+0x110>)
    62f0:	781b      	ldrb	r3, [r3, #0]
    62f2:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
		pcb->polltmr = 0;
    62f6:	77e5      	strb	r5, [r4, #31]
		pcb->recv = tcp_recv_null;
    62f8:	4b27      	ldr	r3, [pc, #156]	; (6398 <tcp_alloc+0x114>)
    62fa:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
		pcb->keep_idle = TCP_KEEPIDLE_DEFAULT;
    62fe:	4b27      	ldr	r3, [pc, #156]	; (639c <tcp_alloc+0x118>)
    6300:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
		pcb->keep_cnt_sent = 0;
    6304:	f884 5096 	strb.w	r5, [r4, #150]	; 0x96
}
    6308:	4620      	mov	r0, r4
    630a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    630c:	4b24      	ldr	r3, [pc, #144]	; (63a0 <tcp_alloc+0x11c>)
    630e:	681b      	ldr	r3, [r3, #0]
    6310:	b17b      	cbz	r3, 6332 <tcp_alloc+0xae>
		if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6312:	4a1f      	ldr	r2, [pc, #124]	; (6390 <tcp_alloc+0x10c>)
    6314:	6810      	ldr	r0, [r2, #0]
    6316:	2100      	movs	r1, #0
    6318:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    631a:	1a82      	subs	r2, r0, r2
    631c:	428a      	cmp	r2, r1
			inactivity = tcp_ticks - pcb->tmr;
    631e:	bf24      	itt	cs
    6320:	4611      	movcs	r1, r2
		if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6322:	461c      	movcs	r4, r3
	for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    6324:	68db      	ldr	r3, [r3, #12]
    6326:	2b00      	cmp	r3, #0
    6328:	d1f6      	bne.n	6318 <tcp_alloc+0x94>
	if (inactive != NULL) {
    632a:	b114      	cbz	r4, 6332 <tcp_alloc+0xae>
		tcp_abort(inactive);
    632c:	4620      	mov	r0, r4
    632e:	4b1d      	ldr	r3, [pc, #116]	; (63a4 <tcp_alloc+0x120>)
    6330:	4798      	blx	r3
		pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6332:	2002      	movs	r0, #2
    6334:	4b13      	ldr	r3, [pc, #76]	; (6384 <tcp_alloc+0x100>)
    6336:	4798      	blx	r3
		if (pcb == NULL) {
    6338:	4604      	mov	r4, r0
    633a:	2800      	cmp	r0, #0
    633c:	d1aa      	bne.n	6294 <tcp_alloc+0x10>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    633e:	4b1a      	ldr	r3, [pc, #104]	; (63a8 <tcp_alloc+0x124>)
    6340:	681b      	ldr	r3, [r3, #0]
    6342:	b1bb      	cbz	r3, 6374 <tcp_alloc+0xf0>
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6344:	4a12      	ldr	r2, [pc, #72]	; (6390 <tcp_alloc+0x10c>)
    6346:	6817      	ldr	r7, [r2, #0]
    6348:	2600      	movs	r6, #0
    634a:	207f      	movs	r0, #127	; 0x7f
    634c:	e001      	b.n	6352 <tcp_alloc+0xce>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    634e:	68db      	ldr	r3, [r3, #12]
    6350:	b163      	cbz	r3, 636c <tcp_alloc+0xe8>
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6352:	7e5a      	ldrb	r2, [r3, #25]
    6354:	4295      	cmp	r5, r2
    6356:	d3fa      	bcc.n	634e <tcp_alloc+0xca>
    6358:	4282      	cmp	r2, r0
    635a:	d8f8      	bhi.n	634e <tcp_alloc+0xca>
    635c:	6a59      	ldr	r1, [r3, #36]	; 0x24
    635e:	1a79      	subs	r1, r7, r1
    6360:	42b1      	cmp	r1, r6
    6362:	d3f4      	bcc.n	634e <tcp_alloc+0xca>
			mprio      = pcb->prio;
    6364:	4610      	mov	r0, r2
			inactivity = tcp_ticks - pcb->tmr;
    6366:	460e      	mov	r6, r1
		if (pcb->prio <= prio && pcb->prio <= mprio && (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    6368:	461c      	mov	r4, r3
    636a:	e7f0      	b.n	634e <tcp_alloc+0xca>
	if (inactive != NULL) {
    636c:	b114      	cbz	r4, 6374 <tcp_alloc+0xf0>
		tcp_abort(inactive);
    636e:	4620      	mov	r0, r4
    6370:	4b0c      	ldr	r3, [pc, #48]	; (63a4 <tcp_alloc+0x120>)
    6372:	4798      	blx	r3
			pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    6374:	2002      	movs	r0, #2
    6376:	4b03      	ldr	r3, [pc, #12]	; (6384 <tcp_alloc+0x100>)
    6378:	4798      	blx	r3
	if (pcb != NULL) {
    637a:	4604      	mov	r4, r0
    637c:	2800      	cmp	r0, #0
    637e:	d0c3      	beq.n	6308 <tcp_alloc+0x84>
    6380:	e788      	b.n	6294 <tcp_alloc+0x10>
    6382:	bf00      	nop
    6384:	000051b9 	.word	0x000051b9
    6388:	00009805 	.word	0x00009805
    638c:	0000626d 	.word	0x0000626d
    6390:	200092e4 	.word	0x200092e4
    6394:	20007f98 	.word	0x20007f98
    6398:	00006071 	.word	0x00006071
    639c:	006ddd00 	.word	0x006ddd00
    63a0:	200092f4 	.word	0x200092f4
    63a4:	0000625d 	.word	0x0000625d
    63a8:	200092e0 	.word	0x200092e0

000063ac <tcp_eff_send_mss>:
 * Calcluates the effective send mss that can be used for a specific IP address
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
    63ac:	b510      	push	{r4, lr}
    63ae:	4604      	mov	r4, r0
	u16_t         mss_s;
	struct netif *outif;

	outif = ip_route(addr);
    63b0:	4608      	mov	r0, r1
    63b2:	4b07      	ldr	r3, [pc, #28]	; (63d0 <tcp_eff_send_mss+0x24>)
    63b4:	4798      	blx	r3
	if ((outif != NULL) && (outif->mtu != 0)) {
    63b6:	b138      	cbz	r0, 63c8 <tcp_eff_send_mss+0x1c>
    63b8:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
    63ba:	b138      	cbz	r0, 63cc <tcp_eff_send_mss+0x20>
		mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    63bc:	3828      	subs	r0, #40	; 0x28
		/* RFC 1122, chap 4.2.2.6:
		 * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
		 * We correct for TCP options in tcp_write(), and don't support IP options.
		 */
		sendmss = LWIP_MIN(sendmss, mss_s);
    63be:	b280      	uxth	r0, r0
    63c0:	42a0      	cmp	r0, r4
    63c2:	bf28      	it	cs
    63c4:	4620      	movcs	r0, r4
    63c6:	bd10      	pop	{r4, pc}
    63c8:	4620      	mov	r0, r4
    63ca:	bd10      	pop	{r4, pc}
    63cc:	4620      	mov	r0, r4
	}
	return sendmss;
}
    63ce:	bd10      	pop	{r4, pc}
    63d0:	000043cd 	.word	0x000043cd

000063d4 <tcp_parseopt>:
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void tcp_parseopt(struct tcp_pcb *pcb)
{
    63d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    63d6:	4605      	mov	r5, r0
	u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
	u32_t tsval;
#endif

	opts = (u8_t *)tcphdr + TCP_HLEN;
    63d8:	4b22      	ldr	r3, [pc, #136]	; (6464 <tcp_parseopt+0x90>)
    63da:	681c      	ldr	r4, [r3, #0]

	/* Parse the TCP MSS option, if present. */
	if (TCPH_HDRLEN(tcphdr) > 0x5) {
    63dc:	89a0      	ldrh	r0, [r4, #12]
    63de:	4b22      	ldr	r3, [pc, #136]	; (6468 <tcp_parseopt+0x94>)
    63e0:	4798      	blx	r3
    63e2:	f3c0 300f 	ubfx	r0, r0, #12, #16
    63e6:	2805      	cmp	r0, #5
    63e8:	d800      	bhi.n	63ec <tcp_parseopt+0x18>
    63ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    63ec:	4b1d      	ldr	r3, [pc, #116]	; (6464 <tcp_parseopt+0x90>)
    63ee:	681b      	ldr	r3, [r3, #0]
    63f0:	8998      	ldrh	r0, [r3, #12]
    63f2:	4b1d      	ldr	r3, [pc, #116]	; (6468 <tcp_parseopt+0x94>)
    63f4:	4798      	blx	r3
    63f6:	0b06      	lsrs	r6, r0, #12
    63f8:	3e05      	subs	r6, #5
    63fa:	00b6      	lsls	r6, r6, #2
    63fc:	b2b6      	uxth	r6, r6
		for (c = 0; c < max_c;) {
    63fe:	2e00      	cmp	r6, #0
    6400:	d0f3      	beq.n	63ea <tcp_parseopt+0x16>
	opts = (u8_t *)tcphdr + TCP_HLEN;
    6402:	f104 0214 	add.w	r2, r4, #20
    6406:	2300      	movs	r3, #0
					return;
				}
				/* An MSS option with the right option length. */
				mss = (opts[c + 2] << 8) | opts[c + 3];
				/* Limit the mss to the configured TCP_MSS and prevent division by zero */
				pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    6408:	f240 57b3 	movw	r7, #1459	; 0x5b3
    640c:	f240 54b4 	movw	r4, #1460	; 0x5b4
    6410:	e003      	b.n	641a <tcp_parseopt+0x46>
				++c;
    6412:	3301      	adds	r3, #1
    6414:	b29b      	uxth	r3, r3
		for (c = 0; c < max_c;) {
    6416:	429e      	cmp	r6, r3
    6418:	d9e7      	bls.n	63ea <tcp_parseopt+0x16>
			opt = opts[c];
    641a:	4618      	mov	r0, r3
			switch (opt) {
    641c:	5cd1      	ldrb	r1, [r2, r3]
    641e:	2901      	cmp	r1, #1
    6420:	d0f7      	beq.n	6412 <tcp_parseopt+0x3e>
    6422:	2900      	cmp	r1, #0
    6424:	d0e1      	beq.n	63ea <tcp_parseopt+0x16>
    6426:	2902      	cmp	r1, #2
    6428:	d006      	beq.n	6438 <tcp_parseopt+0x64>
				c += 0x0A;
				break;
#endif
			default:
				LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
				if (opts[c + 1] == 0) {
    642a:	4410      	add	r0, r2
    642c:	7841      	ldrb	r1, [r0, #1]
    642e:	2900      	cmp	r1, #0
    6430:	d0db      	beq.n	63ea <tcp_parseopt+0x16>
					   and we don't process them further. */
					return;
				}
				/* All other options have a length field, so that we easily
				   can skip past them. */
				c += opts[c + 1];
    6432:	440b      	add	r3, r1
    6434:	b29b      	uxth	r3, r3
    6436:	e7ee      	b.n	6416 <tcp_parseopt+0x42>
				if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
    6438:	18d1      	adds	r1, r2, r3
    643a:	7849      	ldrb	r1, [r1, #1]
    643c:	2904      	cmp	r1, #4
    643e:	d1d4      	bne.n	63ea <tcp_parseopt+0x16>
    6440:	1d19      	adds	r1, r3, #4
    6442:	42b1      	cmp	r1, r6
    6444:	dcd1      	bgt.n	63ea <tcp_parseopt+0x16>
				mss = (opts[c + 2] << 8) | opts[c + 3];
    6446:	4410      	add	r0, r2
    6448:	f890 e002 	ldrb.w	lr, [r0, #2]
    644c:	78c1      	ldrb	r1, [r0, #3]
    644e:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
				pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    6452:	1e48      	subs	r0, r1, #1
    6454:	b280      	uxth	r0, r0
    6456:	42b8      	cmp	r0, r7
    6458:	bf88      	it	hi
    645a:	4621      	movhi	r1, r4
    645c:	86e9      	strh	r1, [r5, #54]	; 0x36
				c += 0x04;
    645e:	3304      	adds	r3, #4
    6460:	b29b      	uxth	r3, r3
				break;
    6462:	e7d8      	b.n	6416 <tcp_parseopt+0x42>
    6464:	20007f9c 	.word	0x20007f9c
    6468:	000026ef 	.word	0x000026ef

0000646c <tcp_oos_insert_segment>:
{
    646c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6470:	4605      	mov	r5, r0
    6472:	4689      	mov	r9, r1
	if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    6474:	6903      	ldr	r3, [r0, #16]
    6476:	8998      	ldrh	r0, [r3, #12]
    6478:	4b2a      	ldr	r3, [pc, #168]	; (6524 <tcp_oos_insert_segment+0xb8>)
    647a:	4798      	blx	r3
    647c:	f010 0f01 	tst.w	r0, #1
    6480:	d116      	bne.n	64b0 <tcp_oos_insert_segment+0x44>
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    6482:	f1b9 0f00 	cmp.w	r9, #0
    6486:	d04a      	beq.n	651e <tcp_oos_insert_segment+0xb2>
    6488:	f8d9 2010 	ldr.w	r2, [r9, #16]
    648c:	892b      	ldrh	r3, [r5, #8]
    648e:	6851      	ldr	r1, [r2, #4]
    6490:	1a5b      	subs	r3, r3, r1
    6492:	4925      	ldr	r1, [pc, #148]	; (6528 <tcp_oos_insert_segment+0xbc>)
    6494:	6849      	ldr	r1, [r1, #4]
    6496:	440b      	add	r3, r1
    6498:	f8b9 1008 	ldrh.w	r1, [r9, #8]
    649c:	1a5b      	subs	r3, r3, r1
    649e:	2b00      	cmp	r3, #0
    64a0:	bfb8      	it	lt
    64a2:	464c      	movlt	r4, r9
    64a4:	db29      	blt.n	64fa <tcp_oos_insert_segment+0x8e>
			if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    64a6:	4f1f      	ldr	r7, [pc, #124]	; (6524 <tcp_oos_insert_segment+0xb8>)
				TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    64a8:	f8df 808c 	ldr.w	r8, [pc, #140]	; 6538 <tcp_oos_insert_segment+0xcc>
			tcp_seg_free(old_seg);
    64ac:	4e1f      	ldr	r6, [pc, #124]	; (652c <tcp_oos_insert_segment+0xc0>)
    64ae:	e015      	b.n	64dc <tcp_oos_insert_segment+0x70>
		tcp_segs_free(next);
    64b0:	4648      	mov	r0, r9
    64b2:	4b1f      	ldr	r3, [pc, #124]	; (6530 <tcp_oos_insert_segment+0xc4>)
    64b4:	4798      	blx	r3
		next = NULL;
    64b6:	2400      	movs	r4, #0
    64b8:	e02e      	b.n	6518 <tcp_oos_insert_segment+0xac>
			next    = next->next;
    64ba:	f8d9 4000 	ldr.w	r4, [r9]
			tcp_seg_free(old_seg);
    64be:	4648      	mov	r0, r9
    64c0:	47b0      	blx	r6
		while (next && TCP_SEQ_GEQ((seqno + cseg->len), (next->tcphdr->seqno + next->len))) {
    64c2:	b364      	cbz	r4, 651e <tcp_oos_insert_segment+0xb2>
    64c4:	6922      	ldr	r2, [r4, #16]
    64c6:	892b      	ldrh	r3, [r5, #8]
    64c8:	4917      	ldr	r1, [pc, #92]	; (6528 <tcp_oos_insert_segment+0xbc>)
    64ca:	6849      	ldr	r1, [r1, #4]
    64cc:	440b      	add	r3, r1
    64ce:	6851      	ldr	r1, [r2, #4]
    64d0:	1a5b      	subs	r3, r3, r1
    64d2:	8921      	ldrh	r1, [r4, #8]
    64d4:	1a5b      	subs	r3, r3, r1
    64d6:	2b00      	cmp	r3, #0
    64d8:	db0f      	blt.n	64fa <tcp_oos_insert_segment+0x8e>
			next    = next->next;
    64da:	46a1      	mov	r9, r4
			if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    64dc:	8990      	ldrh	r0, [r2, #12]
    64de:	47b8      	blx	r7
    64e0:	f010 0f01 	tst.w	r0, #1
    64e4:	d0e9      	beq.n	64ba <tcp_oos_insert_segment+0x4e>
				TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    64e6:	f8d5 a010 	ldr.w	sl, [r5, #16]
    64ea:	f8ba 400c 	ldrh.w	r4, [sl, #12]
    64ee:	2001      	movs	r0, #1
    64f0:	47c0      	blx	r8
    64f2:	4320      	orrs	r0, r4
    64f4:	f8aa 000c 	strh.w	r0, [sl, #12]
    64f8:	e7df      	b.n	64ba <tcp_oos_insert_segment+0x4e>
		if (next && TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
    64fa:	4b0b      	ldr	r3, [pc, #44]	; (6528 <tcp_oos_insert_segment+0xbc>)
    64fc:	6859      	ldr	r1, [r3, #4]
    64fe:	6923      	ldr	r3, [r4, #16]
    6500:	685a      	ldr	r2, [r3, #4]
    6502:	892b      	ldrh	r3, [r5, #8]
    6504:	440b      	add	r3, r1
    6506:	1a9b      	subs	r3, r3, r2
    6508:	2b00      	cmp	r3, #0
    650a:	dd05      	ble.n	6518 <tcp_oos_insert_segment+0xac>
			cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    650c:	1a52      	subs	r2, r2, r1
    650e:	b291      	uxth	r1, r2
    6510:	8129      	strh	r1, [r5, #8]
			pbuf_realloc(cseg->p, cseg->len);
    6512:	6868      	ldr	r0, [r5, #4]
    6514:	4b07      	ldr	r3, [pc, #28]	; (6534 <tcp_oos_insert_segment+0xc8>)
    6516:	4798      	blx	r3
	cseg->next = next;
    6518:	602c      	str	r4, [r5, #0]
}
    651a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		next = NULL;
    651e:	2400      	movs	r4, #0
    6520:	e7fa      	b.n	6518 <tcp_oos_insert_segment+0xac>
    6522:	bf00      	nop
    6524:	000026ef 	.word	0x000026ef
    6528:	20007f9c 	.word	0x20007f9c
    652c:	000059e9 	.word	0x000059e9
    6530:	00005a0d 	.word	0x00005a0d
    6534:	0000566d 	.word	0x0000566d
    6538:	000026e5 	.word	0x000026e5

0000653c <tcp_receive>:
{
    653c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6540:	4604      	mov	r4, r0
	if (flags & TCP_ACK) {
    6542:	4baa      	ldr	r3, [pc, #680]	; (67ec <tcp_receive+0x2b0>)
    6544:	7a1b      	ldrb	r3, [r3, #8]
    6546:	f013 0f10 	tst.w	r3, #16
    654a:	f000 8163 	beq.w	6814 <tcp_receive+0x2d8>
		right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    654e:	f8b0 5060 	ldrh.w	r5, [r0, #96]	; 0x60
    6552:	6d80      	ldr	r0, [r0, #88]	; 0x58
		if (TCP_SEQ_LT(pcb->snd_wl1, seqno) || (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno))
    6554:	6d62      	ldr	r2, [r4, #84]	; 0x54
    6556:	4ba5      	ldr	r3, [pc, #660]	; (67ec <tcp_receive+0x2b0>)
    6558:	685b      	ldr	r3, [r3, #4]
    655a:	1ad1      	subs	r1, r2, r3
    655c:	2900      	cmp	r1, #0
    655e:	db28      	blt.n	65b2 <tcp_receive+0x76>
    6560:	429a      	cmp	r2, r3
    6562:	d01b      	beq.n	659c <tcp_receive+0x60>
		    || (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    6564:	4aa1      	ldr	r2, [pc, #644]	; (67ec <tcp_receive+0x2b0>)
    6566:	68d2      	ldr	r2, [r2, #12]
    6568:	4290      	cmp	r0, r2
    656a:	d01d      	beq.n	65a8 <tcp_receive+0x6c>
		if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
    656c:	4b9f      	ldr	r3, [pc, #636]	; (67ec <tcp_receive+0x2b0>)
    656e:	68da      	ldr	r2, [r3, #12]
    6570:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    6572:	1ad1      	subs	r1, r2, r3
    6574:	2900      	cmp	r1, #0
    6576:	dd41      	ble.n	65fc <tcp_receive+0xc0>
		} else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
    6578:	2901      	cmp	r1, #1
    657a:	d403      	bmi.n	6584 <tcp_receive+0x48>
    657c:	6d21      	ldr	r1, [r4, #80]	; 0x50
    657e:	1a51      	subs	r1, r2, r1
    6580:	2900      	cmp	r1, #0
    6582:	dd6e      	ble.n	6662 <tcp_receive+0x126>
			pcb->acked = 0;
    6584:	2300      	movs	r3, #0
    6586:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
		while (pcb->unsent != NULL
    658a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    658c:	2b00      	cmp	r3, #0
    658e:	f000 8139 	beq.w	6804 <tcp_receive+0x2c8>
		       && TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
    6592:	4e96      	ldr	r6, [pc, #600]	; (67ec <tcp_receive+0x2b0>)
    6594:	f8df 8268 	ldr.w	r8, [pc, #616]	; 6800 <tcp_receive+0x2c4>
    6598:	4f95      	ldr	r7, [pc, #596]	; (67f0 <tcp_receive+0x2b4>)
    659a:	e0f8      	b.n	678e <tcp_receive+0x252>
		if (TCP_SEQ_LT(pcb->snd_wl1, seqno) || (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno))
    659c:	4a93      	ldr	r2, [pc, #588]	; (67ec <tcp_receive+0x2b0>)
    659e:	68d2      	ldr	r2, [r2, #12]
    65a0:	1a82      	subs	r2, r0, r2
    65a2:	2a00      	cmp	r2, #0
    65a4:	dade      	bge.n	6564 <tcp_receive+0x28>
    65a6:	e004      	b.n	65b2 <tcp_receive+0x76>
		    || (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    65a8:	4a90      	ldr	r2, [pc, #576]	; (67ec <tcp_receive+0x2b0>)
    65aa:	6812      	ldr	r2, [r2, #0]
    65ac:	89d2      	ldrh	r2, [r2, #14]
    65ae:	42aa      	cmp	r2, r5
    65b0:	d9dc      	bls.n	656c <tcp_receive+0x30>
			pcb->snd_wnd = tcphdr->wnd;
    65b2:	4a8e      	ldr	r2, [pc, #568]	; (67ec <tcp_receive+0x2b0>)
    65b4:	6812      	ldr	r2, [r2, #0]
    65b6:	89d1      	ldrh	r1, [r2, #14]
    65b8:	b28e      	uxth	r6, r1
    65ba:	f8a4 1060 	strh.w	r1, [r4, #96]	; 0x60
			if (pcb->snd_wnd_max < tcphdr->wnd) {
    65be:	89d2      	ldrh	r2, [r2, #14]
    65c0:	b291      	uxth	r1, r2
    65c2:	f8b4 7062 	ldrh.w	r7, [r4, #98]	; 0x62
    65c6:	428f      	cmp	r7, r1
				pcb->snd_wnd_max = tcphdr->wnd;
    65c8:	bf38      	it	cc
    65ca:	f8a4 2062 	strhcc.w	r2, [r4, #98]	; 0x62
			pcb->snd_wl1 = seqno;
    65ce:	6563      	str	r3, [r4, #84]	; 0x54
			pcb->snd_wl2 = ackno;
    65d0:	4b86      	ldr	r3, [pc, #536]	; (67ec <tcp_receive+0x2b0>)
    65d2:	68db      	ldr	r3, [r3, #12]
    65d4:	65a3      	str	r3, [r4, #88]	; 0x58
			if (pcb->snd_wnd == 0) {
    65d6:	b94e      	cbnz	r6, 65ec <tcp_receive+0xb0>
				if (pcb->persist_backoff == 0) {
    65d8:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
    65dc:	2b00      	cmp	r3, #0
    65de:	d1c5      	bne.n	656c <tcp_receive+0x30>
					pcb->persist_cnt     = 0;
    65e0:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
					pcb->persist_backoff = 1;
    65e4:	2301      	movs	r3, #1
    65e6:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
    65ea:	e7bf      	b.n	656c <tcp_receive+0x30>
			} else if (pcb->persist_backoff > 0) {
    65ec:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
    65f0:	2b00      	cmp	r3, #0
    65f2:	d0bb      	beq.n	656c <tcp_receive+0x30>
				pcb->persist_backoff = 0;
    65f4:	2300      	movs	r3, #0
    65f6:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
    65fa:	e7b7      	b.n	656c <tcp_receive+0x30>
			pcb->acked = 0;
    65fc:	2100      	movs	r1, #0
    65fe:	f8a4 1064 	strh.w	r1, [r4, #100]	; 0x64
			if (tcplen == 0) {
    6602:	497a      	ldr	r1, [pc, #488]	; (67ec <tcp_receive+0x2b0>)
    6604:	8a09      	ldrh	r1, [r1, #16]
    6606:	b931      	cbnz	r1, 6616 <tcp_receive+0xda>
		right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    6608:	4428      	add	r0, r5
				if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
    660a:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
    660e:	6da5      	ldr	r5, [r4, #88]	; 0x58
    6610:	4429      	add	r1, r5
    6612:	4288      	cmp	r0, r1
    6614:	d003      	beq.n	661e <tcp_receive+0xe2>
				pcb->dupacks = 0;
    6616:	2300      	movs	r3, #0
    6618:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
    661c:	e7b5      	b.n	658a <tcp_receive+0x4e>
					if (pcb->rtime >= 0) {
    661e:	f9b4 1034 	ldrsh.w	r1, [r4, #52]	; 0x34
    6622:	2900      	cmp	r1, #0
    6624:	dbf7      	blt.n	6616 <tcp_receive+0xda>
						if (pcb->lastack == ackno) {
    6626:	429a      	cmp	r2, r3
    6628:	d1f5      	bne.n	6616 <tcp_receive+0xda>
							if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
    662a:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
    662e:	1c53      	adds	r3, r2, #1
    6630:	b2db      	uxtb	r3, r3
    6632:	429a      	cmp	r2, r3
								++pcb->dupacks;
    6634:	bf38      	it	cc
    6636:	f884 3047 	strbcc.w	r3, [r4, #71]	; 0x47
							if (pcb->dupacks > 3) {
    663a:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
    663e:	2b03      	cmp	r3, #3
    6640:	d909      	bls.n	6656 <tcp_receive+0x11a>
								if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    6642:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    6646:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    6648:	4413      	add	r3, r2
    664a:	b29b      	uxth	r3, r3
    664c:	429a      	cmp	r2, r3
    664e:	d29c      	bcs.n	658a <tcp_receive+0x4e>
									pcb->cwnd += pcb->mss;
    6650:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    6654:	e799      	b.n	658a <tcp_receive+0x4e>
							} else if (pcb->dupacks == 3) {
    6656:	2b03      	cmp	r3, #3
    6658:	d197      	bne.n	658a <tcp_receive+0x4e>
								tcp_rexmit_fast(pcb);
    665a:	4620      	mov	r0, r4
    665c:	4b65      	ldr	r3, [pc, #404]	; (67f4 <tcp_receive+0x2b8>)
    665e:	4798      	blx	r3
    6660:	e793      	b.n	658a <tcp_receive+0x4e>
			if (pcb->flags & TF_INFR) {
    6662:	7fa1      	ldrb	r1, [r4, #30]
    6664:	f011 0f04 	tst.w	r1, #4
    6668:	d006      	beq.n	6678 <tcp_receive+0x13c>
				pcb->flags &= ~TF_INFR;
    666a:	f021 0104 	bic.w	r1, r1, #4
    666e:	77a1      	strb	r1, [r4, #30]
				pcb->cwnd = pcb->ssthresh;
    6670:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
    6674:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
			pcb->nrtx = 0;
    6678:	2000      	movs	r0, #0
    667a:	f884 0046 	strb.w	r0, [r4, #70]	; 0x46
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    667e:	f9b4 5040 	ldrsh.w	r5, [r4, #64]	; 0x40
    6682:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
    6686:	eb01 01e5 	add.w	r1, r1, r5, asr #3
    668a:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
			pcb->acked = (u16_t)(ackno - pcb->lastack);
    668e:	1ad3      	subs	r3, r2, r3
    6690:	b29b      	uxth	r3, r3
    6692:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
			pcb->snd_buf += pcb->acked;
    6696:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
    669a:	440b      	add	r3, r1
    669c:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
			pcb->dupacks = 0;
    66a0:	f884 0047 	strb.w	r0, [r4, #71]	; 0x47
			pcb->lastack = ackno;
    66a4:	64a2      	str	r2, [r4, #72]	; 0x48
			if (pcb->state >= ESTABLISHED) {
    66a6:	7e23      	ldrb	r3, [r4, #24]
    66a8:	2b03      	cmp	r3, #3
    66aa:	d90c      	bls.n	66c6 <tcp_receive+0x18a>
				if (pcb->cwnd < pcb->ssthresh) {
    66ac:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
    66b0:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
    66b4:	4293      	cmp	r3, r2
    66b6:	d90e      	bls.n	66d6 <tcp_receive+0x19a>
					if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    66b8:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    66ba:	4413      	add	r3, r2
    66bc:	b29b      	uxth	r3, r3
    66be:	429a      	cmp	r2, r3
						pcb->cwnd += pcb->mss;
    66c0:	bf38      	it	cc
    66c2:	f8a4 304c 	strhcc.w	r3, [r4, #76]	; 0x4c
			while (pcb->unacked != NULL
    66c6:	6f23      	ldr	r3, [r4, #112]	; 0x70
    66c8:	2b00      	cmp	r3, #0
    66ca:	d04b      	beq.n	6764 <tcp_receive+0x228>
			       && TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked), ackno)) {
    66cc:	f8df 8130 	ldr.w	r8, [pc, #304]	; 6800 <tcp_receive+0x2c4>
    66d0:	4e47      	ldr	r6, [pc, #284]	; (67f0 <tcp_receive+0x2b4>)
    66d2:	4f46      	ldr	r7, [pc, #280]	; (67ec <tcp_receive+0x2b0>)
    66d4:	e018      	b.n	6708 <tcp_receive+0x1cc>
					u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
    66d6:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    66d8:	fb03 f303 	mul.w	r3, r3, r3
    66dc:	fb93 f3f2 	sdiv	r3, r3, r2
    66e0:	4413      	add	r3, r2
    66e2:	b29b      	uxth	r3, r3
					if (new_cwnd > pcb->cwnd) {
    66e4:	429a      	cmp	r2, r3
    66e6:	d2ee      	bcs.n	66c6 <tcp_receive+0x18a>
						pcb->cwnd = new_cwnd;
    66e8:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
    66ec:	e7eb      	b.n	66c6 <tcp_receive+0x18a>
				pcb->snd_queuelen -= pbuf_clen(next->p);
    66ee:	6868      	ldr	r0, [r5, #4]
    66f0:	4b41      	ldr	r3, [pc, #260]	; (67f8 <tcp_receive+0x2bc>)
    66f2:	4798      	blx	r3
    66f4:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    66f8:	1a18      	subs	r0, r3, r0
    66fa:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
				tcp_seg_free(next);
    66fe:	4628      	mov	r0, r5
    6700:	4b3e      	ldr	r3, [pc, #248]	; (67fc <tcp_receive+0x2c0>)
    6702:	4798      	blx	r3
			while (pcb->unacked != NULL
    6704:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6706:	b36b      	cbz	r3, 6764 <tcp_receive+0x228>
			       && TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked), ackno)) {
    6708:	691b      	ldr	r3, [r3, #16]
    670a:	6858      	ldr	r0, [r3, #4]
    670c:	47c0      	blx	r8
    670e:	4605      	mov	r5, r0
    6710:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6712:	f8b3 9008 	ldrh.w	r9, [r3, #8]
    6716:	691b      	ldr	r3, [r3, #16]
    6718:	8998      	ldrh	r0, [r3, #12]
    671a:	47b0      	blx	r6
    671c:	f010 0003 	ands.w	r0, r0, #3
    6720:	bf18      	it	ne
    6722:	2001      	movne	r0, #1
    6724:	4448      	add	r0, r9
    6726:	68fb      	ldr	r3, [r7, #12]
    6728:	1aed      	subs	r5, r5, r3
    672a:	4428      	add	r0, r5
    672c:	2800      	cmp	r0, #0
    672e:	dc12      	bgt.n	6756 <tcp_receive+0x21a>
				next         = pcb->unacked;
    6730:	6f25      	ldr	r5, [r4, #112]	; 0x70
				pcb->unacked = pcb->unacked->next;
    6732:	682b      	ldr	r3, [r5, #0]
    6734:	6723      	str	r3, [r4, #112]	; 0x70
				if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    6736:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    673a:	2b00      	cmp	r3, #0
    673c:	d0d7      	beq.n	66ee <tcp_receive+0x1b2>
    673e:	692b      	ldr	r3, [r5, #16]
    6740:	8998      	ldrh	r0, [r3, #12]
    6742:	47b0      	blx	r6
    6744:	f010 0f01 	tst.w	r0, #1
    6748:	d0d1      	beq.n	66ee <tcp_receive+0x1b2>
					pcb->acked--;
    674a:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    674e:	3b01      	subs	r3, #1
    6750:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    6754:	e7cb      	b.n	66ee <tcp_receive+0x1b2>
			if (pcb->unacked == NULL)
    6756:	6f23      	ldr	r3, [r4, #112]	; 0x70
    6758:	b123      	cbz	r3, 6764 <tcp_receive+0x228>
				pcb->rtime = 0;
    675a:	2300      	movs	r3, #0
    675c:	86a3      	strh	r3, [r4, #52]	; 0x34
			pcb->polltmr = 0;
    675e:	2300      	movs	r3, #0
    6760:	77e3      	strb	r3, [r4, #31]
    6762:	e712      	b.n	658a <tcp_receive+0x4e>
				pcb->rtime = -1;
    6764:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6768:	86a3      	strh	r3, [r4, #52]	; 0x34
    676a:	e7f8      	b.n	675e <tcp_receive+0x222>
				pcb->unsent_oversize = 0;
    676c:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
    6770:	e02c      	b.n	67cc <tcp_receive+0x290>
			pcb->snd_queuelen -= pbuf_clen(next->p);
    6772:	6868      	ldr	r0, [r5, #4]
    6774:	4b20      	ldr	r3, [pc, #128]	; (67f8 <tcp_receive+0x2bc>)
    6776:	4798      	blx	r3
    6778:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    677c:	1a18      	subs	r0, r3, r0
    677e:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
			tcp_seg_free(next);
    6782:	4628      	mov	r0, r5
    6784:	4b1d      	ldr	r3, [pc, #116]	; (67fc <tcp_receive+0x2c0>)
    6786:	4798      	blx	r3
		while (pcb->unsent != NULL
    6788:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    678a:	2b00      	cmp	r3, #0
    678c:	d03a      	beq.n	6804 <tcp_receive+0x2c8>
		       && TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
    678e:	68f5      	ldr	r5, [r6, #12]
    6790:	691b      	ldr	r3, [r3, #16]
    6792:	6858      	ldr	r0, [r3, #4]
    6794:	47c0      	blx	r8
    6796:	4682      	mov	sl, r0
    6798:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    679a:	f8b3 9008 	ldrh.w	r9, [r3, #8]
    679e:	691b      	ldr	r3, [r3, #16]
    67a0:	8998      	ldrh	r0, [r3, #12]
    67a2:	47b8      	blx	r7
    67a4:	eba5 050a 	sub.w	r5, r5, sl
    67a8:	f010 0003 	ands.w	r0, r0, #3
    67ac:	bf18      	it	ne
    67ae:	2001      	movne	r0, #1
    67b0:	4448      	add	r0, r9
    67b2:	1a2d      	subs	r5, r5, r0
    67b4:	2d00      	cmp	r5, #0
    67b6:	db25      	blt.n	6804 <tcp_receive+0x2c8>
    67b8:	68f3      	ldr	r3, [r6, #12]
    67ba:	6d22      	ldr	r2, [r4, #80]	; 0x50
    67bc:	1a9b      	subs	r3, r3, r2
    67be:	2b00      	cmp	r3, #0
    67c0:	dc20      	bgt.n	6804 <tcp_receive+0x2c8>
			next        = pcb->unsent;
    67c2:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
			pcb->unsent = pcb->unsent->next;
    67c4:	682b      	ldr	r3, [r5, #0]
    67c6:	66e3      	str	r3, [r4, #108]	; 0x6c
			if (pcb->unsent == NULL) {
    67c8:	2b00      	cmp	r3, #0
    67ca:	d0cf      	beq.n	676c <tcp_receive+0x230>
			if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    67cc:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    67d0:	2b00      	cmp	r3, #0
    67d2:	d0ce      	beq.n	6772 <tcp_receive+0x236>
    67d4:	692b      	ldr	r3, [r5, #16]
    67d6:	8998      	ldrh	r0, [r3, #12]
    67d8:	47b8      	blx	r7
    67da:	f010 0f01 	tst.w	r0, #1
    67de:	d0c8      	beq.n	6772 <tcp_receive+0x236>
				pcb->acked--;
    67e0:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
    67e4:	3b01      	subs	r3, #1
    67e6:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
    67ea:	e7c2      	b.n	6772 <tcp_receive+0x236>
    67ec:	20007f9c 	.word	0x20007f9c
    67f0:	000026ef 	.word	0x000026ef
    67f4:	00007e51 	.word	0x00007e51
    67f8:	000056cd 	.word	0x000056cd
    67fc:	000059e9 	.word	0x000059e9
    6800:	00002711 	.word	0x00002711
		if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    6804:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    6806:	b12b      	cbz	r3, 6814 <tcp_receive+0x2d8>
    6808:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    680a:	499a      	ldr	r1, [pc, #616]	; (6a74 <tcp_receive+0x538>)
    680c:	68c9      	ldr	r1, [r1, #12]
    680e:	1a52      	subs	r2, r2, r1
    6810:	2a00      	cmp	r2, #0
    6812:	db23      	blt.n	685c <tcp_receive+0x320>
	if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
    6814:	4b97      	ldr	r3, [pc, #604]	; (6a74 <tcp_receive+0x538>)
    6816:	8a1b      	ldrh	r3, [r3, #16]
    6818:	2b00      	cmp	r3, #0
    681a:	f000 8244 	beq.w	6ca6 <tcp_receive+0x76a>
    681e:	7e22      	ldrb	r2, [r4, #24]
    6820:	2a06      	cmp	r2, #6
    6822:	f200 8240 	bhi.w	6ca6 <tcp_receive+0x76a>
		if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
    6826:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    6828:	4a92      	ldr	r2, [pc, #584]	; (6a74 <tcp_receive+0x538>)
    682a:	6852      	ldr	r2, [r2, #4]
    682c:	1a8d      	subs	r5, r1, r2
    682e:	2d01      	cmp	r5, #1
    6830:	d405      	bmi.n	683e <tcp_receive+0x302>
    6832:	f1c2 0001 	rsb	r0, r2, #1
    6836:	1ac3      	subs	r3, r0, r3
    6838:	440b      	add	r3, r1
    683a:	2b00      	cmp	r3, #0
    683c:	dd2e      	ble.n	689c <tcp_receive+0x360>
			if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
    683e:	1a53      	subs	r3, r2, r1
    6840:	2b00      	cmp	r3, #0
    6842:	db54      	blt.n	68ee <tcp_receive+0x3b2>
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    6844:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    6846:	f1c3 0301 	rsb	r3, r3, #1
    684a:	4413      	add	r3, r2
    684c:	1a5b      	subs	r3, r3, r1
    684e:	2b00      	cmp	r3, #0
    6850:	dd52      	ble.n	68f8 <tcp_receive+0x3bc>
			tcp_send_empty_ack(pcb);
    6852:	4620      	mov	r0, r4
    6854:	4b88      	ldr	r3, [pc, #544]	; (6a78 <tcp_receive+0x53c>)
    6856:	4798      	blx	r3
    6858:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			m = m - (pcb->sa >> 3);
    685c:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
			m = (s16_t)(tcp_ticks - pcb->rttest);
    6860:	4a86      	ldr	r2, [pc, #536]	; (6a7c <tcp_receive+0x540>)
    6862:	6812      	ldr	r2, [r2, #0]
    6864:	1ad3      	subs	r3, r2, r3
			m = m - (pcb->sa >> 3);
    6866:	eba3 03e1 	sub.w	r3, r3, r1, asr #3
    686a:	b29b      	uxth	r3, r3
    686c:	b218      	sxth	r0, r3
			pcb->sa += m;
    686e:	185a      	adds	r2, r3, r1
    6870:	b212      	sxth	r2, r2
    6872:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
			if (m < 0) {
    6876:	2800      	cmp	r0, #0
				m = -m;
    6878:	bfbc      	itt	lt
    687a:	425b      	neglt	r3, r3
    687c:	b218      	sxthlt	r0, r3
			m = m - (pcb->sv >> 2);
    687e:	f9b4 3042 	ldrsh.w	r3, [r4, #66]	; 0x42
			pcb->sv += m;
    6882:	eba3 03a3 	sub.w	r3, r3, r3, asr #2
    6886:	4403      	add	r3, r0
    6888:	b29b      	uxth	r3, r3
    688a:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
			pcb->rto = (pcb->sa >> 3) + pcb->sv;
    688e:	eb03 03e2 	add.w	r3, r3, r2, asr #3
    6892:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
			pcb->rttest = 0;
    6896:	2300      	movs	r3, #0
    6898:	63a3      	str	r3, [r4, #56]	; 0x38
    689a:	e7bb      	b.n	6814 <tcp_receive+0x2d8>
			off = pcb->rcv_nxt - seqno;
    689c:	462b      	mov	r3, r5
			p   = inseg.p;
    689e:	4a75      	ldr	r2, [pc, #468]	; (6a74 <tcp_receive+0x538>)
    68a0:	6990      	ldr	r0, [r2, #24]
			if (inseg.p->len < off) {
    68a2:	8942      	ldrh	r2, [r0, #10]
    68a4:	4295      	cmp	r5, r2
    68a6:	dd1d      	ble.n	68e4 <tcp_receive+0x3a8>
				new_tot_len = (u16_t)(inseg.p->tot_len - off);
    68a8:	8901      	ldrh	r1, [r0, #8]
    68aa:	1b49      	subs	r1, r1, r5
    68ac:	b289      	uxth	r1, r1
					p->len     = 0;
    68ae:	2500      	movs	r5, #0
					off -= p->len;
    68b0:	1a9b      	subs	r3, r3, r2
					p->tot_len = new_tot_len;
    68b2:	8101      	strh	r1, [r0, #8]
					p->len     = 0;
    68b4:	8145      	strh	r5, [r0, #10]
					p          = p->next;
    68b6:	6800      	ldr	r0, [r0, #0]
				while (p->len < off) {
    68b8:	8942      	ldrh	r2, [r0, #10]
    68ba:	429a      	cmp	r2, r3
    68bc:	dbf8      	blt.n	68b0 <tcp_receive+0x374>
				if (pbuf_header(p, (s16_t)-off)) {
    68be:	425b      	negs	r3, r3
    68c0:	b219      	sxth	r1, r3
    68c2:	4b6f      	ldr	r3, [pc, #444]	; (6a80 <tcp_receive+0x544>)
    68c4:	4798      	blx	r3
			inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    68c6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    68c8:	4b6a      	ldr	r3, [pc, #424]	; (6a74 <tcp_receive+0x538>)
    68ca:	6859      	ldr	r1, [r3, #4]
    68cc:	8b98      	ldrh	r0, [r3, #28]
    68ce:	4401      	add	r1, r0
    68d0:	1a89      	subs	r1, r1, r2
    68d2:	8399      	strh	r1, [r3, #28]
			inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    68d4:	6a59      	ldr	r1, [r3, #36]	; 0x24
    68d6:	605a      	str	r2, [r3, #4]
    68d8:	604a      	str	r2, [r1, #4]
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    68da:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    68dc:	1a53      	subs	r3, r2, r1
    68de:	2b00      	cmp	r3, #0
    68e0:	dab0      	bge.n	6844 <tcp_receive+0x308>
    68e2:	e7b6      	b.n	6852 <tcp_receive+0x316>
				if (pbuf_header(inseg.p, (s16_t)-off)) {
    68e4:	4269      	negs	r1, r5
    68e6:	b209      	sxth	r1, r1
    68e8:	4b65      	ldr	r3, [pc, #404]	; (6a80 <tcp_receive+0x544>)
    68ea:	4798      	blx	r3
    68ec:	e7eb      	b.n	68c6 <tcp_receive+0x38a>
				tcp_ack_now(pcb);
    68ee:	7fa3      	ldrb	r3, [r4, #30]
    68f0:	f043 0302 	orr.w	r3, r3, #2
    68f4:	77a3      	strb	r3, [r4, #30]
    68f6:	e7ac      	b.n	6852 <tcp_receive+0x316>
			if (pcb->rcv_nxt == seqno) {
    68f8:	428a      	cmp	r2, r1
    68fa:	d013      	beq.n	6924 <tcp_receive+0x3e8>
				tcp_send_empty_ack(pcb);
    68fc:	4620      	mov	r0, r4
    68fe:	4b5e      	ldr	r3, [pc, #376]	; (6a78 <tcp_receive+0x53c>)
    6900:	4798      	blx	r3
				if (pcb->ooseq == NULL) {
    6902:	6f66      	ldr	r6, [r4, #116]	; 0x74
    6904:	2e00      	cmp	r6, #0
    6906:	f000 8119 	beq.w	6b3c <tcp_receive+0x600>
						if (seqno == next->tcphdr->seqno) {
    690a:	6931      	ldr	r1, [r6, #16]
    690c:	684a      	ldr	r2, [r1, #4]
    690e:	4b59      	ldr	r3, [pc, #356]	; (6a74 <tcp_receive+0x538>)
    6910:	6858      	ldr	r0, [r3, #4]
    6912:	4282      	cmp	r2, r0
    6914:	f000 8118 	beq.w	6b48 <tcp_receive+0x60c>
    6918:	2700      	movs	r7, #0
								if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
    691a:	f100 3eff 	add.w	lr, r0, #4294967295
    691e:	f100 0c01 	add.w	ip, r0, #1
    6922:	e134      	b.n	6b8e <tcp_receive+0x652>
				tcplen = TCP_TCPLEN(&inseg);
    6924:	4e53      	ldr	r6, [pc, #332]	; (6a74 <tcp_receive+0x538>)
    6926:	8bb5      	ldrh	r5, [r6, #28]
    6928:	6a73      	ldr	r3, [r6, #36]	; 0x24
    692a:	8998      	ldrh	r0, [r3, #12]
    692c:	4b55      	ldr	r3, [pc, #340]	; (6a84 <tcp_receive+0x548>)
    692e:	4798      	blx	r3
    6930:	f010 0303 	ands.w	r3, r0, #3
    6934:	bf18      	it	ne
    6936:	2301      	movne	r3, #1
    6938:	442b      	add	r3, r5
    693a:	b29b      	uxth	r3, r3
    693c:	8233      	strh	r3, [r6, #16]
				if (tcplen > pcb->rcv_wnd) {
    693e:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    6940:	429a      	cmp	r2, r3
    6942:	d317      	bcc.n	6974 <tcp_receive+0x438>
				if (pcb->ooseq != NULL) {
    6944:	6f63      	ldr	r3, [r4, #116]	; 0x74
    6946:	2b00      	cmp	r3, #0
    6948:	f000 81c1 	beq.w	6cce <tcp_receive+0x792>
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    694c:	4b49      	ldr	r3, [pc, #292]	; (6a74 <tcp_receive+0x538>)
    694e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6950:	8998      	ldrh	r0, [r3, #12]
    6952:	4b4c      	ldr	r3, [pc, #304]	; (6a84 <tcp_receive+0x548>)
    6954:	4798      	blx	r3
    6956:	f010 0f01 	tst.w	r0, #1
    695a:	d03f      	beq.n	69dc <tcp_receive+0x4a0>
						while (pcb->ooseq != NULL) {
    695c:	6f60      	ldr	r0, [r4, #116]	; 0x74
    695e:	2800      	cmp	r0, #0
    6960:	f000 81b5 	beq.w	6cce <tcp_receive+0x792>
							tcp_seg_free(old_ooseq);
    6964:	4d48      	ldr	r5, [pc, #288]	; (6a88 <tcp_receive+0x54c>)
							pcb->ooseq                = pcb->ooseq->next;
    6966:	6803      	ldr	r3, [r0, #0]
    6968:	6763      	str	r3, [r4, #116]	; 0x74
							tcp_seg_free(old_ooseq);
    696a:	47a8      	blx	r5
						while (pcb->ooseq != NULL) {
    696c:	6f60      	ldr	r0, [r4, #116]	; 0x74
    696e:	2800      	cmp	r0, #0
    6970:	d1f9      	bne.n	6966 <tcp_receive+0x42a>
    6972:	e1ac      	b.n	6cce <tcp_receive+0x792>
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    6974:	6a73      	ldr	r3, [r6, #36]	; 0x24
    6976:	8998      	ldrh	r0, [r3, #12]
    6978:	4b42      	ldr	r3, [pc, #264]	; (6a84 <tcp_receive+0x548>)
    697a:	4798      	blx	r3
    697c:	f010 0f01 	tst.w	r0, #1
    6980:	d11e      	bne.n	69c0 <tcp_receive+0x484>
					inseg.len = pcb->rcv_wnd;
    6982:	4b3c      	ldr	r3, [pc, #240]	; (6a74 <tcp_receive+0x538>)
    6984:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    6986:	839a      	strh	r2, [r3, #28]
					if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    6988:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    698a:	8998      	ldrh	r0, [r3, #12]
    698c:	4b3d      	ldr	r3, [pc, #244]	; (6a84 <tcp_receive+0x548>)
    698e:	4798      	blx	r3
    6990:	f010 0f02 	tst.w	r0, #2
    6994:	d003      	beq.n	699e <tcp_receive+0x462>
						inseg.len -= 1;
    6996:	4a37      	ldr	r2, [pc, #220]	; (6a74 <tcp_receive+0x538>)
    6998:	8b93      	ldrh	r3, [r2, #28]
    699a:	3b01      	subs	r3, #1
    699c:	8393      	strh	r3, [r2, #28]
					pbuf_realloc(inseg.p, inseg.len);
    699e:	4d35      	ldr	r5, [pc, #212]	; (6a74 <tcp_receive+0x538>)
    69a0:	8ba9      	ldrh	r1, [r5, #28]
    69a2:	69a8      	ldr	r0, [r5, #24]
    69a4:	4b39      	ldr	r3, [pc, #228]	; (6a8c <tcp_receive+0x550>)
    69a6:	4798      	blx	r3
					tcplen = TCP_TCPLEN(&inseg);
    69a8:	8bae      	ldrh	r6, [r5, #28]
    69aa:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    69ac:	8998      	ldrh	r0, [r3, #12]
    69ae:	4b35      	ldr	r3, [pc, #212]	; (6a84 <tcp_receive+0x548>)
    69b0:	4798      	blx	r3
    69b2:	f010 0003 	ands.w	r0, r0, #3
    69b6:	bf18      	it	ne
    69b8:	2001      	movne	r0, #1
    69ba:	4406      	add	r6, r0
    69bc:	822e      	strh	r6, [r5, #16]
    69be:	e7c1      	b.n	6944 <tcp_receive+0x408>
						TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~TCP_FIN);
    69c0:	6a76      	ldr	r6, [r6, #36]	; 0x24
    69c2:	89b5      	ldrh	r5, [r6, #12]
    69c4:	4628      	mov	r0, r5
    69c6:	4b2f      	ldr	r3, [pc, #188]	; (6a84 <tcp_receive+0x548>)
    69c8:	4798      	blx	r3
    69ca:	f000 003e 	and.w	r0, r0, #62	; 0x3e
    69ce:	4b30      	ldr	r3, [pc, #192]	; (6a90 <tcp_receive+0x554>)
    69d0:	4798      	blx	r3
    69d2:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
    69d6:	4305      	orrs	r5, r0
    69d8:	81b5      	strh	r5, [r6, #12]
    69da:	e7d2      	b.n	6982 <tcp_receive+0x446>
						next = pcb->ooseq;
    69dc:	f8d4 9074 	ldr.w	r9, [r4, #116]	; 0x74
						while (next && TCP_SEQ_GEQ(seqno + tcplen, next->tcphdr->seqno + next->len)) {
    69e0:	f1b9 0f00 	cmp.w	r9, #0
    69e4:	f000 8171 	beq.w	6cca <tcp_receive+0x78e>
    69e8:	f8d9 2010 	ldr.w	r2, [r9, #16]
    69ec:	4921      	ldr	r1, [pc, #132]	; (6a74 <tcp_receive+0x538>)
    69ee:	8a0b      	ldrh	r3, [r1, #16]
    69f0:	6849      	ldr	r1, [r1, #4]
    69f2:	440b      	add	r3, r1
    69f4:	6851      	ldr	r1, [r2, #4]
    69f6:	1a5b      	subs	r3, r3, r1
    69f8:	f8b9 1008 	ldrh.w	r1, [r9, #8]
    69fc:	1a5b      	subs	r3, r3, r1
    69fe:	2b00      	cmp	r3, #0
    6a00:	f2c0 81a8 	blt.w	6d54 <tcp_receive+0x818>
							if (TCPH_FLAGS(next->tcphdr) & TCP_FIN && (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    6a04:	4f1f      	ldr	r7, [pc, #124]	; (6a84 <tcp_receive+0x548>)
    6a06:	4e1b      	ldr	r6, [pc, #108]	; (6a74 <tcp_receive+0x538>)
								TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    6a08:	f8df 8084 	ldr.w	r8, [pc, #132]	; 6a90 <tcp_receive+0x554>
    6a0c:	e013      	b.n	6a36 <tcp_receive+0x4fa>
							next = next->next;
    6a0e:	f8d9 5000 	ldr.w	r5, [r9]
							tcp_seg_free(prev);
    6a12:	4648      	mov	r0, r9
    6a14:	4b1c      	ldr	r3, [pc, #112]	; (6a88 <tcp_receive+0x54c>)
    6a16:	4798      	blx	r3
						while (next && TCP_SEQ_GEQ(seqno + tcplen, next->tcphdr->seqno + next->len)) {
    6a18:	2d00      	cmp	r5, #0
    6a1a:	f000 8156 	beq.w	6cca <tcp_receive+0x78e>
    6a1e:	692a      	ldr	r2, [r5, #16]
    6a20:	8a33      	ldrh	r3, [r6, #16]
    6a22:	6871      	ldr	r1, [r6, #4]
    6a24:	440b      	add	r3, r1
    6a26:	6851      	ldr	r1, [r2, #4]
    6a28:	1a5b      	subs	r3, r3, r1
    6a2a:	8929      	ldrh	r1, [r5, #8]
    6a2c:	1a5b      	subs	r3, r3, r1
    6a2e:	2b00      	cmp	r3, #0
    6a30:	f2c0 8191 	blt.w	6d56 <tcp_receive+0x81a>
							next = next->next;
    6a34:	46a9      	mov	r9, r5
							if (TCPH_FLAGS(next->tcphdr) & TCP_FIN && (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    6a36:	8990      	ldrh	r0, [r2, #12]
    6a38:	47b8      	blx	r7
    6a3a:	f010 0f01 	tst.w	r0, #1
    6a3e:	d0e6      	beq.n	6a0e <tcp_receive+0x4d2>
    6a40:	6a73      	ldr	r3, [r6, #36]	; 0x24
    6a42:	8998      	ldrh	r0, [r3, #12]
    6a44:	47b8      	blx	r7
    6a46:	f010 0f02 	tst.w	r0, #2
    6a4a:	d1e0      	bne.n	6a0e <tcp_receive+0x4d2>
								TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    6a4c:	f8d6 a024 	ldr.w	sl, [r6, #36]	; 0x24
    6a50:	f8ba 500c 	ldrh.w	r5, [sl, #12]
    6a54:	2001      	movs	r0, #1
    6a56:	47c0      	blx	r8
    6a58:	4328      	orrs	r0, r5
    6a5a:	f8aa 000c 	strh.w	r0, [sl, #12]
								tcplen = TCP_TCPLEN(&inseg);
    6a5e:	8bb5      	ldrh	r5, [r6, #28]
    6a60:	6a73      	ldr	r3, [r6, #36]	; 0x24
    6a62:	8998      	ldrh	r0, [r3, #12]
    6a64:	47b8      	blx	r7
    6a66:	f010 0003 	ands.w	r0, r0, #3
    6a6a:	bf18      	it	ne
    6a6c:	2001      	movne	r0, #1
    6a6e:	4405      	add	r5, r0
    6a70:	8235      	strh	r5, [r6, #16]
    6a72:	e7cc      	b.n	6a0e <tcp_receive+0x4d2>
    6a74:	20007f9c 	.word	0x20007f9c
    6a78:	000079d1 	.word	0x000079d1
    6a7c:	200092e4 	.word	0x200092e4
    6a80:	00005435 	.word	0x00005435
    6a84:	000026ef 	.word	0x000026ef
    6a88:	000059e9 	.word	0x000059e9
    6a8c:	0000566d 	.word	0x0000566d
    6a90:	000026e5 	.word	0x000026e5
							recv_data = cseg->p;
    6a94:	62b9      	str	r1, [r7, #40]	; 0x28
						cseg->p = NULL;
    6a96:	2300      	movs	r3, #0
    6a98:	606b      	str	r3, [r5, #4]
					if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    6a9a:	692b      	ldr	r3, [r5, #16]
    6a9c:	8998      	ldrh	r0, [r3, #12]
    6a9e:	47b0      	blx	r6
    6aa0:	f010 0f01 	tst.w	r0, #1
    6aa4:	d00a      	beq.n	6abc <tcp_receive+0x580>
						recv_flags |= TF_GOT_FIN;
    6aa6:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
    6aaa:	f043 0320 	orr.w	r3, r3, #32
    6aae:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
						if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
    6ab2:	7e23      	ldrb	r3, [r4, #24]
    6ab4:	2b04      	cmp	r3, #4
							pcb->state = CLOSE_WAIT;
    6ab6:	bf04      	itt	eq
    6ab8:	2307      	moveq	r3, #7
    6aba:	7623      	strbeq	r3, [r4, #24]
					pcb->ooseq = cseg->next;
    6abc:	682b      	ldr	r3, [r5, #0]
    6abe:	6763      	str	r3, [r4, #116]	; 0x74
					tcp_seg_free(cseg);
    6ac0:	4628      	mov	r0, r5
    6ac2:	4b9a      	ldr	r3, [pc, #616]	; (6d2c <tcp_receive+0x7f0>)
    6ac4:	4798      	blx	r3
				while (pcb->ooseq != NULL && pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    6ac6:	6f65      	ldr	r5, [r4, #116]	; 0x74
    6ac8:	2d00      	cmp	r5, #0
    6aca:	d02a      	beq.n	6b22 <tcp_receive+0x5e6>
    6acc:	692b      	ldr	r3, [r5, #16]
    6ace:	685a      	ldr	r2, [r3, #4]
    6ad0:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    6ad2:	428a      	cmp	r2, r1
    6ad4:	d125      	bne.n	6b22 <tcp_receive+0x5e6>
					seqno = pcb->ooseq->tcphdr->seqno;
    6ad6:	607a      	str	r2, [r7, #4]
					pcb->rcv_nxt += TCP_TCPLEN(cseg);
    6ad8:	f8b5 9008 	ldrh.w	r9, [r5, #8]
    6adc:	8998      	ldrh	r0, [r3, #12]
    6ade:	47b0      	blx	r6
    6ae0:	f010 0003 	ands.w	r0, r0, #3
    6ae4:	bf18      	it	ne
    6ae6:	2001      	movne	r0, #1
    6ae8:	4448      	add	r0, r9
    6aea:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    6aec:	4418      	add	r0, r3
    6aee:	62a0      	str	r0, [r4, #40]	; 0x28
					pcb->rcv_wnd -= TCP_TCPLEN(cseg);
    6af0:	f8b5 9008 	ldrh.w	r9, [r5, #8]
    6af4:	692b      	ldr	r3, [r5, #16]
    6af6:	8998      	ldrh	r0, [r3, #12]
    6af8:	47b0      	blx	r6
    6afa:	f010 0003 	ands.w	r0, r0, #3
    6afe:	bf18      	it	ne
    6b00:	2001      	movne	r0, #1
    6b02:	4448      	add	r0, r9
    6b04:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    6b06:	1a18      	subs	r0, r3, r0
    6b08:	85a0      	strh	r0, [r4, #44]	; 0x2c
					tcp_update_rcv_ann_wnd(pcb);
    6b0a:	4620      	mov	r0, r4
    6b0c:	47c0      	blx	r8
					if (cseg->p->tot_len > 0) {
    6b0e:	6869      	ldr	r1, [r5, #4]
    6b10:	890b      	ldrh	r3, [r1, #8]
    6b12:	2b00      	cmp	r3, #0
    6b14:	d0c1      	beq.n	6a9a <tcp_receive+0x55e>
						if (recv_data) {
    6b16:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    6b18:	2800      	cmp	r0, #0
    6b1a:	d0bb      	beq.n	6a94 <tcp_receive+0x558>
							pbuf_cat(recv_data, cseg->p);
    6b1c:	4b84      	ldr	r3, [pc, #528]	; (6d30 <tcp_receive+0x7f4>)
    6b1e:	4798      	blx	r3
    6b20:	e7b9      	b.n	6a96 <tcp_receive+0x55a>
				tcp_ack(pcb);
    6b22:	7fa3      	ldrb	r3, [r4, #30]
    6b24:	f013 0f01 	tst.w	r3, #1
    6b28:	bf1a      	itte	ne
    6b2a:	f023 0301 	bicne.w	r3, r3, #1
    6b2e:	f043 0302 	orrne.w	r3, r3, #2
    6b32:	f043 0301 	orreq.w	r3, r3, #1
    6b36:	77a3      	strb	r3, [r4, #30]
    6b38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					pcb->ooseq = tcp_seg_copy(&inseg);
    6b3c:	487d      	ldr	r0, [pc, #500]	; (6d34 <tcp_receive+0x7f8>)
    6b3e:	4b7e      	ldr	r3, [pc, #504]	; (6d38 <tcp_receive+0x7fc>)
    6b40:	4798      	blx	r3
    6b42:	6760      	str	r0, [r4, #116]	; 0x74
    6b44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						if (seqno == next->tcphdr->seqno) {
    6b48:	4635      	mov	r5, r6
    6b4a:	2600      	movs	r6, #0
							if (inseg.len > next->len) {
    6b4c:	4b7b      	ldr	r3, [pc, #492]	; (6d3c <tcp_receive+0x800>)
    6b4e:	8b9a      	ldrh	r2, [r3, #28]
    6b50:	892b      	ldrh	r3, [r5, #8]
    6b52:	429a      	cmp	r2, r3
    6b54:	d94f      	bls.n	6bf6 <tcp_receive+0x6ba>
								cseg = tcp_seg_copy(&inseg);
    6b56:	4877      	ldr	r0, [pc, #476]	; (6d34 <tcp_receive+0x7f8>)
    6b58:	4b77      	ldr	r3, [pc, #476]	; (6d38 <tcp_receive+0x7fc>)
    6b5a:	4798      	blx	r3
								if (cseg != NULL) {
    6b5c:	4603      	mov	r3, r0
    6b5e:	2800      	cmp	r0, #0
    6b60:	d049      	beq.n	6bf6 <tcp_receive+0x6ba>
									if (prev != NULL) {
    6b62:	b136      	cbz	r6, 6b72 <tcp_receive+0x636>
										prev->next = cseg;
    6b64:	6030      	str	r0, [r6, #0]
									tcp_oos_insert_segment(cseg, next);
    6b66:	4629      	mov	r1, r5
    6b68:	4618      	mov	r0, r3
    6b6a:	4b75      	ldr	r3, [pc, #468]	; (6d40 <tcp_receive+0x804>)
    6b6c:	4798      	blx	r3
    6b6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
										pcb->ooseq = cseg;
    6b72:	6760      	str	r0, [r4, #116]	; 0x74
    6b74:	e7f7      	b.n	6b66 <tcp_receive+0x62a>
								if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
    6b76:	1a83      	subs	r3, r0, r2
    6b78:	2b00      	cmp	r3, #0
    6b7a:	db2f      	blt.n	6bdc <tcp_receive+0x6a0>
							if (next->next == NULL && TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    6b7c:	6835      	ldr	r5, [r6, #0]
    6b7e:	2d00      	cmp	r5, #0
    6b80:	d036      	beq.n	6bf0 <tcp_receive+0x6b4>
						if (seqno == next->tcphdr->seqno) {
    6b82:	6929      	ldr	r1, [r5, #16]
    6b84:	684a      	ldr	r2, [r1, #4]
    6b86:	4637      	mov	r7, r6
    6b88:	4282      	cmp	r2, r0
    6b8a:	d0df      	beq.n	6b4c <tcp_receive+0x610>
							if (next->next == NULL && TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    6b8c:	462e      	mov	r6, r5
							if (prev == NULL) {
    6b8e:	2f00      	cmp	r7, #0
    6b90:	d0f1      	beq.n	6b76 <tcp_receive+0x63a>
								if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
    6b92:	693b      	ldr	r3, [r7, #16]
    6b94:	685b      	ldr	r3, [r3, #4]
    6b96:	ebae 0303 	sub.w	r3, lr, r3
    6b9a:	2b00      	cmp	r3, #0
    6b9c:	dbee      	blt.n	6b7c <tcp_receive+0x640>
    6b9e:	ebac 0302 	sub.w	r3, ip, r2
    6ba2:	2b00      	cmp	r3, #0
    6ba4:	dcea      	bgt.n	6b7c <tcp_receive+0x640>
									cseg = tcp_seg_copy(&inseg);
    6ba6:	4863      	ldr	r0, [pc, #396]	; (6d34 <tcp_receive+0x7f8>)
    6ba8:	4b63      	ldr	r3, [pc, #396]	; (6d38 <tcp_receive+0x7fc>)
    6baa:	4798      	blx	r3
									if (cseg != NULL) {
    6bac:	4604      	mov	r4, r0
    6bae:	b310      	cbz	r0, 6bf6 <tcp_receive+0x6ba>
										if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
    6bb0:	693b      	ldr	r3, [r7, #16]
    6bb2:	6859      	ldr	r1, [r3, #4]
    6bb4:	4b61      	ldr	r3, [pc, #388]	; (6d3c <tcp_receive+0x800>)
    6bb6:	685b      	ldr	r3, [r3, #4]
    6bb8:	893a      	ldrh	r2, [r7, #8]
    6bba:	440a      	add	r2, r1
    6bbc:	1ad2      	subs	r2, r2, r3
    6bbe:	2a00      	cmp	r2, #0
    6bc0:	dd05      	ble.n	6bce <tcp_receive+0x692>
											prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
    6bc2:	1a5b      	subs	r3, r3, r1
    6bc4:	b299      	uxth	r1, r3
    6bc6:	8139      	strh	r1, [r7, #8]
											pbuf_realloc(prev->p, prev->len);
    6bc8:	6878      	ldr	r0, [r7, #4]
    6bca:	4b5e      	ldr	r3, [pc, #376]	; (6d44 <tcp_receive+0x808>)
    6bcc:	4798      	blx	r3
										prev->next = cseg;
    6bce:	603c      	str	r4, [r7, #0]
										tcp_oos_insert_segment(cseg, next);
    6bd0:	4631      	mov	r1, r6
    6bd2:	4620      	mov	r0, r4
    6bd4:	4b5a      	ldr	r3, [pc, #360]	; (6d40 <tcp_receive+0x804>)
    6bd6:	4798      	blx	r3
    6bd8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
									cseg = tcp_seg_copy(&inseg);
    6bdc:	4855      	ldr	r0, [pc, #340]	; (6d34 <tcp_receive+0x7f8>)
    6bde:	4b56      	ldr	r3, [pc, #344]	; (6d38 <tcp_receive+0x7fc>)
    6be0:	4798      	blx	r3
									if (cseg != NULL) {
    6be2:	b140      	cbz	r0, 6bf6 <tcp_receive+0x6ba>
										pcb->ooseq = cseg;
    6be4:	6760      	str	r0, [r4, #116]	; 0x74
										tcp_oos_insert_segment(cseg, next);
    6be6:	4631      	mov	r1, r6
    6be8:	4b55      	ldr	r3, [pc, #340]	; (6d40 <tcp_receive+0x804>)
    6bea:	4798      	blx	r3
    6bec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
							if (next->next == NULL && TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    6bf0:	1a82      	subs	r2, r0, r2
    6bf2:	2a00      	cmp	r2, #0
    6bf4:	dc01      	bgt.n	6bfa <tcp_receive+0x6be>
    6bf6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
								if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    6bfa:	8988      	ldrh	r0, [r1, #12]
    6bfc:	4b52      	ldr	r3, [pc, #328]	; (6d48 <tcp_receive+0x80c>)
    6bfe:	4798      	blx	r3
    6c00:	f010 0f01 	tst.w	r0, #1
    6c04:	d1f7      	bne.n	6bf6 <tcp_receive+0x6ba>
								next->next = tcp_seg_copy(&inseg);
    6c06:	484b      	ldr	r0, [pc, #300]	; (6d34 <tcp_receive+0x7f8>)
    6c08:	4b4b      	ldr	r3, [pc, #300]	; (6d38 <tcp_receive+0x7fc>)
    6c0a:	4798      	blx	r3
    6c0c:	6030      	str	r0, [r6, #0]
								if (next->next != NULL) {
    6c0e:	2800      	cmp	r0, #0
    6c10:	d0f1      	beq.n	6bf6 <tcp_receive+0x6ba>
									if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
    6c12:	6933      	ldr	r3, [r6, #16]
    6c14:	6859      	ldr	r1, [r3, #4]
    6c16:	4b49      	ldr	r3, [pc, #292]	; (6d3c <tcp_receive+0x800>)
    6c18:	685b      	ldr	r3, [r3, #4]
    6c1a:	8932      	ldrh	r2, [r6, #8]
    6c1c:	440a      	add	r2, r1
    6c1e:	1ad2      	subs	r2, r2, r3
    6c20:	2a00      	cmp	r2, #0
    6c22:	dd05      	ble.n	6c30 <tcp_receive+0x6f4>
										next->len = (u16_t)(seqno - next->tcphdr->seqno);
    6c24:	1a5b      	subs	r3, r3, r1
    6c26:	b299      	uxth	r1, r3
    6c28:	8131      	strh	r1, [r6, #8]
										pbuf_realloc(next->p, next->len);
    6c2a:	6870      	ldr	r0, [r6, #4]
    6c2c:	4b45      	ldr	r3, [pc, #276]	; (6d44 <tcp_receive+0x808>)
    6c2e:	4798      	blx	r3
									if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
    6c30:	4b42      	ldr	r3, [pc, #264]	; (6d3c <tcp_receive+0x800>)
    6c32:	8a1a      	ldrh	r2, [r3, #16]
    6c34:	685b      	ldr	r3, [r3, #4]
    6c36:	441a      	add	r2, r3
    6c38:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    6c3a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    6c3c:	440b      	add	r3, r1
    6c3e:	429a      	cmp	r2, r3
    6c40:	d9d9      	bls.n	6bf6 <tcp_receive+0x6ba>
										if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
    6c42:	6833      	ldr	r3, [r6, #0]
    6c44:	691b      	ldr	r3, [r3, #16]
    6c46:	8998      	ldrh	r0, [r3, #12]
    6c48:	4b3f      	ldr	r3, [pc, #252]	; (6d48 <tcp_receive+0x80c>)
    6c4a:	4798      	blx	r3
    6c4c:	f010 0f01 	tst.w	r0, #1
    6c50:	d11a      	bne.n	6c88 <tcp_receive+0x74c>
										next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    6c52:	6832      	ldr	r2, [r6, #0]
    6c54:	4d39      	ldr	r5, [pc, #228]	; (6d3c <tcp_receive+0x800>)
    6c56:	6869      	ldr	r1, [r5, #4]
    6c58:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    6c5a:	1a5b      	subs	r3, r3, r1
    6c5c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    6c5e:	440b      	add	r3, r1
    6c60:	8113      	strh	r3, [r2, #8]
										pbuf_realloc(next->next->p, next->next->len);
    6c62:	6833      	ldr	r3, [r6, #0]
    6c64:	8919      	ldrh	r1, [r3, #8]
    6c66:	6858      	ldr	r0, [r3, #4]
    6c68:	4b36      	ldr	r3, [pc, #216]	; (6d44 <tcp_receive+0x808>)
    6c6a:	4798      	blx	r3
										tcplen = TCP_TCPLEN(next->next);
    6c6c:	6833      	ldr	r3, [r6, #0]
    6c6e:	891c      	ldrh	r4, [r3, #8]
    6c70:	691b      	ldr	r3, [r3, #16]
    6c72:	8998      	ldrh	r0, [r3, #12]
    6c74:	4b34      	ldr	r3, [pc, #208]	; (6d48 <tcp_receive+0x80c>)
    6c76:	4798      	blx	r3
    6c78:	f010 0003 	ands.w	r0, r0, #3
    6c7c:	bf18      	it	ne
    6c7e:	2001      	movne	r0, #1
    6c80:	4404      	add	r4, r0
    6c82:	822c      	strh	r4, [r5, #16]
    6c84:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
											TCPH_FLAGS_SET(next->next->tcphdr,
    6c88:	6833      	ldr	r3, [r6, #0]
    6c8a:	691f      	ldr	r7, [r3, #16]
    6c8c:	89bd      	ldrh	r5, [r7, #12]
    6c8e:	4628      	mov	r0, r5
    6c90:	4b2d      	ldr	r3, [pc, #180]	; (6d48 <tcp_receive+0x80c>)
    6c92:	4798      	blx	r3
    6c94:	f000 003e 	and.w	r0, r0, #62	; 0x3e
    6c98:	4b2c      	ldr	r3, [pc, #176]	; (6d4c <tcp_receive+0x810>)
    6c9a:	4798      	blx	r3
    6c9c:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
    6ca0:	4305      	orrs	r5, r0
    6ca2:	81bd      	strh	r5, [r7, #12]
    6ca4:	e7d5      	b.n	6c52 <tcp_receive+0x716>
		if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
    6ca6:	4b25      	ldr	r3, [pc, #148]	; (6d3c <tcp_receive+0x800>)
    6ca8:	685b      	ldr	r3, [r3, #4]
    6caa:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    6cac:	1a99      	subs	r1, r3, r2
    6cae:	2900      	cmp	r1, #0
    6cb0:	db05      	blt.n	6cbe <tcp_receive+0x782>
    6cb2:	3301      	adds	r3, #1
    6cb4:	1a9b      	subs	r3, r3, r2
    6cb6:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    6cb8:	1a9b      	subs	r3, r3, r2
    6cba:	2b00      	cmp	r3, #0
    6cbc:	dd9b      	ble.n	6bf6 <tcp_receive+0x6ba>
			tcp_ack_now(pcb);
    6cbe:	7fa3      	ldrb	r3, [r4, #30]
    6cc0:	f043 0302 	orr.w	r3, r3, #2
    6cc4:	77a3      	strb	r3, [r4, #30]
}
    6cc6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
							next = next->next;
    6cca:	2500      	movs	r5, #0
						pcb->ooseq = next;
    6ccc:	6765      	str	r5, [r4, #116]	; 0x74
				pcb->rcv_nxt = seqno + tcplen;
    6cce:	4d1b      	ldr	r5, [pc, #108]	; (6d3c <tcp_receive+0x800>)
    6cd0:	8a2a      	ldrh	r2, [r5, #16]
    6cd2:	686b      	ldr	r3, [r5, #4]
    6cd4:	4413      	add	r3, r2
    6cd6:	62a3      	str	r3, [r4, #40]	; 0x28
				pcb->rcv_wnd -= tcplen;
    6cd8:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    6cda:	1a9b      	subs	r3, r3, r2
    6cdc:	85a3      	strh	r3, [r4, #44]	; 0x2c
				tcp_update_rcv_ann_wnd(pcb);
    6cde:	4620      	mov	r0, r4
    6ce0:	4b1b      	ldr	r3, [pc, #108]	; (6d50 <tcp_receive+0x814>)
    6ce2:	4798      	blx	r3
				if (inseg.p->tot_len > 0) {
    6ce4:	69ab      	ldr	r3, [r5, #24]
    6ce6:	891a      	ldrh	r2, [r3, #8]
    6ce8:	b112      	cbz	r2, 6cf0 <tcp_receive+0x7b4>
					recv_data = inseg.p;
    6cea:	62ab      	str	r3, [r5, #40]	; 0x28
					inseg.p = NULL;
    6cec:	2300      	movs	r3, #0
    6cee:	61ab      	str	r3, [r5, #24]
				if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    6cf0:	4b12      	ldr	r3, [pc, #72]	; (6d3c <tcp_receive+0x800>)
    6cf2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6cf4:	8998      	ldrh	r0, [r3, #12]
    6cf6:	4b14      	ldr	r3, [pc, #80]	; (6d48 <tcp_receive+0x80c>)
    6cf8:	4798      	blx	r3
    6cfa:	f010 0f01 	tst.w	r0, #1
    6cfe:	d006      	beq.n	6d0e <tcp_receive+0x7d2>
					recv_flags |= TF_GOT_FIN;
    6d00:	4a0e      	ldr	r2, [pc, #56]	; (6d3c <tcp_receive+0x800>)
    6d02:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
    6d06:	f043 0320 	orr.w	r3, r3, #32
    6d0a:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
				while (pcb->ooseq != NULL && pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    6d0e:	6f65      	ldr	r5, [r4, #116]	; 0x74
    6d10:	2d00      	cmp	r5, #0
    6d12:	f43f af06 	beq.w	6b22 <tcp_receive+0x5e6>
    6d16:	692b      	ldr	r3, [r5, #16]
    6d18:	685a      	ldr	r2, [r3, #4]
    6d1a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    6d1c:	428a      	cmp	r2, r1
    6d1e:	f47f af00 	bne.w	6b22 <tcp_receive+0x5e6>
					seqno = pcb->ooseq->tcphdr->seqno;
    6d22:	4f06      	ldr	r7, [pc, #24]	; (6d3c <tcp_receive+0x800>)
					pcb->rcv_nxt += TCP_TCPLEN(cseg);
    6d24:	4e08      	ldr	r6, [pc, #32]	; (6d48 <tcp_receive+0x80c>)
					tcp_update_rcv_ann_wnd(pcb);
    6d26:	f8df 8028 	ldr.w	r8, [pc, #40]	; 6d50 <tcp_receive+0x814>
    6d2a:	e6d4      	b.n	6ad6 <tcp_receive+0x59a>
    6d2c:	000059e9 	.word	0x000059e9
    6d30:	000056ed 	.word	0x000056ed
    6d34:	20007fb0 	.word	0x20007fb0
    6d38:	00005a29 	.word	0x00005a29
    6d3c:	20007f9c 	.word	0x20007f9c
    6d40:	0000646d 	.word	0x0000646d
    6d44:	0000566d 	.word	0x0000566d
    6d48:	000026ef 	.word	0x000026ef
    6d4c:	000026e5 	.word	0x000026e5
    6d50:	0000596b 	.word	0x0000596b
						next = pcb->ooseq;
    6d54:	464d      	mov	r5, r9
						if (next && TCP_SEQ_GT(seqno + tcplen, next->tcphdr->seqno)) {
    6d56:	4b14      	ldr	r3, [pc, #80]	; (6da8 <tcp_receive+0x86c>)
    6d58:	6859      	ldr	r1, [r3, #4]
    6d5a:	692a      	ldr	r2, [r5, #16]
    6d5c:	6852      	ldr	r2, [r2, #4]
    6d5e:	8a1b      	ldrh	r3, [r3, #16]
    6d60:	440b      	add	r3, r1
    6d62:	1a9b      	subs	r3, r3, r2
    6d64:	2b00      	cmp	r3, #0
    6d66:	ddb1      	ble.n	6ccc <tcp_receive+0x790>
							inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
    6d68:	4b0f      	ldr	r3, [pc, #60]	; (6da8 <tcp_receive+0x86c>)
    6d6a:	1a52      	subs	r2, r2, r1
    6d6c:	839a      	strh	r2, [r3, #28]
							if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    6d6e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6d70:	8998      	ldrh	r0, [r3, #12]
    6d72:	4b0e      	ldr	r3, [pc, #56]	; (6dac <tcp_receive+0x870>)
    6d74:	4798      	blx	r3
    6d76:	f010 0f02 	tst.w	r0, #2
    6d7a:	d003      	beq.n	6d84 <tcp_receive+0x848>
								inseg.len -= 1;
    6d7c:	4a0a      	ldr	r2, [pc, #40]	; (6da8 <tcp_receive+0x86c>)
    6d7e:	8b93      	ldrh	r3, [r2, #28]
    6d80:	3b01      	subs	r3, #1
    6d82:	8393      	strh	r3, [r2, #28]
							pbuf_realloc(inseg.p, inseg.len);
    6d84:	4e08      	ldr	r6, [pc, #32]	; (6da8 <tcp_receive+0x86c>)
    6d86:	8bb1      	ldrh	r1, [r6, #28]
    6d88:	69b0      	ldr	r0, [r6, #24]
    6d8a:	4b09      	ldr	r3, [pc, #36]	; (6db0 <tcp_receive+0x874>)
    6d8c:	4798      	blx	r3
							tcplen = TCP_TCPLEN(&inseg);
    6d8e:	8bb7      	ldrh	r7, [r6, #28]
    6d90:	6a73      	ldr	r3, [r6, #36]	; 0x24
    6d92:	8998      	ldrh	r0, [r3, #12]
    6d94:	4b05      	ldr	r3, [pc, #20]	; (6dac <tcp_receive+0x870>)
    6d96:	4798      	blx	r3
    6d98:	f010 0003 	ands.w	r0, r0, #3
    6d9c:	bf18      	it	ne
    6d9e:	2001      	movne	r0, #1
    6da0:	4407      	add	r7, r0
    6da2:	8237      	strh	r7, [r6, #16]
    6da4:	e792      	b.n	6ccc <tcp_receive+0x790>
    6da6:	bf00      	nop
    6da8:	20007f9c 	.word	0x20007f9c
    6dac:	000026ef 	.word	0x000026ef
    6db0:	0000566d 	.word	0x0000566d

00006db4 <tcp_input>:
{
    6db4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6db8:	b083      	sub	sp, #12
    6dba:	4604      	mov	r4, r0
    6dbc:	460d      	mov	r5, r1
	iphdr  = (struct ip_hdr *)p->payload;
    6dbe:	6843      	ldr	r3, [r0, #4]
    6dc0:	7819      	ldrb	r1, [r3, #0]
    6dc2:	f001 010f 	and.w	r1, r1, #15
	tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    6dc6:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    6dca:	4a99      	ldr	r2, [pc, #612]	; (7030 <tcp_input+0x27c>)
    6dcc:	6013      	str	r3, [r2, #0]
	if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    6dce:	0089      	lsls	r1, r1, #2
    6dd0:	4249      	negs	r1, r1
    6dd2:	4b98      	ldr	r3, [pc, #608]	; (7034 <tcp_input+0x280>)
    6dd4:	4798      	blx	r3
    6dd6:	b910      	cbnz	r0, 6dde <tcp_input+0x2a>
    6dd8:	8923      	ldrh	r3, [r4, #8]
    6dda:	2b13      	cmp	r3, #19
    6ddc:	d805      	bhi.n	6dea <tcp_input+0x36>
	pbuf_free(p);
    6dde:	4620      	mov	r0, r4
    6de0:	4b95      	ldr	r3, [pc, #596]	; (7038 <tcp_input+0x284>)
    6de2:	4798      	blx	r3
}
    6de4:	b003      	add	sp, #12
    6de6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (ip_addr_isbroadcast(&current_iphdr_dest, inp) || ip_addr_ismulticast(&current_iphdr_dest)) {
    6dea:	4629      	mov	r1, r5
    6dec:	4b93      	ldr	r3, [pc, #588]	; (703c <tcp_input+0x288>)
    6dee:	6818      	ldr	r0, [r3, #0]
    6df0:	4b93      	ldr	r3, [pc, #588]	; (7040 <tcp_input+0x28c>)
    6df2:	4798      	blx	r3
    6df4:	2800      	cmp	r0, #0
    6df6:	d1f2      	bne.n	6dde <tcp_input+0x2a>
    6df8:	4b90      	ldr	r3, [pc, #576]	; (703c <tcp_input+0x288>)
    6dfa:	681b      	ldr	r3, [r3, #0]
    6dfc:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    6e00:	2be0      	cmp	r3, #224	; 0xe0
    6e02:	d0ec      	beq.n	6dde <tcp_input+0x2a>
	if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(), IP_PROTO_TCP, p->tot_len) != 0) {
    6e04:	8923      	ldrh	r3, [r4, #8]
    6e06:	9300      	str	r3, [sp, #0]
    6e08:	2306      	movs	r3, #6
    6e0a:	4a8c      	ldr	r2, [pc, #560]	; (703c <tcp_input+0x288>)
    6e0c:	498d      	ldr	r1, [pc, #564]	; (7044 <tcp_input+0x290>)
    6e0e:	4620      	mov	r0, r4
    6e10:	4d8d      	ldr	r5, [pc, #564]	; (7048 <tcp_input+0x294>)
    6e12:	47a8      	blx	r5
    6e14:	2800      	cmp	r0, #0
    6e16:	d1e2      	bne.n	6dde <tcp_input+0x2a>
	hdrlen = TCPH_HDRLEN(tcphdr);
    6e18:	4b85      	ldr	r3, [pc, #532]	; (7030 <tcp_input+0x27c>)
    6e1a:	681b      	ldr	r3, [r3, #0]
    6e1c:	8998      	ldrh	r0, [r3, #12]
    6e1e:	4b8b      	ldr	r3, [pc, #556]	; (704c <tcp_input+0x298>)
    6e20:	4798      	blx	r3
    6e22:	0b00      	lsrs	r0, r0, #12
	if (pbuf_header(p, -(hdrlen * 4))) {
    6e24:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
    6e28:	0081      	lsls	r1, r0, #2
    6e2a:	b209      	sxth	r1, r1
    6e2c:	4620      	mov	r0, r4
    6e2e:	4b81      	ldr	r3, [pc, #516]	; (7034 <tcp_input+0x280>)
    6e30:	4798      	blx	r3
    6e32:	2800      	cmp	r0, #0
    6e34:	d1d3      	bne.n	6dde <tcp_input+0x2a>
	tcphdr->src  = ntohs(tcphdr->src);
    6e36:	4d7e      	ldr	r5, [pc, #504]	; (7030 <tcp_input+0x27c>)
    6e38:	682f      	ldr	r7, [r5, #0]
    6e3a:	8838      	ldrh	r0, [r7, #0]
    6e3c:	4e83      	ldr	r6, [pc, #524]	; (704c <tcp_input+0x298>)
    6e3e:	47b0      	blx	r6
    6e40:	8038      	strh	r0, [r7, #0]
	tcphdr->dest = ntohs(tcphdr->dest);
    6e42:	682f      	ldr	r7, [r5, #0]
    6e44:	8878      	ldrh	r0, [r7, #2]
    6e46:	47b0      	blx	r6
    6e48:	8078      	strh	r0, [r7, #2]
	seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    6e4a:	682f      	ldr	r7, [r5, #0]
    6e4c:	6878      	ldr	r0, [r7, #4]
    6e4e:	f8df 8224 	ldr.w	r8, [pc, #548]	; 7074 <tcp_input+0x2c0>
    6e52:	47c0      	blx	r8
    6e54:	6078      	str	r0, [r7, #4]
    6e56:	6068      	str	r0, [r5, #4]
	ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    6e58:	682f      	ldr	r7, [r5, #0]
    6e5a:	68b8      	ldr	r0, [r7, #8]
    6e5c:	47c0      	blx	r8
    6e5e:	60b8      	str	r0, [r7, #8]
    6e60:	60e8      	str	r0, [r5, #12]
	tcphdr->wnd           = ntohs(tcphdr->wnd);
    6e62:	682f      	ldr	r7, [r5, #0]
    6e64:	89f8      	ldrh	r0, [r7, #14]
    6e66:	47b0      	blx	r6
    6e68:	81f8      	strh	r0, [r7, #14]
	flags  = TCPH_FLAGS(tcphdr);
    6e6a:	682b      	ldr	r3, [r5, #0]
    6e6c:	8998      	ldrh	r0, [r3, #12]
    6e6e:	47b0      	blx	r6
    6e70:	fa5f fe80 	uxtb.w	lr, r0
    6e74:	f00e 033f 	and.w	r3, lr, #63	; 0x3f
    6e78:	722b      	strb	r3, [r5, #8]
	tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    6e7a:	f01e 0303 	ands.w	r3, lr, #3
    6e7e:	bf18      	it	ne
    6e80:	2301      	movne	r3, #1
    6e82:	8921      	ldrh	r1, [r4, #8]
    6e84:	440b      	add	r3, r1
    6e86:	b299      	uxth	r1, r3
    6e88:	8229      	strh	r1, [r5, #16]
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    6e8a:	4b71      	ldr	r3, [pc, #452]	; (7050 <tcp_input+0x29c>)
    6e8c:	6818      	ldr	r0, [r3, #0]
    6e8e:	2800      	cmp	r0, #0
    6e90:	f000 8084 	beq.w	6f9c <tcp_input+0x1e8>
		if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    6e94:	682f      	ldr	r7, [r5, #0]
    6e96:	883e      	ldrh	r6, [r7, #0]
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    6e98:	4b6a      	ldr	r3, [pc, #424]	; (7044 <tcp_input+0x290>)
    6e9a:	f8d3 c000 	ldr.w	ip, [r3]
		    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    6e9e:	4b67      	ldr	r3, [pc, #412]	; (703c <tcp_input+0x288>)
    6ea0:	f8d3 8000 	ldr.w	r8, [r3]
    6ea4:	4605      	mov	r5, r0
    6ea6:	2200      	movs	r2, #0
    6ea8:	e004      	b.n	6eb4 <tcp_input+0x100>
	for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    6eaa:	68eb      	ldr	r3, [r5, #12]
    6eac:	462a      	mov	r2, r5
    6eae:	2b00      	cmp	r3, #0
    6eb0:	d074      	beq.n	6f9c <tcp_input+0x1e8>
    6eb2:	461d      	mov	r5, r3
		if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    6eb4:	8bab      	ldrh	r3, [r5, #28]
    6eb6:	42b3      	cmp	r3, r6
    6eb8:	d1f7      	bne.n	6eaa <tcp_input+0xf6>
    6eba:	f8b5 901a 	ldrh.w	r9, [r5, #26]
    6ebe:	887b      	ldrh	r3, [r7, #2]
    6ec0:	4599      	cmp	r9, r3
    6ec2:	d1f2      	bne.n	6eaa <tcp_input+0xf6>
		    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    6ec4:	686b      	ldr	r3, [r5, #4]
    6ec6:	4563      	cmp	r3, ip
    6ec8:	d1ef      	bne.n	6eaa <tcp_input+0xf6>
		    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    6eca:	682b      	ldr	r3, [r5, #0]
    6ecc:	4543      	cmp	r3, r8
    6ece:	d1ec      	bne.n	6eaa <tcp_input+0xf6>
			if (prev != NULL) {
    6ed0:	b122      	cbz	r2, 6edc <tcp_input+0x128>
				prev->next      = pcb->next;
    6ed2:	68eb      	ldr	r3, [r5, #12]
    6ed4:	60d3      	str	r3, [r2, #12]
				pcb->next       = tcp_active_pcbs;
    6ed6:	60e8      	str	r0, [r5, #12]
				tcp_active_pcbs = pcb;
    6ed8:	4b5d      	ldr	r3, [pc, #372]	; (7050 <tcp_input+0x29c>)
    6eda:	601d      	str	r5, [r3, #0]
	if (pcb == NULL) {
    6edc:	2d00      	cmp	r5, #0
    6ede:	d05d      	beq.n	6f9c <tcp_input+0x1e8>
		inseg.next   = NULL;
    6ee0:	4b53      	ldr	r3, [pc, #332]	; (7030 <tcp_input+0x27c>)
    6ee2:	2200      	movs	r2, #0
    6ee4:	615a      	str	r2, [r3, #20]
		inseg.len    = p->tot_len;
    6ee6:	8921      	ldrh	r1, [r4, #8]
    6ee8:	8399      	strh	r1, [r3, #28]
		inseg.p      = p;
    6eea:	619c      	str	r4, [r3, #24]
		inseg.tcphdr = tcphdr;
    6eec:	625f      	str	r7, [r3, #36]	; 0x24
		recv_data  = NULL;
    6eee:	629a      	str	r2, [r3, #40]	; 0x28
		recv_flags = 0;
    6ef0:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
		if (flags & TCP_PSH) {
    6ef4:	f01e 0f08 	tst.w	lr, #8
    6ef8:	d003      	beq.n	6f02 <tcp_input+0x14e>
			p->flags |= PBUF_FLAG_PUSH;
    6efa:	7b63      	ldrb	r3, [r4, #13]
    6efc:	f043 0301 	orr.w	r3, r3, #1
    6f00:	7363      	strb	r3, [r4, #13]
		if (pcb->refused_data != NULL) {
    6f02:	6fab      	ldr	r3, [r5, #120]	; 0x78
    6f04:	b15b      	cbz	r3, 6f1e <tcp_input+0x16a>
			if ((tcp_process_refused_data(pcb) == ERR_ABRT) || ((pcb->refused_data != NULL) && (tcplen > 0))) {
    6f06:	4628      	mov	r0, r5
    6f08:	4b52      	ldr	r3, [pc, #328]	; (7054 <tcp_input+0x2a0>)
    6f0a:	4798      	blx	r3
    6f0c:	f110 0f0a 	cmn.w	r0, #10
    6f10:	d035      	beq.n	6f7e <tcp_input+0x1ca>
    6f12:	6fab      	ldr	r3, [r5, #120]	; 0x78
    6f14:	b11b      	cbz	r3, 6f1e <tcp_input+0x16a>
    6f16:	4b46      	ldr	r3, [pc, #280]	; (7030 <tcp_input+0x27c>)
    6f18:	8a1b      	ldrh	r3, [r3, #16]
    6f1a:	2b00      	cmp	r3, #0
    6f1c:	d12f      	bne.n	6f7e <tcp_input+0x1ca>
		tcp_input_pcb = pcb;
    6f1e:	4b4e      	ldr	r3, [pc, #312]	; (7058 <tcp_input+0x2a4>)
    6f20:	601d      	str	r5, [r3, #0]
	if (flags & TCP_RST) {
    6f22:	4b43      	ldr	r3, [pc, #268]	; (7030 <tcp_input+0x27c>)
    6f24:	7a1b      	ldrb	r3, [r3, #8]
    6f26:	f013 0f04 	tst.w	r3, #4
    6f2a:	f000 8144 	beq.w	71b6 <tcp_input+0x402>
		if (pcb->state == SYN_SENT) {
    6f2e:	7e2b      	ldrb	r3, [r5, #24]
    6f30:	2b02      	cmp	r3, #2
    6f32:	f000 812c 	beq.w	718e <tcp_input+0x3da>
			if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
    6f36:	4b3e      	ldr	r3, [pc, #248]	; (7030 <tcp_input+0x27c>)
    6f38:	685b      	ldr	r3, [r3, #4]
    6f3a:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    6f3c:	1a9b      	subs	r3, r3, r2
    6f3e:	d408      	bmi.n	6f52 <tcp_input+0x19e>
    6f40:	8daa      	ldrh	r2, [r5, #44]	; 0x2c
    6f42:	1a9b      	subs	r3, r3, r2
	u8_t            acceptable = 0;
    6f44:	2b00      	cmp	r3, #0
    6f46:	bfcc      	ite	gt
    6f48:	2300      	movgt	r3, #0
    6f4a:	2301      	movle	r3, #1
		if (acceptable) {
    6f4c:	2b00      	cmp	r3, #0
    6f4e:	f040 8126 	bne.w	719e <tcp_input+0x3ea>
			if (recv_flags & TF_RESET) {
    6f52:	4b37      	ldr	r3, [pc, #220]	; (7030 <tcp_input+0x27c>)
    6f54:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    6f58:	f013 0f08 	tst.w	r3, #8
    6f5c:	f000 835d 	beq.w	761a <tcp_input+0x866>
				TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
    6f60:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    6f64:	b11b      	cbz	r3, 6f6e <tcp_input+0x1ba>
    6f66:	f06f 010a 	mvn.w	r1, #10
    6f6a:	6928      	ldr	r0, [r5, #16]
    6f6c:	4798      	blx	r3
				tcp_pcb_remove(&tcp_active_pcbs, pcb);
    6f6e:	4629      	mov	r1, r5
    6f70:	4837      	ldr	r0, [pc, #220]	; (7050 <tcp_input+0x29c>)
    6f72:	4b3a      	ldr	r3, [pc, #232]	; (705c <tcp_input+0x2a8>)
    6f74:	4798      	blx	r3
				memp_free(MEMP_TCP_PCB, pcb);
    6f76:	4629      	mov	r1, r5
    6f78:	2002      	movs	r0, #2
    6f7a:	4b39      	ldr	r3, [pc, #228]	; (7060 <tcp_input+0x2ac>)
    6f7c:	4798      	blx	r3
		tcp_input_pcb = NULL;
    6f7e:	2200      	movs	r2, #0
    6f80:	4b35      	ldr	r3, [pc, #212]	; (7058 <tcp_input+0x2a4>)
    6f82:	601a      	str	r2, [r3, #0]
		recv_data     = NULL;
    6f84:	4b2a      	ldr	r3, [pc, #168]	; (7030 <tcp_input+0x27c>)
    6f86:	629a      	str	r2, [r3, #40]	; 0x28
		if (inseg.p != NULL) {
    6f88:	6998      	ldr	r0, [r3, #24]
    6f8a:	2800      	cmp	r0, #0
    6f8c:	f43f af2a 	beq.w	6de4 <tcp_input+0x30>
			pbuf_free(inseg.p);
    6f90:	4b29      	ldr	r3, [pc, #164]	; (7038 <tcp_input+0x284>)
    6f92:	4798      	blx	r3
			inseg.p = NULL;
    6f94:	2200      	movs	r2, #0
    6f96:	4b26      	ldr	r3, [pc, #152]	; (7030 <tcp_input+0x27c>)
    6f98:	619a      	str	r2, [r3, #24]
    6f9a:	e723      	b.n	6de4 <tcp_input+0x30>
		for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    6f9c:	4b31      	ldr	r3, [pc, #196]	; (7064 <tcp_input+0x2b0>)
    6f9e:	6818      	ldr	r0, [r3, #0]
    6fa0:	2800      	cmp	r0, #0
    6fa2:	d069      	beq.n	7078 <tcp_input+0x2c4>
			if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    6fa4:	4b22      	ldr	r3, [pc, #136]	; (7030 <tcp_input+0x27c>)
    6fa6:	681f      	ldr	r7, [r3, #0]
    6fa8:	883a      	ldrh	r2, [r7, #0]
			    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    6faa:	4b26      	ldr	r3, [pc, #152]	; (7044 <tcp_input+0x290>)
    6fac:	f8d3 8000 	ldr.w	r8, [r3]
			    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    6fb0:	4b22      	ldr	r3, [pc, #136]	; (703c <tcp_input+0x288>)
    6fb2:	f8d3 c000 	ldr.w	ip, [r3]
    6fb6:	e011      	b.n	6fdc <tcp_input+0x228>
	} else if (flags & TCP_FIN) {
    6fb8:	f01e 0f01 	tst.w	lr, #1
    6fbc:	d002      	beq.n	6fc4 <tcp_input+0x210>
		pcb->tmr = tcp_ticks;
    6fbe:	4b2a      	ldr	r3, [pc, #168]	; (7068 <tcp_input+0x2b4>)
    6fc0:	681b      	ldr	r3, [r3, #0]
    6fc2:	6243      	str	r3, [r0, #36]	; 0x24
	if ((tcplen > 0)) {
    6fc4:	2900      	cmp	r1, #0
    6fc6:	d02e      	beq.n	7026 <tcp_input+0x272>
		pcb->flags |= TF_ACK_NOW;
    6fc8:	7f83      	ldrb	r3, [r0, #30]
    6fca:	f043 0302 	orr.w	r3, r3, #2
    6fce:	7783      	strb	r3, [r0, #30]
		return tcp_output(pcb);
    6fd0:	4b26      	ldr	r3, [pc, #152]	; (706c <tcp_input+0x2b8>)
    6fd2:	4798      	blx	r3
    6fd4:	e027      	b.n	7026 <tcp_input+0x272>
		for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    6fd6:	68c0      	ldr	r0, [r0, #12]
    6fd8:	2800      	cmp	r0, #0
    6fda:	d04d      	beq.n	7078 <tcp_input+0x2c4>
			if (pcb->remote_port == tcphdr->src && pcb->local_port == tcphdr->dest
    6fdc:	8b83      	ldrh	r3, [r0, #28]
    6fde:	4293      	cmp	r3, r2
    6fe0:	d1f9      	bne.n	6fd6 <tcp_input+0x222>
    6fe2:	8b45      	ldrh	r5, [r0, #26]
    6fe4:	887e      	ldrh	r6, [r7, #2]
    6fe6:	42ae      	cmp	r6, r5
    6fe8:	d1f5      	bne.n	6fd6 <tcp_input+0x222>
			    && ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src)
    6fea:	6846      	ldr	r6, [r0, #4]
    6fec:	4546      	cmp	r6, r8
    6fee:	d1f2      	bne.n	6fd6 <tcp_input+0x222>
			    && ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    6ff0:	6806      	ldr	r6, [r0, #0]
    6ff2:	4566      	cmp	r6, ip
    6ff4:	d1ef      	bne.n	6fd6 <tcp_input+0x222>
	if (flags & TCP_RST) {
    6ff6:	f01e 0f04 	tst.w	lr, #4
    6ffa:	d114      	bne.n	7026 <tcp_input+0x272>
	if (flags & TCP_SYN) {
    6ffc:	f01e 0f02 	tst.w	lr, #2
    7000:	d0da      	beq.n	6fb8 <tcp_input+0x204>
		if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
    7002:	4a0b      	ldr	r2, [pc, #44]	; (7030 <tcp_input+0x27c>)
    7004:	6856      	ldr	r6, [r2, #4]
    7006:	6a82      	ldr	r2, [r0, #40]	; 0x28
    7008:	1ab2      	subs	r2, r6, r2
    700a:	d4db      	bmi.n	6fc4 <tcp_input+0x210>
    700c:	8d87      	ldrh	r7, [r0, #44]	; 0x2c
    700e:	1bd2      	subs	r2, r2, r7
    7010:	2a00      	cmp	r2, #0
    7012:	dcd7      	bgt.n	6fc4 <tcp_input+0x210>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    7014:	9301      	str	r3, [sp, #4]
    7016:	9500      	str	r5, [sp, #0]
    7018:	4b0a      	ldr	r3, [pc, #40]	; (7044 <tcp_input+0x290>)
    701a:	4a08      	ldr	r2, [pc, #32]	; (703c <tcp_input+0x288>)
    701c:	4431      	add	r1, r6
    701e:	4804      	ldr	r0, [pc, #16]	; (7030 <tcp_input+0x27c>)
    7020:	68c0      	ldr	r0, [r0, #12]
    7022:	4d13      	ldr	r5, [pc, #76]	; (7070 <tcp_input+0x2bc>)
    7024:	47a8      	blx	r5
				pbuf_free(p);
    7026:	4620      	mov	r0, r4
    7028:	4b03      	ldr	r3, [pc, #12]	; (7038 <tcp_input+0x284>)
    702a:	4798      	blx	r3
				return;
    702c:	e6da      	b.n	6de4 <tcp_input+0x30>
    702e:	bf00      	nop
    7030:	20007f9c 	.word	0x20007f9c
    7034:	00005435 	.word	0x00005435
    7038:	000054c9 	.word	0x000054c9
    703c:	20008314 	.word	0x20008314
    7040:	00004739 	.word	0x00004739
    7044:	2000830c 	.word	0x2000830c
    7048:	000042d1 	.word	0x000042d1
    704c:	000026ef 	.word	0x000026ef
    7050:	200092e0 	.word	0x200092e0
    7054:	000060a1 	.word	0x000060a1
    7058:	200092f8 	.word	0x200092f8
    705c:	00005e29 	.word	0x00005e29
    7060:	00005201 	.word	0x00005201
    7064:	200092f4 	.word	0x200092f4
    7068:	200092e4 	.word	0x200092e4
    706c:	00007a49 	.word	0x00007a49
    7070:	00007d1d 	.word	0x00007d1d
    7074:	00002711 	.word	0x00002711
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    7078:	4b9c      	ldr	r3, [pc, #624]	; (72ec <tcp_input+0x538>)
    707a:	f8d3 c000 	ldr.w	ip, [r3]
    707e:	f1bc 0f00 	cmp.w	ip, #0
    7082:	f000 8337 	beq.w	76f4 <tcp_input+0x940>
			if (lpcb->local_port == tcphdr->dest) {
    7086:	4b9a      	ldr	r3, [pc, #616]	; (72f0 <tcp_input+0x53c>)
    7088:	681f      	ldr	r7, [r3, #0]
    708a:	8878      	ldrh	r0, [r7, #2]
				if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) || ip_addr_isany(&(lpcb->local_ip))) {
    708c:	4b99      	ldr	r3, [pc, #612]	; (72f4 <tcp_input+0x540>)
    708e:	681e      	ldr	r6, [r3, #0]
    7090:	4665      	mov	r5, ip
    7092:	2200      	movs	r2, #0
    7094:	e005      	b.n	70a2 <tcp_input+0x2ee>
		for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    7096:	68eb      	ldr	r3, [r5, #12]
    7098:	462a      	mov	r2, r5
    709a:	2b00      	cmp	r3, #0
    709c:	f000 832a 	beq.w	76f4 <tcp_input+0x940>
    70a0:	461d      	mov	r5, r3
			if (lpcb->local_port == tcphdr->dest) {
    70a2:	8b6b      	ldrh	r3, [r5, #26]
    70a4:	4283      	cmp	r3, r0
    70a6:	d1f6      	bne.n	7096 <tcp_input+0x2e2>
				if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) || ip_addr_isany(&(lpcb->local_ip))) {
    70a8:	682b      	ldr	r3, [r5, #0]
    70aa:	42b3      	cmp	r3, r6
    70ac:	d002      	beq.n	70b4 <tcp_input+0x300>
    70ae:	b10d      	cbz	r5, 70b4 <tcp_input+0x300>
    70b0:	2b00      	cmp	r3, #0
    70b2:	d1f0      	bne.n	7096 <tcp_input+0x2e2>
		if (lpcb != NULL) {
    70b4:	2d00      	cmp	r5, #0
    70b6:	f000 831d 	beq.w	76f4 <tcp_input+0x940>
			if (prev != NULL) {
    70ba:	b12a      	cbz	r2, 70c8 <tcp_input+0x314>
				((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    70bc:	68eb      	ldr	r3, [r5, #12]
    70be:	60d3      	str	r3, [r2, #12]
				lpcb->next = tcp_listen_pcbs.listen_pcbs;
    70c0:	f8c5 c00c 	str.w	ip, [r5, #12]
				tcp_listen_pcbs.listen_pcbs = lpcb;
    70c4:	4b89      	ldr	r3, [pc, #548]	; (72ec <tcp_input+0x538>)
    70c6:	601d      	str	r5, [r3, #0]
	if (flags & TCP_RST) {
    70c8:	f01e 0f04 	tst.w	lr, #4
    70cc:	d105      	bne.n	70da <tcp_input+0x326>
	if (flags & TCP_ACK) {
    70ce:	f01e 0f10 	tst.w	lr, #16
    70d2:	d106      	bne.n	70e2 <tcp_input+0x32e>
	} else if (flags & TCP_SYN) {
    70d4:	f01e 0f02 	tst.w	lr, #2
    70d8:	d110      	bne.n	70fc <tcp_input+0x348>
			pbuf_free(p);
    70da:	4620      	mov	r0, r4
    70dc:	4b86      	ldr	r3, [pc, #536]	; (72f8 <tcp_input+0x544>)
    70de:	4798      	blx	r3
			return;
    70e0:	e680      	b.n	6de4 <tcp_input+0x30>
		tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    70e2:	4883      	ldr	r0, [pc, #524]	; (72f0 <tcp_input+0x53c>)
    70e4:	6845      	ldr	r5, [r0, #4]
    70e6:	883b      	ldrh	r3, [r7, #0]
    70e8:	9301      	str	r3, [sp, #4]
    70ea:	887b      	ldrh	r3, [r7, #2]
    70ec:	9300      	str	r3, [sp, #0]
    70ee:	4b83      	ldr	r3, [pc, #524]	; (72fc <tcp_input+0x548>)
    70f0:	4a80      	ldr	r2, [pc, #512]	; (72f4 <tcp_input+0x540>)
    70f2:	4429      	add	r1, r5
    70f4:	68c0      	ldr	r0, [r0, #12]
    70f6:	4d82      	ldr	r5, [pc, #520]	; (7300 <tcp_input+0x54c>)
    70f8:	47a8      	blx	r5
    70fa:	e7ee      	b.n	70da <tcp_input+0x326>
		npcb = tcp_alloc(pcb->prio);
    70fc:	7e68      	ldrb	r0, [r5, #25]
    70fe:	4b81      	ldr	r3, [pc, #516]	; (7304 <tcp_input+0x550>)
    7100:	4798      	blx	r3
		if (npcb == NULL) {
    7102:	4606      	mov	r6, r0
    7104:	2800      	cmp	r0, #0
    7106:	d0e8      	beq.n	70da <tcp_input+0x326>
		ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    7108:	4b7a      	ldr	r3, [pc, #488]	; (72f4 <tcp_input+0x540>)
    710a:	681b      	ldr	r3, [r3, #0]
    710c:	6003      	str	r3, [r0, #0]
		npcb->local_port = pcb->local_port;
    710e:	8b6b      	ldrh	r3, [r5, #26]
    7110:	8343      	strh	r3, [r0, #26]
		ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    7112:	4b7a      	ldr	r3, [pc, #488]	; (72fc <tcp_input+0x548>)
    7114:	681b      	ldr	r3, [r3, #0]
    7116:	6043      	str	r3, [r0, #4]
		npcb->remote_port        = tcphdr->src;
    7118:	4b75      	ldr	r3, [pc, #468]	; (72f0 <tcp_input+0x53c>)
    711a:	681a      	ldr	r2, [r3, #0]
    711c:	8811      	ldrh	r1, [r2, #0]
    711e:	8381      	strh	r1, [r0, #28]
		npcb->state              = SYN_RCVD;
    7120:	2103      	movs	r1, #3
    7122:	7601      	strb	r1, [r0, #24]
		npcb->rcv_nxt            = seqno + 1;
    7124:	685b      	ldr	r3, [r3, #4]
    7126:	1c59      	adds	r1, r3, #1
    7128:	6281      	str	r1, [r0, #40]	; 0x28
		npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    712a:	6301      	str	r1, [r0, #48]	; 0x30
		npcb->snd_wnd            = tcphdr->wnd;
    712c:	89d1      	ldrh	r1, [r2, #14]
    712e:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60
		npcb->snd_wnd_max        = tcphdr->wnd;
    7132:	89d2      	ldrh	r2, [r2, #14]
    7134:	f8a0 2062 	strh.w	r2, [r0, #98]	; 0x62
		npcb->ssthresh           = npcb->snd_wnd;
    7138:	f8a0 104e 	strh.w	r1, [r0, #78]	; 0x4e
		npcb->snd_wl1            = seqno - 1; /* initialise to seqno-1 to force window update */
    713c:	3b01      	subs	r3, #1
    713e:	6543      	str	r3, [r0, #84]	; 0x54
		npcb->callback_arg       = pcb->callback_arg;
    7140:	692b      	ldr	r3, [r5, #16]
    7142:	6103      	str	r3, [r0, #16]
		npcb->accept = pcb->accept;
    7144:	696b      	ldr	r3, [r5, #20]
    7146:	6143      	str	r3, [r0, #20]
		npcb->so_options = pcb->so_options & SOF_INHERITED;
    7148:	7a2b      	ldrb	r3, [r5, #8]
    714a:	f023 0373 	bic.w	r3, r3, #115	; 0x73
    714e:	7203      	strb	r3, [r0, #8]
		TCP_REG_ACTIVE(npcb);
    7150:	4b6d      	ldr	r3, [pc, #436]	; (7308 <tcp_input+0x554>)
    7152:	681a      	ldr	r2, [r3, #0]
    7154:	60c2      	str	r2, [r0, #12]
    7156:	6018      	str	r0, [r3, #0]
    7158:	4b6c      	ldr	r3, [pc, #432]	; (730c <tcp_input+0x558>)
    715a:	4798      	blx	r3
    715c:	2201      	movs	r2, #1
    715e:	4b6c      	ldr	r3, [pc, #432]	; (7310 <tcp_input+0x55c>)
    7160:	701a      	strb	r2, [r3, #0]
		tcp_parseopt(npcb);
    7162:	4630      	mov	r0, r6
    7164:	4b6b      	ldr	r3, [pc, #428]	; (7314 <tcp_input+0x560>)
    7166:	4798      	blx	r3
		npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    7168:	1d31      	adds	r1, r6, #4
    716a:	8ef0      	ldrh	r0, [r6, #54]	; 0x36
    716c:	4b6a      	ldr	r3, [pc, #424]	; (7318 <tcp_input+0x564>)
    716e:	4798      	blx	r3
    7170:	86f0      	strh	r0, [r6, #54]	; 0x36
		rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    7172:	2112      	movs	r1, #18
    7174:	4630      	mov	r0, r6
    7176:	4b69      	ldr	r3, [pc, #420]	; (731c <tcp_input+0x568>)
    7178:	4798      	blx	r3
		if (rc != ERR_OK) {
    717a:	b918      	cbnz	r0, 7184 <tcp_input+0x3d0>
		return tcp_output(npcb);
    717c:	4630      	mov	r0, r6
    717e:	4b68      	ldr	r3, [pc, #416]	; (7320 <tcp_input+0x56c>)
    7180:	4798      	blx	r3
    7182:	e7aa      	b.n	70da <tcp_input+0x326>
			tcp_abandon(npcb, 0);
    7184:	2100      	movs	r1, #0
    7186:	4630      	mov	r0, r6
    7188:	4b66      	ldr	r3, [pc, #408]	; (7324 <tcp_input+0x570>)
    718a:	4798      	blx	r3
    718c:	e7a5      	b.n	70da <tcp_input+0x326>
			if (ackno == pcb->snd_nxt) {
    718e:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    7190:	4a57      	ldr	r2, [pc, #348]	; (72f0 <tcp_input+0x53c>)
    7192:	68d2      	ldr	r2, [r2, #12]
	u8_t            acceptable = 0;
    7194:	4293      	cmp	r3, r2
    7196:	bf14      	ite	ne
    7198:	2300      	movne	r3, #0
    719a:	2301      	moveq	r3, #1
    719c:	e6d6      	b.n	6f4c <tcp_input+0x198>
			recv_flags |= TF_RESET;
    719e:	4a54      	ldr	r2, [pc, #336]	; (72f0 <tcp_input+0x53c>)
    71a0:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
    71a4:	f043 0308 	orr.w	r3, r3, #8
    71a8:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
			pcb->flags &= ~TF_ACK_DELAY;
    71ac:	7fab      	ldrb	r3, [r5, #30]
    71ae:	f023 0301 	bic.w	r3, r3, #1
    71b2:	77ab      	strb	r3, [r5, #30]
    71b4:	e6cd      	b.n	6f52 <tcp_input+0x19e>
	if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
    71b6:	f013 0f02 	tst.w	r3, #2
    71ba:	d009      	beq.n	71d0 <tcp_input+0x41c>
    71bc:	7e2b      	ldrb	r3, [r5, #24]
    71be:	3b02      	subs	r3, #2
    71c0:	b2db      	uxtb	r3, r3
    71c2:	2b01      	cmp	r3, #1
    71c4:	d904      	bls.n	71d0 <tcp_input+0x41c>
		tcp_ack_now(pcb);
    71c6:	7fab      	ldrb	r3, [r5, #30]
    71c8:	f043 0302 	orr.w	r3, r3, #2
    71cc:	77ab      	strb	r3, [r5, #30]
    71ce:	e6c0      	b.n	6f52 <tcp_input+0x19e>
	if ((pcb->flags & TF_RXCLOSED) == 0) {
    71d0:	7fab      	ldrb	r3, [r5, #30]
    71d2:	f013 0f10 	tst.w	r3, #16
    71d6:	d102      	bne.n	71de <tcp_input+0x42a>
		pcb->tmr = tcp_ticks;
    71d8:	4b53      	ldr	r3, [pc, #332]	; (7328 <tcp_input+0x574>)
    71da:	681b      	ldr	r3, [r3, #0]
    71dc:	626b      	str	r3, [r5, #36]	; 0x24
	pcb->keep_cnt_sent = 0;
    71de:	2300      	movs	r3, #0
    71e0:	f885 3096 	strb.w	r3, [r5, #150]	; 0x96
	tcp_parseopt(pcb);
    71e4:	4628      	mov	r0, r5
    71e6:	4b4b      	ldr	r3, [pc, #300]	; (7314 <tcp_input+0x560>)
    71e8:	4798      	blx	r3
	switch (pcb->state) {
    71ea:	7e2b      	ldrb	r3, [r5, #24]
    71ec:	3b02      	subs	r3, #2
    71ee:	2b07      	cmp	r3, #7
    71f0:	f63f aeaf 	bhi.w	6f52 <tcp_input+0x19e>
    71f4:	e8df f013 	tbh	[pc, r3, lsl #1]
    71f8:	009e0008 	.word	0x009e0008
    71fc:	010c00fb 	.word	0x010c00fb
    7200:	00fb0166 	.word	0x00fb0166
    7204:	01fa01a2 	.word	0x01fa01a2
		if ((flags & TCP_ACK) && (flags & TCP_SYN) && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    7208:	4b39      	ldr	r3, [pc, #228]	; (72f0 <tcp_input+0x53c>)
    720a:	7a1b      	ldrb	r3, [r3, #8]
    720c:	f003 0312 	and.w	r3, r3, #18
    7210:	2b12      	cmp	r3, #18
    7212:	d014      	beq.n	723e <tcp_input+0x48a>
		else if (flags & TCP_ACK) {
    7214:	4b36      	ldr	r3, [pc, #216]	; (72f0 <tcp_input+0x53c>)
    7216:	7a1b      	ldrb	r3, [r3, #8]
    7218:	f013 0f10 	tst.w	r3, #16
    721c:	f43f ae99 	beq.w	6f52 <tcp_input+0x19e>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    7220:	4833      	ldr	r0, [pc, #204]	; (72f0 <tcp_input+0x53c>)
    7222:	6803      	ldr	r3, [r0, #0]
    7224:	8a04      	ldrh	r4, [r0, #16]
    7226:	6841      	ldr	r1, [r0, #4]
    7228:	881a      	ldrh	r2, [r3, #0]
    722a:	9201      	str	r2, [sp, #4]
    722c:	885b      	ldrh	r3, [r3, #2]
    722e:	9300      	str	r3, [sp, #0]
    7230:	4b32      	ldr	r3, [pc, #200]	; (72fc <tcp_input+0x548>)
    7232:	4a30      	ldr	r2, [pc, #192]	; (72f4 <tcp_input+0x540>)
    7234:	4421      	add	r1, r4
    7236:	68c0      	ldr	r0, [r0, #12]
    7238:	4c31      	ldr	r4, [pc, #196]	; (7300 <tcp_input+0x54c>)
    723a:	47a0      	blx	r4
    723c:	e689      	b.n	6f52 <tcp_input+0x19e>
		if ((flags & TCP_ACK) && (flags & TCP_SYN) && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    723e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    7240:	691b      	ldr	r3, [r3, #16]
    7242:	6858      	ldr	r0, [r3, #4]
    7244:	4b39      	ldr	r3, [pc, #228]	; (732c <tcp_input+0x578>)
    7246:	4798      	blx	r3
    7248:	3001      	adds	r0, #1
    724a:	4b29      	ldr	r3, [pc, #164]	; (72f0 <tcp_input+0x53c>)
    724c:	68db      	ldr	r3, [r3, #12]
    724e:	4298      	cmp	r0, r3
    7250:	d1e0      	bne.n	7214 <tcp_input+0x460>
			pcb->snd_buf++;
    7252:	f8b5 3066 	ldrh.w	r3, [r5, #102]	; 0x66
    7256:	3301      	adds	r3, #1
    7258:	f8a5 3066 	strh.w	r3, [r5, #102]	; 0x66
			pcb->rcv_nxt            = seqno + 1;
    725c:	4a24      	ldr	r2, [pc, #144]	; (72f0 <tcp_input+0x53c>)
    725e:	6853      	ldr	r3, [r2, #4]
    7260:	1c59      	adds	r1, r3, #1
    7262:	62a9      	str	r1, [r5, #40]	; 0x28
			pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    7264:	6329      	str	r1, [r5, #48]	; 0x30
			pcb->lastack            = ackno;
    7266:	64a8      	str	r0, [r5, #72]	; 0x48
			pcb->snd_wnd            = tcphdr->wnd;
    7268:	6812      	ldr	r2, [r2, #0]
    726a:	89d1      	ldrh	r1, [r2, #14]
    726c:	f8a5 1060 	strh.w	r1, [r5, #96]	; 0x60
			pcb->snd_wnd_max        = tcphdr->wnd;
    7270:	89d2      	ldrh	r2, [r2, #14]
    7272:	f8a5 2062 	strh.w	r2, [r5, #98]	; 0x62
			pcb->snd_wl1            = seqno - 1; /* initialise to seqno - 1 to force window update */
    7276:	3b01      	subs	r3, #1
    7278:	656b      	str	r3, [r5, #84]	; 0x54
			pcb->state              = ESTABLISHED;
    727a:	2304      	movs	r3, #4
    727c:	762b      	strb	r3, [r5, #24]
			pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    727e:	18e9      	adds	r1, r5, r3
    7280:	8ee8      	ldrh	r0, [r5, #54]	; 0x36
    7282:	4b25      	ldr	r3, [pc, #148]	; (7318 <tcp_input+0x564>)
    7284:	4798      	blx	r3
    7286:	86e8      	strh	r0, [r5, #54]	; 0x36
			pcb->ssthresh = pcb->mss * 10;
    7288:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    728c:	005b      	lsls	r3, r3, #1
    728e:	f8a5 304e 	strh.w	r3, [r5, #78]	; 0x4e
			pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    7292:	f8b5 304c 	ldrh.w	r3, [r5, #76]	; 0x4c
    7296:	2b01      	cmp	r3, #1
    7298:	bf04      	itt	eq
    729a:	0040      	lsleq	r0, r0, #1
    729c:	b280      	uxtheq	r0, r0
    729e:	f8a5 004c 	strh.w	r0, [r5, #76]	; 0x4c
			--pcb->snd_queuelen;
    72a2:	f8b5 3068 	ldrh.w	r3, [r5, #104]	; 0x68
    72a6:	3b01      	subs	r3, #1
    72a8:	f8a5 3068 	strh.w	r3, [r5, #104]	; 0x68
			rseg         = pcb->unacked;
    72ac:	6f28      	ldr	r0, [r5, #112]	; 0x70
			pcb->unacked = rseg->next;
    72ae:	6803      	ldr	r3, [r0, #0]
    72b0:	672b      	str	r3, [r5, #112]	; 0x70
			tcp_seg_free(rseg);
    72b2:	4b1f      	ldr	r3, [pc, #124]	; (7330 <tcp_input+0x57c>)
    72b4:	4798      	blx	r3
			if (pcb->unacked == NULL)
    72b6:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    72b8:	b993      	cbnz	r3, 72e0 <tcp_input+0x52c>
				pcb->rtime = -1;
    72ba:	f64f 73ff 	movw	r3, #65535	; 0xffff
    72be:	86ab      	strh	r3, [r5, #52]	; 0x34
			TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    72c0:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
    72c4:	b13b      	cbz	r3, 72d6 <tcp_input+0x522>
    72c6:	2200      	movs	r2, #0
    72c8:	4629      	mov	r1, r5
    72ca:	6928      	ldr	r0, [r5, #16]
    72cc:	4798      	blx	r3
			if (err == ERR_ABRT) {
    72ce:	f110 0f0a 	cmn.w	r0, #10
    72d2:	f43f ae54 	beq.w	6f7e <tcp_input+0x1ca>
			tcp_ack_now(pcb);
    72d6:	7fab      	ldrb	r3, [r5, #30]
    72d8:	f043 0302 	orr.w	r3, r3, #2
    72dc:	77ab      	strb	r3, [r5, #30]
    72de:	e638      	b.n	6f52 <tcp_input+0x19e>
				pcb->rtime = 0;
    72e0:	2300      	movs	r3, #0
    72e2:	86ab      	strh	r3, [r5, #52]	; 0x34
				pcb->nrtx  = 0;
    72e4:	f885 3046 	strb.w	r3, [r5, #70]	; 0x46
    72e8:	e7ea      	b.n	72c0 <tcp_input+0x50c>
    72ea:	bf00      	nop
    72ec:	200092e8 	.word	0x200092e8
    72f0:	20007f9c 	.word	0x20007f9c
    72f4:	20008314 	.word	0x20008314
    72f8:	000054c9 	.word	0x000054c9
    72fc:	2000830c 	.word	0x2000830c
    7300:	00007d1d 	.word	0x00007d1d
    7304:	00006285 	.word	0x00006285
    7308:	200092e0 	.word	0x200092e0
    730c:	00008061 	.word	0x00008061
    7310:	200092dc 	.word	0x200092dc
    7314:	000063d5 	.word	0x000063d5
    7318:	000063ad 	.word	0x000063ad
    731c:	000078ad 	.word	0x000078ad
    7320:	00007a49 	.word	0x00007a49
    7324:	000061b9 	.word	0x000061b9
    7328:	200092e4 	.word	0x200092e4
    732c:	00002711 	.word	0x00002711
    7330:	000059e9 	.word	0x000059e9
		if (flags & TCP_ACK) {
    7334:	4b9d      	ldr	r3, [pc, #628]	; (75ac <tcp_input+0x7f8>)
    7336:	7a1b      	ldrb	r3, [r3, #8]
    7338:	f013 0f10 	tst.w	r3, #16
    733c:	d048      	beq.n	73d0 <tcp_input+0x61c>
			if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
    733e:	4b9b      	ldr	r3, [pc, #620]	; (75ac <tcp_input+0x7f8>)
    7340:	68d8      	ldr	r0, [r3, #12]
    7342:	6cab      	ldr	r3, [r5, #72]	; 0x48
    7344:	43db      	mvns	r3, r3
    7346:	42c3      	cmn	r3, r0
    7348:	d434      	bmi.n	73b4 <tcp_input+0x600>
    734a:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    734c:	1ac3      	subs	r3, r0, r3
    734e:	2b00      	cmp	r3, #0
    7350:	dc30      	bgt.n	73b4 <tcp_input+0x600>
				pcb->state = ESTABLISHED;
    7352:	2304      	movs	r3, #4
    7354:	762b      	strb	r3, [r5, #24]
				TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    7356:	696b      	ldr	r3, [r5, #20]
    7358:	b143      	cbz	r3, 736c <tcp_input+0x5b8>
    735a:	2200      	movs	r2, #0
    735c:	4629      	mov	r1, r5
    735e:	6928      	ldr	r0, [r5, #16]
    7360:	4798      	blx	r3
				if (err != ERR_OK) {
    7362:	b138      	cbz	r0, 7374 <tcp_input+0x5c0>
					if (err != ERR_ABRT) {
    7364:	f110 0f0a 	cmn.w	r0, #10
    7368:	f43f ae09 	beq.w	6f7e <tcp_input+0x1ca>
						tcp_abort(pcb);
    736c:	4628      	mov	r0, r5
    736e:	4b90      	ldr	r3, [pc, #576]	; (75b0 <tcp_input+0x7fc>)
    7370:	4798      	blx	r3
    7372:	e604      	b.n	6f7e <tcp_input+0x1ca>
				old_cwnd = pcb->cwnd;
    7374:	f8b5 404c 	ldrh.w	r4, [r5, #76]	; 0x4c
				tcp_receive(pcb);
    7378:	4628      	mov	r0, r5
    737a:	4b8e      	ldr	r3, [pc, #568]	; (75b4 <tcp_input+0x800>)
    737c:	4798      	blx	r3
				if (pcb->acked != 0) {
    737e:	f8b5 3064 	ldrh.w	r3, [r5, #100]	; 0x64
    7382:	b113      	cbz	r3, 738a <tcp_input+0x5d6>
					pcb->acked--;
    7384:	3b01      	subs	r3, #1
    7386:	f8a5 3064 	strh.w	r3, [r5, #100]	; 0x64
				pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    738a:	2c01      	cmp	r4, #1
    738c:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
    738e:	bf04      	itt	eq
    7390:	005b      	lsleq	r3, r3, #1
    7392:	b29b      	uxtheq	r3, r3
    7394:	f8a5 304c 	strh.w	r3, [r5, #76]	; 0x4c
				if (recv_flags & TF_GOT_FIN) {
    7398:	4b84      	ldr	r3, [pc, #528]	; (75ac <tcp_input+0x7f8>)
    739a:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    739e:	f013 0f20 	tst.w	r3, #32
    73a2:	f43f add6 	beq.w	6f52 <tcp_input+0x19e>
					tcp_ack_now(pcb);
    73a6:	7fab      	ldrb	r3, [r5, #30]
    73a8:	f043 0302 	orr.w	r3, r3, #2
    73ac:	77ab      	strb	r3, [r5, #30]
					pcb->state = CLOSE_WAIT;
    73ae:	2307      	movs	r3, #7
    73b0:	762b      	strb	r3, [r5, #24]
    73b2:	e5ce      	b.n	6f52 <tcp_input+0x19e>
				    ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    73b4:	4b7d      	ldr	r3, [pc, #500]	; (75ac <tcp_input+0x7f8>)
    73b6:	681a      	ldr	r2, [r3, #0]
				tcp_rst(
    73b8:	8a1c      	ldrh	r4, [r3, #16]
    73ba:	6859      	ldr	r1, [r3, #4]
    73bc:	8813      	ldrh	r3, [r2, #0]
    73be:	9301      	str	r3, [sp, #4]
    73c0:	8853      	ldrh	r3, [r2, #2]
    73c2:	9300      	str	r3, [sp, #0]
    73c4:	4b7c      	ldr	r3, [pc, #496]	; (75b8 <tcp_input+0x804>)
    73c6:	4a7d      	ldr	r2, [pc, #500]	; (75bc <tcp_input+0x808>)
    73c8:	4421      	add	r1, r4
    73ca:	4c7d      	ldr	r4, [pc, #500]	; (75c0 <tcp_input+0x80c>)
    73cc:	47a0      	blx	r4
    73ce:	e5c0      	b.n	6f52 <tcp_input+0x19e>
		} else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
    73d0:	f013 0f02 	tst.w	r3, #2
    73d4:	f43f adbd 	beq.w	6f52 <tcp_input+0x19e>
    73d8:	6aab      	ldr	r3, [r5, #40]	; 0x28
    73da:	3b01      	subs	r3, #1
    73dc:	4a73      	ldr	r2, [pc, #460]	; (75ac <tcp_input+0x7f8>)
    73de:	6852      	ldr	r2, [r2, #4]
    73e0:	4293      	cmp	r3, r2
    73e2:	f47f adb6 	bne.w	6f52 <tcp_input+0x19e>
			tcp_rexmit(pcb);
    73e6:	4628      	mov	r0, r5
    73e8:	4b76      	ldr	r3, [pc, #472]	; (75c4 <tcp_input+0x810>)
    73ea:	4798      	blx	r3
    73ec:	e5b1      	b.n	6f52 <tcp_input+0x19e>
		tcp_receive(pcb);
    73ee:	4628      	mov	r0, r5
    73f0:	4b70      	ldr	r3, [pc, #448]	; (75b4 <tcp_input+0x800>)
    73f2:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) { /* passive close */
    73f4:	4b6d      	ldr	r3, [pc, #436]	; (75ac <tcp_input+0x7f8>)
    73f6:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    73fa:	f013 0f20 	tst.w	r3, #32
    73fe:	f43f ada8 	beq.w	6f52 <tcp_input+0x19e>
			tcp_ack_now(pcb);
    7402:	7fab      	ldrb	r3, [r5, #30]
    7404:	f043 0302 	orr.w	r3, r3, #2
    7408:	77ab      	strb	r3, [r5, #30]
			pcb->state = CLOSE_WAIT;
    740a:	2307      	movs	r3, #7
    740c:	762b      	strb	r3, [r5, #24]
    740e:	e5a0      	b.n	6f52 <tcp_input+0x19e>
		tcp_receive(pcb);
    7410:	4628      	mov	r0, r5
    7412:	4b68      	ldr	r3, [pc, #416]	; (75b4 <tcp_input+0x800>)
    7414:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) {
    7416:	4b65      	ldr	r3, [pc, #404]	; (75ac <tcp_input+0x7f8>)
    7418:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    741c:	f013 0f20 	tst.w	r3, #32
    7420:	d041      	beq.n	74a6 <tcp_input+0x6f2>
			if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    7422:	4b62      	ldr	r3, [pc, #392]	; (75ac <tcp_input+0x7f8>)
    7424:	7a1b      	ldrb	r3, [r3, #8]
    7426:	f013 0f10 	tst.w	r3, #16
    742a:	d035      	beq.n	7498 <tcp_input+0x6e4>
    742c:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    742e:	4b5f      	ldr	r3, [pc, #380]	; (75ac <tcp_input+0x7f8>)
    7430:	68db      	ldr	r3, [r3, #12]
    7432:	429a      	cmp	r2, r3
    7434:	d130      	bne.n	7498 <tcp_input+0x6e4>
				tcp_ack_now(pcb);
    7436:	7fab      	ldrb	r3, [r5, #30]
    7438:	f043 0302 	orr.w	r3, r3, #2
    743c:	77ab      	strb	r3, [r5, #30]
				tcp_pcb_purge(pcb);
    743e:	4628      	mov	r0, r5
    7440:	4b61      	ldr	r3, [pc, #388]	; (75c8 <tcp_input+0x814>)
    7442:	4798      	blx	r3
				TCP_RMV_ACTIVE(pcb);
    7444:	4b61      	ldr	r3, [pc, #388]	; (75cc <tcp_input+0x818>)
    7446:	681b      	ldr	r3, [r3, #0]
    7448:	429d      	cmp	r5, r3
    744a:	d10e      	bne.n	746a <tcp_input+0x6b6>
    744c:	68ea      	ldr	r2, [r5, #12]
    744e:	4b5f      	ldr	r3, [pc, #380]	; (75cc <tcp_input+0x818>)
    7450:	601a      	str	r2, [r3, #0]
    7452:	2201      	movs	r2, #1
    7454:	4b5e      	ldr	r3, [pc, #376]	; (75d0 <tcp_input+0x81c>)
    7456:	701a      	strb	r2, [r3, #0]
				pcb->state = TIME_WAIT;
    7458:	230a      	movs	r3, #10
    745a:	762b      	strb	r3, [r5, #24]
				TCP_REG(&tcp_tw_pcbs, pcb);
    745c:	4b5d      	ldr	r3, [pc, #372]	; (75d4 <tcp_input+0x820>)
    745e:	681a      	ldr	r2, [r3, #0]
    7460:	60ea      	str	r2, [r5, #12]
    7462:	601d      	str	r5, [r3, #0]
    7464:	4b5c      	ldr	r3, [pc, #368]	; (75d8 <tcp_input+0x824>)
    7466:	4798      	blx	r3
    7468:	e573      	b.n	6f52 <tcp_input+0x19e>
				TCP_RMV_ACTIVE(pcb);
    746a:	4a5c      	ldr	r2, [pc, #368]	; (75dc <tcp_input+0x828>)
    746c:	6013      	str	r3, [r2, #0]
    746e:	2200      	movs	r2, #0
    7470:	2001      	movs	r0, #1
    7472:	b92b      	cbnz	r3, 7480 <tcp_input+0x6cc>
    7474:	2a00      	cmp	r2, #0
    7476:	d0ec      	beq.n	7452 <tcp_input+0x69e>
    7478:	2200      	movs	r2, #0
    747a:	4b58      	ldr	r3, [pc, #352]	; (75dc <tcp_input+0x828>)
    747c:	601a      	str	r2, [r3, #0]
    747e:	e7e8      	b.n	7452 <tcp_input+0x69e>
    7480:	68d9      	ldr	r1, [r3, #12]
    7482:	428d      	cmp	r5, r1
    7484:	d105      	bne.n	7492 <tcp_input+0x6de>
    7486:	b10a      	cbz	r2, 748c <tcp_input+0x6d8>
    7488:	4a54      	ldr	r2, [pc, #336]	; (75dc <tcp_input+0x828>)
    748a:	6013      	str	r3, [r2, #0]
    748c:	68ea      	ldr	r2, [r5, #12]
    748e:	60da      	str	r2, [r3, #12]
    7490:	e7df      	b.n	7452 <tcp_input+0x69e>
    7492:	4602      	mov	r2, r0
    7494:	460b      	mov	r3, r1
    7496:	e7ec      	b.n	7472 <tcp_input+0x6be>
				tcp_ack_now(pcb);
    7498:	7fab      	ldrb	r3, [r5, #30]
    749a:	f043 0302 	orr.w	r3, r3, #2
    749e:	77ab      	strb	r3, [r5, #30]
				pcb->state = CLOSING;
    74a0:	2308      	movs	r3, #8
    74a2:	762b      	strb	r3, [r5, #24]
    74a4:	e555      	b.n	6f52 <tcp_input+0x19e>
		} else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    74a6:	4b41      	ldr	r3, [pc, #260]	; (75ac <tcp_input+0x7f8>)
    74a8:	7a1b      	ldrb	r3, [r3, #8]
    74aa:	f013 0f10 	tst.w	r3, #16
    74ae:	f43f ad50 	beq.w	6f52 <tcp_input+0x19e>
    74b2:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    74b4:	4b3d      	ldr	r3, [pc, #244]	; (75ac <tcp_input+0x7f8>)
    74b6:	68db      	ldr	r3, [r3, #12]
    74b8:	429a      	cmp	r2, r3
    74ba:	f47f ad4a 	bne.w	6f52 <tcp_input+0x19e>
			pcb->state = FIN_WAIT_2;
    74be:	2306      	movs	r3, #6
    74c0:	762b      	strb	r3, [r5, #24]
    74c2:	e546      	b.n	6f52 <tcp_input+0x19e>
		tcp_receive(pcb);
    74c4:	4628      	mov	r0, r5
    74c6:	4b3b      	ldr	r3, [pc, #236]	; (75b4 <tcp_input+0x800>)
    74c8:	4798      	blx	r3
		if (recv_flags & TF_GOT_FIN) {
    74ca:	4b38      	ldr	r3, [pc, #224]	; (75ac <tcp_input+0x7f8>)
    74cc:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    74d0:	f013 0f20 	tst.w	r3, #32
    74d4:	f43f ad3d 	beq.w	6f52 <tcp_input+0x19e>
			tcp_ack_now(pcb);
    74d8:	7fab      	ldrb	r3, [r5, #30]
    74da:	f043 0302 	orr.w	r3, r3, #2
    74de:	77ab      	strb	r3, [r5, #30]
			tcp_pcb_purge(pcb);
    74e0:	4628      	mov	r0, r5
    74e2:	4b39      	ldr	r3, [pc, #228]	; (75c8 <tcp_input+0x814>)
    74e4:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    74e6:	4b39      	ldr	r3, [pc, #228]	; (75cc <tcp_input+0x818>)
    74e8:	681b      	ldr	r3, [r3, #0]
    74ea:	429d      	cmp	r5, r3
    74ec:	d10e      	bne.n	750c <tcp_input+0x758>
    74ee:	68ea      	ldr	r2, [r5, #12]
    74f0:	4b36      	ldr	r3, [pc, #216]	; (75cc <tcp_input+0x818>)
    74f2:	601a      	str	r2, [r3, #0]
    74f4:	2201      	movs	r2, #1
    74f6:	4b36      	ldr	r3, [pc, #216]	; (75d0 <tcp_input+0x81c>)
    74f8:	701a      	strb	r2, [r3, #0]
			pcb->state = TIME_WAIT;
    74fa:	230a      	movs	r3, #10
    74fc:	762b      	strb	r3, [r5, #24]
			TCP_REG(&tcp_tw_pcbs, pcb);
    74fe:	4b35      	ldr	r3, [pc, #212]	; (75d4 <tcp_input+0x820>)
    7500:	681a      	ldr	r2, [r3, #0]
    7502:	60ea      	str	r2, [r5, #12]
    7504:	601d      	str	r5, [r3, #0]
    7506:	4b34      	ldr	r3, [pc, #208]	; (75d8 <tcp_input+0x824>)
    7508:	4798      	blx	r3
    750a:	e522      	b.n	6f52 <tcp_input+0x19e>
			TCP_RMV_ACTIVE(pcb);
    750c:	4a33      	ldr	r2, [pc, #204]	; (75dc <tcp_input+0x828>)
    750e:	6013      	str	r3, [r2, #0]
    7510:	2200      	movs	r2, #0
    7512:	2001      	movs	r0, #1
    7514:	e004      	b.n	7520 <tcp_input+0x76c>
    7516:	68d9      	ldr	r1, [r3, #12]
    7518:	428d      	cmp	r5, r1
    751a:	d009      	beq.n	7530 <tcp_input+0x77c>
    751c:	4602      	mov	r2, r0
    751e:	460b      	mov	r3, r1
    7520:	2b00      	cmp	r3, #0
    7522:	d1f8      	bne.n	7516 <tcp_input+0x762>
    7524:	2a00      	cmp	r2, #0
    7526:	d0e5      	beq.n	74f4 <tcp_input+0x740>
    7528:	2200      	movs	r2, #0
    752a:	4b2c      	ldr	r3, [pc, #176]	; (75dc <tcp_input+0x828>)
    752c:	601a      	str	r2, [r3, #0]
    752e:	e7e1      	b.n	74f4 <tcp_input+0x740>
    7530:	b10a      	cbz	r2, 7536 <tcp_input+0x782>
    7532:	4a2a      	ldr	r2, [pc, #168]	; (75dc <tcp_input+0x828>)
    7534:	6013      	str	r3, [r2, #0]
    7536:	68ea      	ldr	r2, [r5, #12]
    7538:	60da      	str	r2, [r3, #12]
    753a:	e7db      	b.n	74f4 <tcp_input+0x740>
		tcp_receive(pcb);
    753c:	4628      	mov	r0, r5
    753e:	4b1d      	ldr	r3, [pc, #116]	; (75b4 <tcp_input+0x800>)
    7540:	4798      	blx	r3
		if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    7542:	4b1a      	ldr	r3, [pc, #104]	; (75ac <tcp_input+0x7f8>)
    7544:	7a1b      	ldrb	r3, [r3, #8]
    7546:	f013 0f10 	tst.w	r3, #16
    754a:	f43f ad02 	beq.w	6f52 <tcp_input+0x19e>
    754e:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    7550:	4b16      	ldr	r3, [pc, #88]	; (75ac <tcp_input+0x7f8>)
    7552:	68db      	ldr	r3, [r3, #12]
    7554:	429a      	cmp	r2, r3
    7556:	f47f acfc 	bne.w	6f52 <tcp_input+0x19e>
			tcp_pcb_purge(pcb);
    755a:	4628      	mov	r0, r5
    755c:	4b1a      	ldr	r3, [pc, #104]	; (75c8 <tcp_input+0x814>)
    755e:	4798      	blx	r3
			TCP_RMV_ACTIVE(pcb);
    7560:	4b1a      	ldr	r3, [pc, #104]	; (75cc <tcp_input+0x818>)
    7562:	681b      	ldr	r3, [r3, #0]
    7564:	429d      	cmp	r5, r3
    7566:	d10e      	bne.n	7586 <tcp_input+0x7d2>
    7568:	68ea      	ldr	r2, [r5, #12]
    756a:	4b18      	ldr	r3, [pc, #96]	; (75cc <tcp_input+0x818>)
    756c:	601a      	str	r2, [r3, #0]
    756e:	2201      	movs	r2, #1
    7570:	4b17      	ldr	r3, [pc, #92]	; (75d0 <tcp_input+0x81c>)
    7572:	701a      	strb	r2, [r3, #0]
			pcb->state = TIME_WAIT;
    7574:	230a      	movs	r3, #10
    7576:	762b      	strb	r3, [r5, #24]
			TCP_REG(&tcp_tw_pcbs, pcb);
    7578:	4b16      	ldr	r3, [pc, #88]	; (75d4 <tcp_input+0x820>)
    757a:	681a      	ldr	r2, [r3, #0]
    757c:	60ea      	str	r2, [r5, #12]
    757e:	601d      	str	r5, [r3, #0]
    7580:	4b15      	ldr	r3, [pc, #84]	; (75d8 <tcp_input+0x824>)
    7582:	4798      	blx	r3
    7584:	e4e5      	b.n	6f52 <tcp_input+0x19e>
			TCP_RMV_ACTIVE(pcb);
    7586:	4a15      	ldr	r2, [pc, #84]	; (75dc <tcp_input+0x828>)
    7588:	6013      	str	r3, [r2, #0]
    758a:	2200      	movs	r2, #0
    758c:	2001      	movs	r0, #1
    758e:	e004      	b.n	759a <tcp_input+0x7e6>
    7590:	68d9      	ldr	r1, [r3, #12]
    7592:	428d      	cmp	r5, r1
    7594:	d024      	beq.n	75e0 <tcp_input+0x82c>
    7596:	4602      	mov	r2, r0
    7598:	460b      	mov	r3, r1
    759a:	2b00      	cmp	r3, #0
    759c:	d1f8      	bne.n	7590 <tcp_input+0x7dc>
    759e:	2a00      	cmp	r2, #0
    75a0:	d0e5      	beq.n	756e <tcp_input+0x7ba>
    75a2:	2200      	movs	r2, #0
    75a4:	4b0d      	ldr	r3, [pc, #52]	; (75dc <tcp_input+0x828>)
    75a6:	601a      	str	r2, [r3, #0]
    75a8:	e7e1      	b.n	756e <tcp_input+0x7ba>
    75aa:	bf00      	nop
    75ac:	20007f9c 	.word	0x20007f9c
    75b0:	0000625d 	.word	0x0000625d
    75b4:	0000653d 	.word	0x0000653d
    75b8:	2000830c 	.word	0x2000830c
    75bc:	20008314 	.word	0x20008314
    75c0:	00007d1d 	.word	0x00007d1d
    75c4:	00007df5 	.word	0x00007df5
    75c8:	00005a5d 	.word	0x00005a5d
    75cc:	200092e0 	.word	0x200092e0
    75d0:	200092dc 	.word	0x200092dc
    75d4:	200092f4 	.word	0x200092f4
    75d8:	00008061 	.word	0x00008061
    75dc:	200092ec 	.word	0x200092ec
    75e0:	b10a      	cbz	r2, 75e6 <tcp_input+0x832>
    75e2:	4a52      	ldr	r2, [pc, #328]	; (772c <tcp_input+0x978>)
    75e4:	6013      	str	r3, [r2, #0]
    75e6:	68ea      	ldr	r2, [r5, #12]
    75e8:	60da      	str	r2, [r3, #12]
    75ea:	e7c0      	b.n	756e <tcp_input+0x7ba>
		tcp_receive(pcb);
    75ec:	4628      	mov	r0, r5
    75ee:	4b50      	ldr	r3, [pc, #320]	; (7730 <tcp_input+0x97c>)
    75f0:	4798      	blx	r3
		if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    75f2:	4b50      	ldr	r3, [pc, #320]	; (7734 <tcp_input+0x980>)
    75f4:	7a1b      	ldrb	r3, [r3, #8]
    75f6:	f013 0f10 	tst.w	r3, #16
    75fa:	f43f acaa 	beq.w	6f52 <tcp_input+0x19e>
    75fe:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    7600:	4b4c      	ldr	r3, [pc, #304]	; (7734 <tcp_input+0x980>)
    7602:	68db      	ldr	r3, [r3, #12]
    7604:	429a      	cmp	r2, r3
    7606:	f47f aca4 	bne.w	6f52 <tcp_input+0x19e>
			recv_flags |= TF_CLOSED;
    760a:	4a4a      	ldr	r2, [pc, #296]	; (7734 <tcp_input+0x980>)
    760c:	f892 302c 	ldrb.w	r3, [r2, #44]	; 0x2c
    7610:	f043 0310 	orr.w	r3, r3, #16
    7614:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
    7618:	e49b      	b.n	6f52 <tcp_input+0x19e>
			} else if (recv_flags & TF_CLOSED) {
    761a:	f013 0f10 	tst.w	r3, #16
    761e:	d013      	beq.n	7648 <tcp_input+0x894>
				if (!(pcb->flags & TF_RXCLOSED)) {
    7620:	7fab      	ldrb	r3, [r5, #30]
    7622:	f013 0f10 	tst.w	r3, #16
    7626:	d106      	bne.n	7636 <tcp_input+0x882>
					TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    7628:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    762c:	b11b      	cbz	r3, 7636 <tcp_input+0x882>
    762e:	f06f 010b 	mvn.w	r1, #11
    7632:	6928      	ldr	r0, [r5, #16]
    7634:	4798      	blx	r3
				tcp_pcb_remove(&tcp_active_pcbs, pcb);
    7636:	4629      	mov	r1, r5
    7638:	483f      	ldr	r0, [pc, #252]	; (7738 <tcp_input+0x984>)
    763a:	4b40      	ldr	r3, [pc, #256]	; (773c <tcp_input+0x988>)
    763c:	4798      	blx	r3
				memp_free(MEMP_TCP_PCB, pcb);
    763e:	4629      	mov	r1, r5
    7640:	2002      	movs	r0, #2
    7642:	4b3f      	ldr	r3, [pc, #252]	; (7740 <tcp_input+0x98c>)
    7644:	4798      	blx	r3
    7646:	e49a      	b.n	6f7e <tcp_input+0x1ca>
				if (pcb->acked > 0) {
    7648:	f8b5 2064 	ldrh.w	r2, [r5, #100]	; 0x64
    764c:	b142      	cbz	r2, 7660 <tcp_input+0x8ac>
					TCP_EVENT_SENT(pcb, pcb->acked, err);
    764e:	6feb      	ldr	r3, [r5, #124]	; 0x7c
    7650:	b133      	cbz	r3, 7660 <tcp_input+0x8ac>
    7652:	4629      	mov	r1, r5
    7654:	6928      	ldr	r0, [r5, #16]
    7656:	4798      	blx	r3
					if (err == ERR_ABRT) {
    7658:	f110 0f0a 	cmn.w	r0, #10
    765c:	f43f ac8f 	beq.w	6f7e <tcp_input+0x1ca>
				if (recv_data != NULL) {
    7660:	4b34      	ldr	r3, [pc, #208]	; (7734 <tcp_input+0x980>)
    7662:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    7664:	b1ca      	cbz	r2, 769a <tcp_input+0x8e6>
					if (pcb->flags & TF_RXCLOSED) {
    7666:	7fab      	ldrb	r3, [r5, #30]
    7668:	f013 0f10 	tst.w	r3, #16
    766c:	d006      	beq.n	767c <tcp_input+0x8c8>
						pbuf_free(recv_data);
    766e:	4610      	mov	r0, r2
    7670:	4b34      	ldr	r3, [pc, #208]	; (7744 <tcp_input+0x990>)
    7672:	4798      	blx	r3
						tcp_abort(pcb);
    7674:	4628      	mov	r0, r5
    7676:	4b34      	ldr	r3, [pc, #208]	; (7748 <tcp_input+0x994>)
    7678:	4798      	blx	r3
						goto aborted;
    767a:	e480      	b.n	6f7e <tcp_input+0x1ca>
					TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    767c:	f8d5 4080 	ldr.w	r4, [r5, #128]	; 0x80
    7680:	b1f4      	cbz	r4, 76c0 <tcp_input+0x90c>
    7682:	2300      	movs	r3, #0
    7684:	4629      	mov	r1, r5
    7686:	6928      	ldr	r0, [r5, #16]
    7688:	47a0      	blx	r4
					if (err == ERR_ABRT) {
    768a:	f110 0f0a 	cmn.w	r0, #10
    768e:	f43f ac76 	beq.w	6f7e <tcp_input+0x1ca>
					if (err != ERR_OK) {
    7692:	b110      	cbz	r0, 769a <tcp_input+0x8e6>
						pcb->refused_data = recv_data;
    7694:	4b27      	ldr	r3, [pc, #156]	; (7734 <tcp_input+0x980>)
    7696:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    7698:	67ab      	str	r3, [r5, #120]	; 0x78
				if (recv_flags & TF_GOT_FIN) {
    769a:	4b26      	ldr	r3, [pc, #152]	; (7734 <tcp_input+0x980>)
    769c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    76a0:	f013 0f20 	tst.w	r3, #32
    76a4:	d005      	beq.n	76b2 <tcp_input+0x8fe>
					if (pcb->refused_data != NULL) {
    76a6:	6fab      	ldr	r3, [r5, #120]	; 0x78
    76a8:	b183      	cbz	r3, 76cc <tcp_input+0x918>
						pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
    76aa:	7b5a      	ldrb	r2, [r3, #13]
    76ac:	f042 0220 	orr.w	r2, r2, #32
    76b0:	735a      	strb	r2, [r3, #13]
				tcp_input_pcb = NULL;
    76b2:	2200      	movs	r2, #0
    76b4:	4b25      	ldr	r3, [pc, #148]	; (774c <tcp_input+0x998>)
    76b6:	601a      	str	r2, [r3, #0]
				tcp_output(pcb);
    76b8:	4628      	mov	r0, r5
    76ba:	4b25      	ldr	r3, [pc, #148]	; (7750 <tcp_input+0x99c>)
    76bc:	4798      	blx	r3
    76be:	e45e      	b.n	6f7e <tcp_input+0x1ca>
					TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    76c0:	2300      	movs	r3, #0
    76c2:	4629      	mov	r1, r5
    76c4:	4618      	mov	r0, r3
    76c6:	4c23      	ldr	r4, [pc, #140]	; (7754 <tcp_input+0x9a0>)
    76c8:	47a0      	blx	r4
    76ca:	e7de      	b.n	768a <tcp_input+0x8d6>
						if (pcb->rcv_wnd != TCP_WND) {
    76cc:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    76ce:	f241 62d0 	movw	r2, #5840	; 0x16d0
    76d2:	4293      	cmp	r3, r2
							pcb->rcv_wnd++;
    76d4:	bf1c      	itt	ne
    76d6:	3301      	addne	r3, #1
    76d8:	85ab      	strhne	r3, [r5, #44]	; 0x2c
						TCP_EVENT_CLOSED(pcb, err);
    76da:	f8d5 4080 	ldr.w	r4, [r5, #128]	; 0x80
    76de:	2c00      	cmp	r4, #0
    76e0:	d0e7      	beq.n	76b2 <tcp_input+0x8fe>
    76e2:	2300      	movs	r3, #0
    76e4:	461a      	mov	r2, r3
    76e6:	4629      	mov	r1, r5
    76e8:	6928      	ldr	r0, [r5, #16]
    76ea:	47a0      	blx	r4
						if (err == ERR_ABRT) {
    76ec:	f110 0f0a 	cmn.w	r0, #10
    76f0:	d1df      	bne.n	76b2 <tcp_input+0x8fe>
    76f2:	e444      	b.n	6f7e <tcp_input+0x1ca>
		if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
    76f4:	4b0f      	ldr	r3, [pc, #60]	; (7734 <tcp_input+0x980>)
    76f6:	681b      	ldr	r3, [r3, #0]
    76f8:	8998      	ldrh	r0, [r3, #12]
    76fa:	4b17      	ldr	r3, [pc, #92]	; (7758 <tcp_input+0x9a4>)
    76fc:	4798      	blx	r3
    76fe:	f010 0f04 	tst.w	r0, #4
    7702:	d004      	beq.n	770e <tcp_input+0x95a>
		pbuf_free(p);
    7704:	4620      	mov	r0, r4
    7706:	4b0f      	ldr	r3, [pc, #60]	; (7744 <tcp_input+0x990>)
    7708:	4798      	blx	r3
    770a:	f7ff bb6b 	b.w	6de4 <tcp_input+0x30>
			tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    770e:	4809      	ldr	r0, [pc, #36]	; (7734 <tcp_input+0x980>)
    7710:	6803      	ldr	r3, [r0, #0]
    7712:	8a05      	ldrh	r5, [r0, #16]
    7714:	6841      	ldr	r1, [r0, #4]
    7716:	881a      	ldrh	r2, [r3, #0]
    7718:	9201      	str	r2, [sp, #4]
    771a:	885b      	ldrh	r3, [r3, #2]
    771c:	9300      	str	r3, [sp, #0]
    771e:	4b0f      	ldr	r3, [pc, #60]	; (775c <tcp_input+0x9a8>)
    7720:	4a0f      	ldr	r2, [pc, #60]	; (7760 <tcp_input+0x9ac>)
    7722:	4429      	add	r1, r5
    7724:	68c0      	ldr	r0, [r0, #12]
    7726:	4d0f      	ldr	r5, [pc, #60]	; (7764 <tcp_input+0x9b0>)
    7728:	47a8      	blx	r5
    772a:	e7eb      	b.n	7704 <tcp_input+0x950>
    772c:	200092ec 	.word	0x200092ec
    7730:	0000653d 	.word	0x0000653d
    7734:	20007f9c 	.word	0x20007f9c
    7738:	200092e0 	.word	0x200092e0
    773c:	00005e29 	.word	0x00005e29
    7740:	00005201 	.word	0x00005201
    7744:	000054c9 	.word	0x000054c9
    7748:	0000625d 	.word	0x0000625d
    774c:	200092f8 	.word	0x200092f8
    7750:	00007a49 	.word	0x00007a49
    7754:	00006071 	.word	0x00006071
    7758:	000026ef 	.word	0x000026ef
    775c:	2000830c 	.word	0x2000830c
    7760:	20008314 	.word	0x20008314
    7764:	00007d1d 	.word	0x00007d1d

00007768 <tcp_create_segment>:
 * @return a new tcp_seg pointing to p, or NULL.
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
    7768:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    776c:	4681      	mov	r9, r0
    776e:	4688      	mov	r8, r1
    7770:	4616      	mov	r6, r2
    7772:	469a      	mov	sl, r3
    7774:	f89d 7020 	ldrb.w	r7, [sp, #32]
	struct tcp_seg *seg;
	u8_t            optlen = LWIP_TCP_OPT_LENGTH(optflags);
    7778:	f007 0301 	and.w	r3, r7, #1
    777c:	f007 0202 	and.w	r2, r7, #2
    7780:	2a00      	cmp	r2, #0
    7782:	bf14      	ite	ne
    7784:	250c      	movne	r5, #12
    7786:	2500      	moveq	r5, #0
    7788:	eb05 0583 	add.w	r5, r5, r3, lsl #2

	if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    778c:	2004      	movs	r0, #4
    778e:	4b24      	ldr	r3, [pc, #144]	; (7820 <tcp_create_segment+0xb8>)
    7790:	4798      	blx	r3
    7792:	4604      	mov	r4, r0
    7794:	2800      	cmp	r0, #0
    7796:	d039      	beq.n	780c <tcp_create_segment+0xa4>
		LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
		pbuf_free(p);
		return NULL;
	}
	seg->flags = optflags;
    7798:	7307      	strb	r7, [r0, #12]
	seg->next  = NULL;
    779a:	2200      	movs	r2, #0
    779c:	6002      	str	r2, [r0, #0]
	seg->p     = p;
    779e:	f8c0 8004 	str.w	r8, [r0, #4]
	seg->len   = p->tot_len - optlen;
    77a2:	f8b8 3008 	ldrh.w	r3, [r8, #8]
    77a6:	1b5b      	subs	r3, r3, r5
    77a8:	8103      	strh	r3, [r0, #8]
#if TCP_OVERSIZE_DBGCHECK
	seg->oversize_left = 0;
    77aa:	8142      	strh	r2, [r0, #10]
	/* check optflags */
	LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED", (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

	/* build TCP header */
	if (pbuf_header(p, TCP_HLEN)) {
    77ac:	2114      	movs	r1, #20
    77ae:	4640      	mov	r0, r8
    77b0:	4b1c      	ldr	r3, [pc, #112]	; (7824 <tcp_create_segment+0xbc>)
    77b2:	4798      	blx	r3
    77b4:	bb70      	cbnz	r0, 7814 <tcp_create_segment+0xac>
		LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
		TCP_STATS_INC(tcp.err);
		tcp_seg_free(seg);
		return NULL;
	}
	seg->tcphdr        = (struct tcp_hdr *)seg->p->payload;
    77b6:	6863      	ldr	r3, [r4, #4]
    77b8:	f8d3 8004 	ldr.w	r8, [r3, #4]
    77bc:	f8c4 8010 	str.w	r8, [r4, #16]
	seg->tcphdr->src   = htons(pcb->local_port);
    77c0:	f8b9 001a 	ldrh.w	r0, [r9, #26]
    77c4:	4f18      	ldr	r7, [pc, #96]	; (7828 <tcp_create_segment+0xc0>)
    77c6:	47b8      	blx	r7
    77c8:	f8a8 0000 	strh.w	r0, [r8]
	seg->tcphdr->dest  = htons(pcb->remote_port);
    77cc:	f8d4 8010 	ldr.w	r8, [r4, #16]
    77d0:	f8b9 001c 	ldrh.w	r0, [r9, #28]
    77d4:	47b8      	blx	r7
    77d6:	f8a8 0002 	strh.w	r0, [r8, #2]
	seg->tcphdr->seqno = htonl(seqno);
    77da:	f8d4 8010 	ldr.w	r8, [r4, #16]
    77de:	4650      	mov	r0, sl
    77e0:	4b12      	ldr	r3, [pc, #72]	; (782c <tcp_create_segment+0xc4>)
    77e2:	4798      	blx	r3
    77e4:	f8c8 0004 	str.w	r0, [r8, #4]
	/* ackno is set in tcp_output */
	TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    77e8:	f8d4 8010 	ldr.w	r8, [r4, #16]
    77ec:	f3c5 0587 	ubfx	r5, r5, #2, #8
    77f0:	3505      	adds	r5, #5
    77f2:	ea46 3505 	orr.w	r5, r6, r5, lsl #12
    77f6:	b2a8      	uxth	r0, r5
    77f8:	47b8      	blx	r7
    77fa:	f8a8 000c 	strh.w	r0, [r8, #12]
	/* wnd and chksum are set in tcp_output */
	seg->tcphdr->urgp = 0;
    77fe:	6923      	ldr	r3, [r4, #16]
    7800:	2200      	movs	r2, #0
    7802:	749a      	strb	r2, [r3, #18]
    7804:	74da      	strb	r2, [r3, #19]
	return seg;
}
    7806:	4620      	mov	r0, r4
    7808:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pbuf_free(p);
    780c:	4640      	mov	r0, r8
    780e:	4b08      	ldr	r3, [pc, #32]	; (7830 <tcp_create_segment+0xc8>)
    7810:	4798      	blx	r3
		return NULL;
    7812:	e7f8      	b.n	7806 <tcp_create_segment+0x9e>
		tcp_seg_free(seg);
    7814:	4620      	mov	r0, r4
    7816:	4b07      	ldr	r3, [pc, #28]	; (7834 <tcp_create_segment+0xcc>)
    7818:	4798      	blx	r3
		return NULL;
    781a:	2400      	movs	r4, #0
    781c:	e7f3      	b.n	7806 <tcp_create_segment+0x9e>
    781e:	bf00      	nop
    7820:	000051b9 	.word	0x000051b9
    7824:	00005435 	.word	0x00005435
    7828:	000026e5 	.word	0x000026e5
    782c:	000026f9 	.word	0x000026f9
    7830:	000054c9 	.word	0x000054c9
    7834:	000059e9 	.word	0x000059e9

00007838 <tcp_output_alloc_header>:
{
    7838:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    783c:	4606      	mov	r6, r0
    783e:	460c      	mov	r4, r1
    7840:	4699      	mov	r9, r3
	struct pbuf *   p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    7842:	3214      	adds	r2, #20
    7844:	4411      	add	r1, r2
    7846:	2200      	movs	r2, #0
    7848:	b289      	uxth	r1, r1
    784a:	2001      	movs	r0, #1
    784c:	4b14      	ldr	r3, [pc, #80]	; (78a0 <tcp_output_alloc_header+0x68>)
    784e:	4798      	blx	r3
	if (p != NULL) {
    7850:	4680      	mov	r8, r0
    7852:	b310      	cbz	r0, 789a <tcp_output_alloc_header+0x62>
		tcphdr        = (struct tcp_hdr *)p->payload;
    7854:	6845      	ldr	r5, [r0, #4]
		tcphdr->src   = htons(pcb->local_port);
    7856:	8b70      	ldrh	r0, [r6, #26]
    7858:	4f12      	ldr	r7, [pc, #72]	; (78a4 <tcp_output_alloc_header+0x6c>)
    785a:	47b8      	blx	r7
    785c:	8028      	strh	r0, [r5, #0]
		tcphdr->dest  = htons(pcb->remote_port);
    785e:	8bb0      	ldrh	r0, [r6, #28]
    7860:	47b8      	blx	r7
    7862:	8068      	strh	r0, [r5, #2]
		tcphdr->seqno = seqno_be;
    7864:	f8c5 9004 	str.w	r9, [r5, #4]
		tcphdr->ackno = htonl(pcb->rcv_nxt);
    7868:	6ab0      	ldr	r0, [r6, #40]	; 0x28
    786a:	4b0f      	ldr	r3, [pc, #60]	; (78a8 <tcp_output_alloc_header+0x70>)
    786c:	4798      	blx	r3
    786e:	60a8      	str	r0, [r5, #8]
		TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    7870:	08a0      	lsrs	r0, r4, #2
    7872:	3005      	adds	r0, #5
    7874:	0300      	lsls	r0, r0, #12
    7876:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
    787a:	f040 0010 	orr.w	r0, r0, #16
    787e:	47b8      	blx	r7
    7880:	81a8      	strh	r0, [r5, #12]
		tcphdr->wnd    = htons(pcb->rcv_ann_wnd);
    7882:	8df0      	ldrh	r0, [r6, #46]	; 0x2e
    7884:	47b8      	blx	r7
    7886:	81e8      	strh	r0, [r5, #14]
		tcphdr->chksum = 0;
    7888:	2300      	movs	r3, #0
    788a:	742b      	strb	r3, [r5, #16]
    788c:	746b      	strb	r3, [r5, #17]
		tcphdr->urgp   = 0;
    788e:	74ab      	strb	r3, [r5, #18]
    7890:	74eb      	strb	r3, [r5, #19]
		pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    7892:	8df2      	ldrh	r2, [r6, #46]	; 0x2e
    7894:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    7896:	4413      	add	r3, r2
    7898:	6333      	str	r3, [r6, #48]	; 0x30
}
    789a:	4640      	mov	r0, r8
    789c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    78a0:	00005531 	.word	0x00005531
    78a4:	000026e5 	.word	0x000026e5
    78a8:	000026f9 	.word	0x000026f9

000078ac <tcp_enqueue_flags>:

	LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
	            (flags & (TCP_SYN | TCP_FIN)) != 0);

	/* check for configured max queuelen and possible overflow */
	if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    78ac:	f8b0 3068 	ldrh.w	r3, [r0, #104]	; 0x68
    78b0:	2b07      	cmp	r3, #7
    78b2:	d822      	bhi.n	78fa <tcp_enqueue_flags+0x4e>
{
    78b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    78b6:	b083      	sub	sp, #12
		TCP_STATS_INC(tcp.memerr);
		pcb->flags |= TF_NAGLEMEMERR;
		return ERR_MEM;
	}

	if (flags & TCP_SYN) {
    78b8:	f001 0302 	and.w	r3, r1, #2
	u8_t            optflags = 0;
    78bc:	f3c1 0640 	ubfx	r6, r1, #1, #1
#if LWIP_TCP_TIMESTAMPS
	if ((pcb->flags & TF_TIMESTAMP)) {
		optflags |= TF_SEG_OPTS_TS;
	}
#endif /* LWIP_TCP_TIMESTAMPS */
	optlen = LWIP_TCP_OPT_LENGTH(optflags);
    78c0:	2b00      	cmp	r3, #0
    78c2:	bf14      	ite	ne
    78c4:	2704      	movne	r7, #4
    78c6:	2700      	moveq	r7, #0

	/* tcp_enqueue_flags is always called with either SYN or FIN in flags.
	 * We need one available snd_buf byte to do that.
	 * This means we can't send FIN while snd_buf==0. A better fix would be to
	 * not include SYN and FIN sequence numbers in the snd_buf count. */
	if (pcb->snd_buf == 0) {
    78c8:	f8b0 3066 	ldrh.w	r3, [r0, #102]	; 0x66
    78cc:	2b00      	cmp	r3, #0
    78ce:	d04e      	beq.n	796e <tcp_enqueue_flags+0xc2>
    78d0:	460d      	mov	r5, r1
    78d2:	4604      	mov	r4, r0
		TCP_STATS_INC(tcp.memerr);
		return ERR_MEM;
	}

	/* Allocate pbuf with room for TCP header + options */
	if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    78d4:	2200      	movs	r2, #0
    78d6:	4639      	mov	r1, r7
    78d8:	4610      	mov	r0, r2
    78da:	4b26      	ldr	r3, [pc, #152]	; (7974 <tcp_enqueue_flags+0xc8>)
    78dc:	4798      	blx	r3
    78de:	4601      	mov	r1, r0
    78e0:	b190      	cbz	r0, 7908 <tcp_enqueue_flags+0x5c>
		return ERR_MEM;
	}
	LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen", (p->len >= optlen));

	/* Allocate memory for tcp_seg, and fill in fields. */
	if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    78e2:	9600      	str	r6, [sp, #0]
    78e4:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    78e6:	462a      	mov	r2, r5
    78e8:	4620      	mov	r0, r4
    78ea:	4e23      	ldr	r6, [pc, #140]	; (7978 <tcp_enqueue_flags+0xcc>)
    78ec:	47b0      	blx	r6
    78ee:	4601      	mov	r1, r0
    78f0:	b188      	cbz	r0, 7916 <tcp_enqueue_flags+0x6a>
	             ntohl(seg->tcphdr->seqno),
	             ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
	             (u16_t)flags));

	/* Now append seg to pcb->unsent queue */
	if (pcb->unsent == NULL) {
    78f2:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
    78f4:	b9ba      	cbnz	r2, 7926 <tcp_enqueue_flags+0x7a>
		pcb->unsent = seg;
    78f6:	66e0      	str	r0, [r4, #108]	; 0x6c
    78f8:	e019      	b.n	792e <tcp_enqueue_flags+0x82>
		pcb->flags |= TF_NAGLEMEMERR;
    78fa:	7f83      	ldrb	r3, [r0, #30]
    78fc:	f063 037f 	orn	r3, r3, #127	; 0x7f
    7900:	7783      	strb	r3, [r0, #30]
		return ERR_MEM;
    7902:	f04f 30ff 	mov.w	r0, #4294967295
    7906:	4770      	bx	lr
		pcb->flags |= TF_NAGLEMEMERR;
    7908:	7fa3      	ldrb	r3, [r4, #30]
    790a:	f063 037f 	orn	r3, r3, #127	; 0x7f
    790e:	77a3      	strb	r3, [r4, #30]
		return ERR_MEM;
    7910:	f04f 30ff 	mov.w	r0, #4294967295
    7914:	e029      	b.n	796a <tcp_enqueue_flags+0xbe>
		pcb->flags |= TF_NAGLEMEMERR;
    7916:	7fa3      	ldrb	r3, [r4, #30]
    7918:	f063 037f 	orn	r3, r3, #127	; 0x7f
    791c:	77a3      	strb	r3, [r4, #30]
		return ERR_MEM;
    791e:	f04f 30ff 	mov.w	r0, #4294967295
    7922:	e022      	b.n	796a <tcp_enqueue_flags+0xbe>
	} else {
		struct tcp_seg *useg;
		for (useg = pcb->unsent; useg->next != NULL; useg = useg->next)
    7924:	461a      	mov	r2, r3
    7926:	6813      	ldr	r3, [r2, #0]
    7928:	2b00      	cmp	r3, #0
    792a:	d1fb      	bne.n	7924 <tcp_enqueue_flags+0x78>
			;
		useg->next = seg;
    792c:	6011      	str	r1, [r2, #0]
	}
#if TCP_OVERSIZE
	/* The new unsent tail has no space */
	pcb->unsent_oversize = 0;
    792e:	2300      	movs	r3, #0
    7930:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

	/* SYN and FIN bump the sequence number */
	if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    7934:	f015 0f03 	tst.w	r5, #3
    7938:	d007      	beq.n	794a <tcp_enqueue_flags+0x9e>
		pcb->snd_lbb++;
    793a:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    793c:	3301      	adds	r3, #1
    793e:	65e3      	str	r3, [r4, #92]	; 0x5c
		/* optlen does not influence snd_buf */
		pcb->snd_buf--;
    7940:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
    7944:	3b01      	subs	r3, #1
    7946:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
	}
	if (flags & TCP_FIN) {
    794a:	f015 0f01 	tst.w	r5, #1
    794e:	d003      	beq.n	7958 <tcp_enqueue_flags+0xac>
		pcb->flags |= TF_FIN;
    7950:	7fa3      	ldrb	r3, [r4, #30]
    7952:	f043 0320 	orr.w	r3, r3, #32
    7956:	77a3      	strb	r3, [r4, #30]
	}

	/* update number of segments on the queues */
	pcb->snd_queuelen += pbuf_clen(seg->p);
    7958:	6848      	ldr	r0, [r1, #4]
    795a:	4b08      	ldr	r3, [pc, #32]	; (797c <tcp_enqueue_flags+0xd0>)
    795c:	4798      	blx	r3
    795e:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
    7962:	4418      	add	r0, r3
    7964:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
	LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %" S16_F " (after enqueued)\n", pcb->snd_queuelen));
	if (pcb->snd_queuelen != 0) {
		LWIP_ASSERT("tcp_enqueue_flags: invalid queue length", pcb->unacked != NULL || pcb->unsent != NULL);
	}

	return ERR_OK;
    7968:	2000      	movs	r0, #0
}
    796a:	b003      	add	sp, #12
    796c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_MEM;
    796e:	f04f 30ff 	mov.w	r0, #4294967295
    7972:	e7fa      	b.n	796a <tcp_enqueue_flags+0xbe>
    7974:	00005531 	.word	0x00005531
    7978:	00007769 	.word	0x00007769
    797c:	000056cd 	.word	0x000056cd

00007980 <tcp_send_fin>:
{
    7980:	b570      	push	{r4, r5, r6, lr}
    7982:	4605      	mov	r5, r0
	if (pcb->unsent != NULL) {
    7984:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
    7986:	b90c      	cbnz	r4, 798c <tcp_send_fin+0xc>
    7988:	e00a      	b.n	79a0 <tcp_send_fin+0x20>
		for (last_unsent = pcb->unsent; last_unsent->next != NULL; last_unsent = last_unsent->next)
    798a:	461c      	mov	r4, r3
    798c:	6823      	ldr	r3, [r4, #0]
    798e:	2b00      	cmp	r3, #0
    7990:	d1fb      	bne.n	798a <tcp_send_fin+0xa>
		if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
    7992:	6923      	ldr	r3, [r4, #16]
    7994:	8998      	ldrh	r0, [r3, #12]
    7996:	4b0b      	ldr	r3, [pc, #44]	; (79c4 <tcp_send_fin+0x44>)
    7998:	4798      	blx	r3
    799a:	f010 0f07 	tst.w	r0, #7
    799e:	d004      	beq.n	79aa <tcp_send_fin+0x2a>
	return tcp_enqueue_flags(pcb, TCP_FIN);
    79a0:	2101      	movs	r1, #1
    79a2:	4628      	mov	r0, r5
    79a4:	4b08      	ldr	r3, [pc, #32]	; (79c8 <tcp_send_fin+0x48>)
    79a6:	4798      	blx	r3
}
    79a8:	bd70      	pop	{r4, r5, r6, pc}
			TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
    79aa:	6926      	ldr	r6, [r4, #16]
    79ac:	89b4      	ldrh	r4, [r6, #12]
    79ae:	2001      	movs	r0, #1
    79b0:	4b06      	ldr	r3, [pc, #24]	; (79cc <tcp_send_fin+0x4c>)
    79b2:	4798      	blx	r3
    79b4:	4320      	orrs	r0, r4
    79b6:	81b0      	strh	r0, [r6, #12]
			pcb->flags |= TF_FIN;
    79b8:	7fab      	ldrb	r3, [r5, #30]
    79ba:	f043 0320 	orr.w	r3, r3, #32
    79be:	77ab      	strb	r3, [r5, #30]
			return ERR_OK;
    79c0:	2000      	movs	r0, #0
    79c2:	bd70      	pop	{r4, r5, r6, pc}
    79c4:	000026ef 	.word	0x000026ef
    79c8:	000078ad 	.word	0x000078ad
    79cc:	000026e5 	.word	0x000026e5

000079d0 <tcp_send_empty_ack>:
/** Send an ACK without data.
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t tcp_send_empty_ack(struct tcp_pcb *pcb)
{
    79d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    79d4:	b082      	sub	sp, #8
    79d6:	4604      	mov	r4, r0
	if (pcb->flags & TF_TIMESTAMP) {
		optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
	}
#endif

	p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    79d8:	6d00      	ldr	r0, [r0, #80]	; 0x50
    79da:	4b16      	ldr	r3, [pc, #88]	; (7a34 <tcp_send_empty_ack+0x64>)
    79dc:	4798      	blx	r3
    79de:	4603      	mov	r3, r0
    79e0:	2200      	movs	r2, #0
    79e2:	4611      	mov	r1, r2
    79e4:	4620      	mov	r0, r4
    79e6:	4d14      	ldr	r5, [pc, #80]	; (7a38 <tcp_send_empty_ack+0x68>)
    79e8:	47a8      	blx	r5
	if (p == NULL) {
    79ea:	b300      	cbz	r0, 7a2e <tcp_send_empty_ack+0x5e>
    79ec:	4605      	mov	r5, r0
		LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
		return ERR_BUF;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
    79ee:	6847      	ldr	r7, [r0, #4]
	LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %" U32_F "\n", pcb->rcv_nxt));
	/* remove ACK flags from the PCB, as we send an empty ACK now */
	pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    79f0:	7fa3      	ldrb	r3, [r4, #30]
    79f2:	f023 0303 	bic.w	r3, r3, #3
    79f6:	77a3      	strb	r3, [r4, #30]
		tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
	}
#endif

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, p->tot_len);
    79f8:	1d26      	adds	r6, r4, #4
    79fa:	8903      	ldrh	r3, [r0, #8]
    79fc:	9300      	str	r3, [sp, #0]
    79fe:	2306      	movs	r3, #6
    7a00:	4632      	mov	r2, r6
    7a02:	4621      	mov	r1, r4
    7a04:	f8df 803c 	ldr.w	r8, [pc, #60]	; 7a44 <tcp_send_empty_ack+0x74>
    7a08:	47c0      	blx	r8
    7a0a:	8238      	strh	r0, [r7, #16]
#endif
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    7a0c:	7aa3      	ldrb	r3, [r4, #10]
    7a0e:	2206      	movs	r2, #6
    7a10:	9201      	str	r2, [sp, #4]
    7a12:	7a62      	ldrb	r2, [r4, #9]
    7a14:	9200      	str	r2, [sp, #0]
    7a16:	4632      	mov	r2, r6
    7a18:	4621      	mov	r1, r4
    7a1a:	4628      	mov	r0, r5
    7a1c:	4c07      	ldr	r4, [pc, #28]	; (7a3c <tcp_send_empty_ack+0x6c>)
    7a1e:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/
	pbuf_free(p);
    7a20:	4628      	mov	r0, r5
    7a22:	4b07      	ldr	r3, [pc, #28]	; (7a40 <tcp_send_empty_ack+0x70>)
    7a24:	4798      	blx	r3

	return ERR_OK;
    7a26:	2000      	movs	r0, #0
}
    7a28:	b002      	add	sp, #8
    7a2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_BUF;
    7a2e:	f06f 0001 	mvn.w	r0, #1
    7a32:	e7f9      	b.n	7a28 <tcp_send_empty_ack+0x58>
    7a34:	000026f9 	.word	0x000026f9
    7a38:	00007839 	.word	0x00007839
    7a3c:	000046f9 	.word	0x000046f9
    7a40:	000054c9 	.word	0x000054c9
    7a44:	000042d1 	.word	0x000042d1

00007a48 <tcp_output>:

	/* First, check if we are invoked by the TCP input processing
	   code. If so, we do not output anything. Instead, we rely on the
	   input processing code to call us when input processing is done
	   with. */
	if (tcp_input_pcb == pcb) {
    7a48:	4ba7      	ldr	r3, [pc, #668]	; (7ce8 <tcp_output+0x2a0>)
    7a4a:	681b      	ldr	r3, [r3, #0]
    7a4c:	4283      	cmp	r3, r0
    7a4e:	f000 8163 	beq.w	7d18 <tcp_output+0x2d0>
{
    7a52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7a56:	b085      	sub	sp, #20
    7a58:	4605      	mov	r5, r0
		return ERR_OK;
	}

	wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
    7a5a:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
    7a5e:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
    7a62:	429a      	cmp	r2, r3
    7a64:	bf28      	it	cs
    7a66:	461a      	movcs	r2, r3
    7a68:	4692      	mov	sl, r2

	seg = pcb->unsent;
    7a6a:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
	 * because the ->unsent queue is empty or because the window does
	 * not allow it), construct an empty ACK segment and send it.
	 *
	 * If data is to be sent, we will just piggyback the ACK (see below).
	 */
	if (pcb->flags & TF_ACK_NOW && (seg == NULL || ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    7a6c:	7f83      	ldrb	r3, [r0, #30]
    7a6e:	f013 0f02 	tst.w	r3, #2
    7a72:	d014      	beq.n	7a9e <tcp_output+0x56>
    7a74:	b17c      	cbz	r4, 7a96 <tcp_output+0x4e>
    7a76:	6923      	ldr	r3, [r4, #16]
    7a78:	6858      	ldr	r0, [r3, #4]
    7a7a:	4b9c      	ldr	r3, [pc, #624]	; (7cec <tcp_output+0x2a4>)
    7a7c:	4798      	blx	r3
    7a7e:	8923      	ldrh	r3, [r4, #8]
    7a80:	6caa      	ldr	r2, [r5, #72]	; 0x48
    7a82:	1a9b      	subs	r3, r3, r2
    7a84:	4418      	add	r0, r3
    7a86:	4582      	cmp	sl, r0
    7a88:	d305      	bcc.n	7a96 <tcp_output+0x4e>
		return tcp_send_empty_ack(pcb);
	}

	/* useg should point to last segment on unacked queue */
	useg = pcb->unacked;
    7a8a:	f8d5 8070 	ldr.w	r8, [r5, #112]	; 0x70
	if (useg != NULL) {
    7a8e:	f1b8 0f00 	cmp.w	r8, #0
    7a92:	d10f      	bne.n	7ab4 <tcp_output+0x6c>
    7a94:	e015      	b.n	7ac2 <tcp_output+0x7a>
		return tcp_send_empty_ack(pcb);
    7a96:	4628      	mov	r0, r5
    7a98:	4b95      	ldr	r3, [pc, #596]	; (7cf0 <tcp_output+0x2a8>)
    7a9a:	4798      	blx	r3
    7a9c:	e120      	b.n	7ce0 <tcp_output+0x298>
	useg = pcb->unacked;
    7a9e:	f8d0 8070 	ldr.w	r8, [r0, #112]	; 0x70
	if (useg != NULL) {
    7aa2:	f1b8 0f00 	cmp.w	r8, #0
    7aa6:	d105      	bne.n	7ab4 <tcp_output+0x6c>
		             ntohl(seg->tcphdr->seqno),
		             pcb->lastack));
	}
#endif /* TCP_CWND_DEBUG */
	/* data available and window allows it to be sent? */
	while (seg != NULL && ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    7aa8:	b95c      	cbnz	r4, 7ac2 <tcp_output+0x7a>
		seg = pcb->unsent;
	}
#if TCP_OVERSIZE
	if (pcb->unsent == NULL) {
		/* last unsent has been removed, reset unsent_oversize */
		pcb->unsent_oversize = 0;
    7aaa:	2300      	movs	r3, #0
    7aac:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
    7ab0:	e111      	b.n	7cd6 <tcp_output+0x28e>
		for (; useg->next != NULL; useg = useg->next)
    7ab2:	4698      	mov	r8, r3
    7ab4:	f8d8 3000 	ldr.w	r3, [r8]
    7ab8:	2b00      	cmp	r3, #0
    7aba:	d1fa      	bne.n	7ab2 <tcp_output+0x6a>
	while (seg != NULL && ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    7abc:	2c00      	cmp	r4, #0
    7abe:	f000 8106 	beq.w	7cce <tcp_output+0x286>
    7ac2:	4e8a      	ldr	r6, [pc, #552]	; (7cec <tcp_output+0x2a4>)
			TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    7ac4:	f8df b248 	ldr.w	fp, [pc, #584]	; 7d10 <tcp_output+0x2c8>
    7ac8:	e0a3      	b.n	7c12 <tcp_output+0x1ca>
		if ((tcp_do_output_nagle(pcb) == 0) && ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
    7aca:	f8b5 2066 	ldrh.w	r2, [r5, #102]	; 0x66
    7ace:	b13a      	cbz	r2, 7ae0 <tcp_output+0x98>
    7ad0:	f8b5 2068 	ldrh.w	r2, [r5, #104]	; 0x68
    7ad4:	2a07      	cmp	r2, #7
    7ad6:	d803      	bhi.n	7ae0 <tcp_output+0x98>
    7ad8:	f013 0fa0 	tst.w	r3, #160	; 0xa0
    7adc:	f000 80f7 	beq.w	7cce <tcp_output+0x286>
		pcb->unsent = seg->next;
    7ae0:	6823      	ldr	r3, [r4, #0]
    7ae2:	66eb      	str	r3, [r5, #108]	; 0x6c
		if (pcb->state != SYN_SENT) {
    7ae4:	7e2b      	ldrb	r3, [r5, #24]
    7ae6:	2b02      	cmp	r3, #2
    7ae8:	d00c      	beq.n	7b04 <tcp_output+0xbc>
			TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    7aea:	f8d4 9010 	ldr.w	r9, [r4, #16]
    7aee:	f8b9 700c 	ldrh.w	r7, [r9, #12]
    7af2:	2010      	movs	r0, #16
    7af4:	47d8      	blx	fp
    7af6:	4338      	orrs	r0, r7
    7af8:	f8a9 000c 	strh.w	r0, [r9, #12]
			pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    7afc:	7fab      	ldrb	r3, [r5, #30]
    7afe:	f023 0303 	bic.w	r3, r3, #3
    7b02:	77ab      	strb	r3, [r5, #30]
	/** @bug Exclude retransmitted segments from this count. */
	snmp_inc_tcpoutsegs();

	/* The TCP header has already been constructed, but the ackno and
	 wnd fields remain. */
	seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
    7b04:	6927      	ldr	r7, [r4, #16]
    7b06:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    7b08:	4b7a      	ldr	r3, [pc, #488]	; (7cf4 <tcp_output+0x2ac>)
    7b0a:	4798      	blx	r3
    7b0c:	60b8      	str	r0, [r7, #8]

	/* advertise our receive window size in this TCP segment */
	seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    7b0e:	6927      	ldr	r7, [r4, #16]
    7b10:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
    7b12:	47d8      	blx	fp
    7b14:	81f8      	strh	r0, [r7, #14]

	pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    7b16:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
    7b18:	6aab      	ldr	r3, [r5, #40]	; 0x28
    7b1a:	4413      	add	r3, r2
    7b1c:	632b      	str	r3, [r5, #48]	; 0x30

	/* Add any requested options.  NB MSS option is only set on SYN
	   packets, so ignore it here */
	opts = (u32_t *)(void *)(seg->tcphdr + 1);
	if (seg->flags & TF_SEG_OPTS_MSS) {
    7b1e:	7b23      	ldrb	r3, [r4, #12]
    7b20:	f013 0f01 	tst.w	r3, #1
    7b24:	f040 8095 	bne.w	7c52 <tcp_output+0x20a>
	}
#endif

	/* Set retransmission timer running if it is not currently enabled
	   This must be set before checking the route. */
	if (pcb->rtime == -1) {
    7b28:	f9b5 3034 	ldrsh.w	r3, [r5, #52]	; 0x34
    7b2c:	f1b3 3fff 	cmp.w	r3, #4294967295
		pcb->rtime = 0;
    7b30:	bf04      	itt	eq
    7b32:	2300      	moveq	r3, #0
    7b34:	86ab      	strheq	r3, [r5, #52]	; 0x34
	}

	/* If we don't have a local IP address, we get one by
	   calling ip_route(). */
	if (ip_addr_isany(&(pcb->local_ip))) {
    7b36:	b10d      	cbz	r5, 7b3c <tcp_output+0xf4>
    7b38:	682b      	ldr	r3, [r5, #0]
    7b3a:	b933      	cbnz	r3, 7b4a <tcp_output+0x102>
		netif = ip_route(&(pcb->remote_ip));
    7b3c:	1d28      	adds	r0, r5, #4
    7b3e:	4b6e      	ldr	r3, [pc, #440]	; (7cf8 <tcp_output+0x2b0>)
    7b40:	4798      	blx	r3
		if (netif == NULL) {
    7b42:	2800      	cmp	r0, #0
    7b44:	d02e      	beq.n	7ba4 <tcp_output+0x15c>
			return;
		}
		ip_addr_copy(pcb->local_ip, netif->ip_addr);
    7b46:	6843      	ldr	r3, [r0, #4]
    7b48:	602b      	str	r3, [r5, #0]
	}

	if (pcb->rttest == 0) {
    7b4a:	6bab      	ldr	r3, [r5, #56]	; 0x38
    7b4c:	2b00      	cmp	r3, #0
    7b4e:	f000 808c 	beq.w	7c6a <tcp_output+0x222>
	LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
	            ("tcp_output_segment: %" U32_F ":%" U32_F "\n",
	             htonl(seg->tcphdr->seqno),
	             htonl(seg->tcphdr->seqno) + seg->len));

	len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    7b52:	6862      	ldr	r2, [r4, #4]
    7b54:	6923      	ldr	r3, [r4, #16]
    7b56:	6851      	ldr	r1, [r2, #4]
    7b58:	1a5b      	subs	r3, r3, r1
    7b5a:	b29b      	uxth	r3, r3

	seg->p->len -= len;
    7b5c:	8951      	ldrh	r1, [r2, #10]
    7b5e:	1ac9      	subs	r1, r1, r3
    7b60:	8151      	strh	r1, [r2, #10]
	seg->p->tot_len -= len;
    7b62:	6861      	ldr	r1, [r4, #4]
    7b64:	890a      	ldrh	r2, [r1, #8]
    7b66:	1ad3      	subs	r3, r2, r3
    7b68:	810b      	strh	r3, [r1, #8]

	seg->p->payload = seg->tcphdr;
    7b6a:	6863      	ldr	r3, [r4, #4]
    7b6c:	6922      	ldr	r2, [r4, #16]
    7b6e:	605a      	str	r2, [r3, #4]

	seg->tcphdr->chksum = 0;
    7b70:	6923      	ldr	r3, [r4, #16]
    7b72:	2200      	movs	r2, #0
    7b74:	741a      	strb	r2, [r3, #16]
    7b76:	745a      	strb	r2, [r3, #17]
			seg->tcphdr->chksum = chksum_slow;
		}
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
	}
#else  /* TCP_CHECKSUM_ON_COPY */
	seg->tcphdr->chksum
    7b78:	6927      	ldr	r7, [r4, #16]
	    = inet_chksum_pseudo(seg->p, &(pcb->local_ip), &(pcb->remote_ip), IP_PROTO_TCP, seg->p->tot_len);
    7b7a:	6860      	ldr	r0, [r4, #4]
    7b7c:	1d2a      	adds	r2, r5, #4
    7b7e:	8903      	ldrh	r3, [r0, #8]
    7b80:	9300      	str	r3, [sp, #0]
    7b82:	2306      	movs	r3, #6
    7b84:	9203      	str	r2, [sp, #12]
    7b86:	4629      	mov	r1, r5
    7b88:	f8df 9188 	ldr.w	r9, [pc, #392]	; 7d14 <tcp_output+0x2cc>
    7b8c:	47c8      	blx	r9
    7b8e:	8238      	strh	r0, [r7, #16]
	TCP_STATS_INC(tcp.xmit);

#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos, IP_PROTO_TCP);
    7b90:	7aab      	ldrb	r3, [r5, #10]
    7b92:	6860      	ldr	r0, [r4, #4]
    7b94:	2206      	movs	r2, #6
    7b96:	9201      	str	r2, [sp, #4]
    7b98:	7a6a      	ldrb	r2, [r5, #9]
    7b9a:	9200      	str	r2, [sp, #0]
    7b9c:	9a03      	ldr	r2, [sp, #12]
    7b9e:	4629      	mov	r1, r5
    7ba0:	4f56      	ldr	r7, [pc, #344]	; (7cfc <tcp_output+0x2b4>)
    7ba2:	47b8      	blx	r7
		snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    7ba4:	6923      	ldr	r3, [r4, #16]
    7ba6:	6858      	ldr	r0, [r3, #4]
    7ba8:	47b0      	blx	r6
    7baa:	4607      	mov	r7, r0
    7bac:	f8b4 9008 	ldrh.w	r9, [r4, #8]
    7bb0:	6923      	ldr	r3, [r4, #16]
    7bb2:	8998      	ldrh	r0, [r3, #12]
    7bb4:	4b52      	ldr	r3, [pc, #328]	; (7d00 <tcp_output+0x2b8>)
    7bb6:	4798      	blx	r3
    7bb8:	f010 0003 	ands.w	r0, r0, #3
    7bbc:	bf18      	it	ne
    7bbe:	2001      	movne	r0, #1
    7bc0:	4448      	add	r0, r9
    7bc2:	4407      	add	r7, r0
		if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
    7bc4:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    7bc6:	1bdb      	subs	r3, r3, r7
    7bc8:	2b00      	cmp	r3, #0
			pcb->snd_nxt = snd_nxt;
    7bca:	bfb8      	it	lt
    7bcc:	652f      	strlt	r7, [r5, #80]	; 0x50
		if (TCP_TCPLEN(seg) > 0) {
    7bce:	8927      	ldrh	r7, [r4, #8]
    7bd0:	6923      	ldr	r3, [r4, #16]
    7bd2:	8998      	ldrh	r0, [r3, #12]
    7bd4:	4b4a      	ldr	r3, [pc, #296]	; (7d00 <tcp_output+0x2b8>)
    7bd6:	4798      	blx	r3
    7bd8:	f010 0003 	ands.w	r0, r0, #3
    7bdc:	bf18      	it	ne
    7bde:	2001      	movne	r0, #1
    7be0:	42f8      	cmn	r0, r7
    7be2:	d070      	beq.n	7cc6 <tcp_output+0x27e>
			seg->next = NULL;
    7be4:	2300      	movs	r3, #0
    7be6:	6023      	str	r3, [r4, #0]
			if (pcb->unacked == NULL) {
    7be8:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    7bea:	2b00      	cmp	r3, #0
    7bec:	d045      	beq.n	7c7a <tcp_output+0x232>
				if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
    7bee:	6923      	ldr	r3, [r4, #16]
    7bf0:	6858      	ldr	r0, [r3, #4]
    7bf2:	47b0      	blx	r6
    7bf4:	4607      	mov	r7, r0
    7bf6:	f8d8 3010 	ldr.w	r3, [r8, #16]
    7bfa:	6858      	ldr	r0, [r3, #4]
    7bfc:	47b0      	blx	r6
    7bfe:	1a38      	subs	r0, r7, r0
    7c00:	2800      	cmp	r0, #0
    7c02:	db3d      	blt.n	7c80 <tcp_output+0x238>
					useg->next = seg;
    7c04:	f8c8 4000 	str.w	r4, [r8]
    7c08:	46a0      	mov	r8, r4
		seg = pcb->unsent;
    7c0a:	6eec      	ldr	r4, [r5, #108]	; 0x6c
	while (seg != NULL && ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    7c0c:	2c00      	cmp	r4, #0
    7c0e:	f43f af4c 	beq.w	7aaa <tcp_output+0x62>
    7c12:	6923      	ldr	r3, [r4, #16]
    7c14:	6858      	ldr	r0, [r3, #4]
    7c16:	47b0      	blx	r6
    7c18:	6cab      	ldr	r3, [r5, #72]	; 0x48
    7c1a:	1ac0      	subs	r0, r0, r3
    7c1c:	8923      	ldrh	r3, [r4, #8]
    7c1e:	4418      	add	r0, r3
    7c20:	4582      	cmp	sl, r0
    7c22:	d354      	bcc.n	7cce <tcp_output+0x286>
		if ((tcp_do_output_nagle(pcb) == 0) && ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
    7c24:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    7c26:	2b00      	cmp	r3, #0
    7c28:	f43f af5a 	beq.w	7ae0 <tcp_output+0x98>
    7c2c:	7fab      	ldrb	r3, [r5, #30]
    7c2e:	f013 0f44 	tst.w	r3, #68	; 0x44
    7c32:	f47f af55 	bne.w	7ae0 <tcp_output+0x98>
    7c36:	6eea      	ldr	r2, [r5, #108]	; 0x6c
    7c38:	2a00      	cmp	r2, #0
    7c3a:	f43f af46 	beq.w	7aca <tcp_output+0x82>
    7c3e:	6811      	ldr	r1, [r2, #0]
    7c40:	2900      	cmp	r1, #0
    7c42:	f47f af4d 	bne.w	7ae0 <tcp_output+0x98>
    7c46:	8911      	ldrh	r1, [r2, #8]
    7c48:	8eea      	ldrh	r2, [r5, #54]	; 0x36
    7c4a:	4291      	cmp	r1, r2
    7c4c:	f4bf af48 	bcs.w	7ae0 <tcp_output+0x98>
    7c50:	e73b      	b.n	7aca <tcp_output+0x82>
	opts = (u32_t *)(void *)(seg->tcphdr + 1);
    7c52:	6927      	ldr	r7, [r4, #16]
		mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    7c54:	1d29      	adds	r1, r5, #4
    7c56:	f240 50b4 	movw	r0, #1460	; 0x5b4
    7c5a:	4b2a      	ldr	r3, [pc, #168]	; (7d04 <tcp_output+0x2bc>)
    7c5c:	4798      	blx	r3
		*opts = TCP_BUILD_MSS_OPTION(mss);
    7c5e:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
    7c62:	4b24      	ldr	r3, [pc, #144]	; (7cf4 <tcp_output+0x2ac>)
    7c64:	4798      	blx	r3
    7c66:	6178      	str	r0, [r7, #20]
    7c68:	e75e      	b.n	7b28 <tcp_output+0xe0>
		pcb->rttest = tcp_ticks;
    7c6a:	4b27      	ldr	r3, [pc, #156]	; (7d08 <tcp_output+0x2c0>)
    7c6c:	681b      	ldr	r3, [r3, #0]
    7c6e:	63ab      	str	r3, [r5, #56]	; 0x38
		pcb->rtseq  = ntohl(seg->tcphdr->seqno);
    7c70:	6923      	ldr	r3, [r4, #16]
    7c72:	6858      	ldr	r0, [r3, #4]
    7c74:	47b0      	blx	r6
    7c76:	63e8      	str	r0, [r5, #60]	; 0x3c
    7c78:	e76b      	b.n	7b52 <tcp_output+0x10a>
				pcb->unacked = seg;
    7c7a:	672c      	str	r4, [r5, #112]	; 0x70
    7c7c:	46a0      	mov	r8, r4
    7c7e:	e7c4      	b.n	7c0a <tcp_output+0x1c2>
					struct tcp_seg **cur_seg = &(pcb->unacked);
    7c80:	f105 0970 	add.w	r9, r5, #112	; 0x70
					while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    7c84:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    7c86:	b1c3      	cbz	r3, 7cba <tcp_output+0x272>
    7c88:	4622      	mov	r2, r4
    7c8a:	464c      	mov	r4, r9
    7c8c:	4691      	mov	r9, r2
    7c8e:	691b      	ldr	r3, [r3, #16]
    7c90:	6858      	ldr	r0, [r3, #4]
    7c92:	47b0      	blx	r6
    7c94:	4607      	mov	r7, r0
    7c96:	f8d9 3010 	ldr.w	r3, [r9, #16]
    7c9a:	6858      	ldr	r0, [r3, #4]
    7c9c:	47b0      	blx	r6
    7c9e:	1a38      	subs	r0, r7, r0
    7ca0:	2800      	cmp	r0, #0
    7ca2:	da07      	bge.n	7cb4 <tcp_output+0x26c>
						cur_seg = &((*cur_seg)->next);
    7ca4:	6824      	ldr	r4, [r4, #0]
					while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    7ca6:	6823      	ldr	r3, [r4, #0]
    7ca8:	2b00      	cmp	r3, #0
    7caa:	d1f0      	bne.n	7c8e <tcp_output+0x246>
    7cac:	464b      	mov	r3, r9
    7cae:	46a1      	mov	r9, r4
    7cb0:	461c      	mov	r4, r3
    7cb2:	e002      	b.n	7cba <tcp_output+0x272>
    7cb4:	464b      	mov	r3, r9
    7cb6:	46a1      	mov	r9, r4
    7cb8:	461c      	mov	r4, r3
					seg->next  = (*cur_seg);
    7cba:	f8d9 3000 	ldr.w	r3, [r9]
    7cbe:	6023      	str	r3, [r4, #0]
					(*cur_seg) = seg;
    7cc0:	f8c9 4000 	str.w	r4, [r9]
    7cc4:	e7a1      	b.n	7c0a <tcp_output+0x1c2>
			tcp_seg_free(seg);
    7cc6:	4620      	mov	r0, r4
    7cc8:	4b10      	ldr	r3, [pc, #64]	; (7d0c <tcp_output+0x2c4>)
    7cca:	4798      	blx	r3
    7ccc:	e79d      	b.n	7c0a <tcp_output+0x1c2>
	if (pcb->unsent == NULL) {
    7cce:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
    7cd0:	2b00      	cmp	r3, #0
    7cd2:	f43f aeea 	beq.w	7aaa <tcp_output+0x62>
	pcb->flags &= ~TF_NAGLEMEMERR;
    7cd6:	7fab      	ldrb	r3, [r5, #30]
    7cd8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    7cdc:	77ab      	strb	r3, [r5, #30]
	return ERR_OK;
    7cde:	2000      	movs	r0, #0
}
    7ce0:	b005      	add	sp, #20
    7ce2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7ce6:	bf00      	nop
    7ce8:	200092f8 	.word	0x200092f8
    7cec:	00002711 	.word	0x00002711
    7cf0:	000079d1 	.word	0x000079d1
    7cf4:	000026f9 	.word	0x000026f9
    7cf8:	000043cd 	.word	0x000043cd
    7cfc:	000046f9 	.word	0x000046f9
    7d00:	000026ef 	.word	0x000026ef
    7d04:	000063ad 	.word	0x000063ad
    7d08:	200092e4 	.word	0x200092e4
    7d0c:	000059e9 	.word	0x000059e9
    7d10:	000026e5 	.word	0x000026e5
    7d14:	000042d1 	.word	0x000042d1
		return ERR_OK;
    7d18:	2000      	movs	r0, #0
    7d1a:	4770      	bx	lr

00007d1c <tcp_rst>:
 * @param remote_ip the remote IP address to send the segment to
 * @param local_port the local TCP port to send the segment from
 * @param remote_port the remote TCP port to send the segment to
 */
void tcp_rst(u32_t seqno, u32_t ackno, ip_addr_t *local_ip, ip_addr_t *remote_ip, u16_t local_port, u16_t remote_port)
{
    7d1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7d20:	b083      	sub	sp, #12
    7d22:	4681      	mov	r9, r0
    7d24:	468a      	mov	sl, r1
    7d26:	4693      	mov	fp, r2
    7d28:	4698      	mov	r8, r3
	struct pbuf *   p;
	struct tcp_hdr *tcphdr;
	p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    7d2a:	2200      	movs	r2, #0
    7d2c:	2114      	movs	r1, #20
    7d2e:	2001      	movs	r0, #1
    7d30:	4b1d      	ldr	r3, [pc, #116]	; (7da8 <tcp_rst+0x8c>)
    7d32:	4798      	blx	r3
	if (p == NULL) {
    7d34:	2800      	cmp	r0, #0
    7d36:	d034      	beq.n	7da2 <tcp_rst+0x86>
    7d38:	4605      	mov	r5, r0
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
		return;
	}
	LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr", (p->len >= sizeof(struct tcp_hdr)));

	tcphdr        = (struct tcp_hdr *)p->payload;
    7d3a:	6844      	ldr	r4, [r0, #4]
	tcphdr->src   = htons(local_port);
    7d3c:	f8bd 0030 	ldrh.w	r0, [sp, #48]	; 0x30
    7d40:	4e1a      	ldr	r6, [pc, #104]	; (7dac <tcp_rst+0x90>)
    7d42:	47b0      	blx	r6
    7d44:	8020      	strh	r0, [r4, #0]
	tcphdr->dest  = htons(remote_port);
    7d46:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
    7d4a:	47b0      	blx	r6
    7d4c:	8060      	strh	r0, [r4, #2]
	tcphdr->seqno = htonl(seqno);
    7d4e:	4648      	mov	r0, r9
    7d50:	4f17      	ldr	r7, [pc, #92]	; (7db0 <tcp_rst+0x94>)
    7d52:	47b8      	blx	r7
    7d54:	6060      	str	r0, [r4, #4]
	tcphdr->ackno = htonl(ackno);
    7d56:	4650      	mov	r0, sl
    7d58:	47b8      	blx	r7
    7d5a:	60a0      	str	r0, [r4, #8]
	TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN / 4, TCP_RST | TCP_ACK);
    7d5c:	f245 0014 	movw	r0, #20500	; 0x5014
    7d60:	47b0      	blx	r6
    7d62:	81a0      	strh	r0, [r4, #12]
	tcphdr->wnd    = PP_HTONS(TCP_WND);
    7d64:	2600      	movs	r6, #0
    7d66:	2316      	movs	r3, #22
    7d68:	73a3      	strb	r3, [r4, #14]
    7d6a:	f06f 032f 	mvn.w	r3, #47	; 0x2f
    7d6e:	73e3      	strb	r3, [r4, #15]
	tcphdr->chksum = 0;
    7d70:	7426      	strb	r6, [r4, #16]
    7d72:	7466      	strb	r6, [r4, #17]
	tcphdr->urgp   = 0;
    7d74:	74a6      	strb	r6, [r4, #18]
    7d76:	74e6      	strb	r6, [r4, #19]

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip, IP_PROTO_TCP, p->tot_len);
    7d78:	892b      	ldrh	r3, [r5, #8]
    7d7a:	9300      	str	r3, [sp, #0]
    7d7c:	2306      	movs	r3, #6
    7d7e:	4642      	mov	r2, r8
    7d80:	4659      	mov	r1, fp
    7d82:	4628      	mov	r0, r5
    7d84:	4f0b      	ldr	r7, [pc, #44]	; (7db4 <tcp_rst+0x98>)
    7d86:	47b8      	blx	r7
    7d88:	8220      	strh	r0, [r4, #16]
#endif
	TCP_STATS_INC(tcp.xmit);
	snmp_inc_tcpoutrsts();
	/* Send output with hardcoded TTL since we have no access to the pcb */
	ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    7d8a:	2306      	movs	r3, #6
    7d8c:	9301      	str	r3, [sp, #4]
    7d8e:	9600      	str	r6, [sp, #0]
    7d90:	23ff      	movs	r3, #255	; 0xff
    7d92:	4642      	mov	r2, r8
    7d94:	4659      	mov	r1, fp
    7d96:	4628      	mov	r0, r5
    7d98:	4c07      	ldr	r4, [pc, #28]	; (7db8 <tcp_rst+0x9c>)
    7d9a:	47a0      	blx	r4
	pbuf_free(p);
    7d9c:	4628      	mov	r0, r5
    7d9e:	4b07      	ldr	r3, [pc, #28]	; (7dbc <tcp_rst+0xa0>)
    7da0:	4798      	blx	r3
	LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %" U32_F " ackno %" U32_F ".\n", seqno, ackno));
}
    7da2:	b003      	add	sp, #12
    7da4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7da8:	00005531 	.word	0x00005531
    7dac:	000026e5 	.word	0x000026e5
    7db0:	000026f9 	.word	0x000026f9
    7db4:	000042d1 	.word	0x000042d1
    7db8:	000046f9 	.word	0x000046f9
    7dbc:	000054c9 	.word	0x000054c9

00007dc0 <tcp_rexmit_rto>:
 */
void tcp_rexmit_rto(struct tcp_pcb *pcb)
{
	struct tcp_seg *seg;

	if (pcb->unacked == NULL) {
    7dc0:	6f02      	ldr	r2, [r0, #112]	; 0x70
    7dc2:	b10a      	cbz	r2, 7dc8 <tcp_rexmit_rto+0x8>
{
    7dc4:	b508      	push	{r3, lr}
    7dc6:	e001      	b.n	7dcc <tcp_rexmit_rto+0xc>
    7dc8:	4770      	bx	lr
		return;
	}

	/* Move all unacked segments to the head of the unsent queue */
	for (seg = pcb->unacked; seg->next != NULL; seg = seg->next)
    7dca:	461a      	mov	r2, r3
    7dcc:	6813      	ldr	r3, [r2, #0]
    7dce:	2b00      	cmp	r3, #0
    7dd0:	d1fb      	bne.n	7dca <tcp_rexmit_rto+0xa>
		;
	/* concatenate unsent queue after unacked queue */
	seg->next = pcb->unsent;
    7dd2:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    7dd4:	6013      	str	r3, [r2, #0]
	/* unsent queue is the concatenated queue (of unacked, unsent) */
	pcb->unsent = pcb->unacked;
    7dd6:	6f03      	ldr	r3, [r0, #112]	; 0x70
    7dd8:	66c3      	str	r3, [r0, #108]	; 0x6c
	/* unacked queue is now empty */
	pcb->unacked = NULL;
    7dda:	2200      	movs	r2, #0
    7ddc:	6702      	str	r2, [r0, #112]	; 0x70
	/* last unsent hasn't changed, no need to reset unsent_oversize */

	/* increment number of retransmissions */
	++pcb->nrtx;
    7dde:	f890 3046 	ldrb.w	r3, [r0, #70]	; 0x46
    7de2:	3301      	adds	r3, #1
    7de4:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46

	/* Don't take any RTT measurements after retransmitting. */
	pcb->rttest = 0;
    7de8:	6382      	str	r2, [r0, #56]	; 0x38

	/* Do the actual retransmission */
	tcp_output(pcb);
    7dea:	4b01      	ldr	r3, [pc, #4]	; (7df0 <tcp_rexmit_rto+0x30>)
    7dec:	4798      	blx	r3
    7dee:	bd08      	pop	{r3, pc}
    7df0:	00007a49 	.word	0x00007a49

00007df4 <tcp_rexmit>:
 * Called by tcp_receive() for fast retramsmit.
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void tcp_rexmit(struct tcp_pcb *pcb)
{
    7df4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct tcp_seg * seg;
	struct tcp_seg **cur_seg;

	if (pcb->unacked == NULL) {
    7df8:	6f07      	ldr	r7, [r0, #112]	; 0x70
    7dfa:	b317      	cbz	r7, 7e42 <tcp_rexmit+0x4e>
    7dfc:	4680      	mov	r8, r0
	}

	/* Move the first unacked segment to the unsent queue */
	/* Keep the unsent queue sorted. */
	seg          = pcb->unacked;
	pcb->unacked = seg->next;
    7dfe:	683b      	ldr	r3, [r7, #0]
    7e00:	6703      	str	r3, [r0, #112]	; 0x70

	cur_seg = &(pcb->unsent);
    7e02:	f100 056c 	add.w	r5, r0, #108	; 0x6c
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    7e06:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    7e08:	b173      	cbz	r3, 7e28 <tcp_rexmit+0x34>
    7e0a:	4e10      	ldr	r6, [pc, #64]	; (7e4c <tcp_rexmit+0x58>)
    7e0c:	691b      	ldr	r3, [r3, #16]
    7e0e:	6858      	ldr	r0, [r3, #4]
    7e10:	47b0      	blx	r6
    7e12:	4604      	mov	r4, r0
    7e14:	693b      	ldr	r3, [r7, #16]
    7e16:	6858      	ldr	r0, [r3, #4]
    7e18:	47b0      	blx	r6
    7e1a:	1a20      	subs	r0, r4, r0
    7e1c:	2800      	cmp	r0, #0
    7e1e:	da03      	bge.n	7e28 <tcp_rexmit+0x34>
		cur_seg = &((*cur_seg)->next);
    7e20:	682d      	ldr	r5, [r5, #0]
	while (*cur_seg && TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    7e22:	682b      	ldr	r3, [r5, #0]
    7e24:	2b00      	cmp	r3, #0
    7e26:	d1f1      	bne.n	7e0c <tcp_rexmit+0x18>
	}
	seg->next = *cur_seg;
    7e28:	682b      	ldr	r3, [r5, #0]
    7e2a:	603b      	str	r3, [r7, #0]
	*cur_seg  = seg;
    7e2c:	602f      	str	r7, [r5, #0]
#if TCP_OVERSIZE
	if (seg->next == NULL) {
    7e2e:	683b      	ldr	r3, [r7, #0]
    7e30:	b14b      	cbz	r3, 7e46 <tcp_rexmit+0x52>
		/* the retransmitted segment is last in unsent, so reset unsent_oversize */
		pcb->unsent_oversize = 0;
	}
#endif /* TCP_OVERSIZE */

	++pcb->nrtx;
    7e32:	f898 3046 	ldrb.w	r3, [r8, #70]	; 0x46
    7e36:	3301      	adds	r3, #1
    7e38:	f888 3046 	strb.w	r3, [r8, #70]	; 0x46

	/* Don't take any rtt measurements after retransmitting. */
	pcb->rttest = 0;
    7e3c:	2300      	movs	r3, #0
    7e3e:	f8c8 3038 	str.w	r3, [r8, #56]	; 0x38
    7e42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		pcb->unsent_oversize = 0;
    7e46:	f8a8 306a 	strh.w	r3, [r8, #106]	; 0x6a
    7e4a:	e7f2      	b.n	7e32 <tcp_rexmit+0x3e>
    7e4c:	00002711 	.word	0x00002711

00007e50 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void tcp_rexmit_fast(struct tcp_pcb *pcb)
{
	if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    7e50:	6f03      	ldr	r3, [r0, #112]	; 0x70
    7e52:	b11b      	cbz	r3, 7e5c <tcp_rexmit_fast+0xc>
    7e54:	7f83      	ldrb	r3, [r0, #30]
    7e56:	f013 0f04 	tst.w	r3, #4
    7e5a:	d000      	beq.n	7e5e <tcp_rexmit_fast+0xe>
    7e5c:	4770      	bx	lr
{
    7e5e:	b510      	push	{r4, lr}
    7e60:	4604      	mov	r4, r0
		LWIP_DEBUGF(TCP_FR_DEBUG,
		            ("tcp_receive: dupacks %" U16_F " (%" U32_F "), fast retransmit %" U32_F "\n",
		             (u16_t)pcb->dupacks,
		             pcb->lastack,
		             ntohl(pcb->unacked->tcphdr->seqno)));
		tcp_rexmit(pcb);
    7e62:	4b11      	ldr	r3, [pc, #68]	; (7ea8 <tcp_rexmit_fast+0x58>)
    7e64:	4798      	blx	r3

		/* Set ssthresh to half of the minimum of the current
		 * cwnd and the advertised window */
		if (pcb->cwnd > pcb->snd_wnd) {
    7e66:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
    7e6a:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
    7e6e:	4293      	cmp	r3, r2
			pcb->ssthresh = pcb->snd_wnd / 2;
    7e70:	bf87      	ittee	hi
    7e72:	0852      	lsrhi	r2, r2, #1
    7e74:	f8a4 204e 	strhhi.w	r2, [r4, #78]	; 0x4e
		} else {
			pcb->ssthresh = pcb->cwnd / 2;
    7e78:	085b      	lsrls	r3, r3, #1
    7e7a:	f8a4 304e 	strhls.w	r3, [r4, #78]	; 0x4e
		}

		/* The minimum value for ssthresh should be 2 MSS */
		if (pcb->ssthresh < 2 * pcb->mss) {
    7e7e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    7e80:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
    7e84:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
			LWIP_DEBUGF(TCP_FR_DEBUG,
			            ("tcp_receive: The minimum value for ssthresh %" U16_F " should be min 2 mss %" U16_F "...\n",
			             pcb->ssthresh,
			             2 * pcb->mss));
			pcb->ssthresh = 2 * pcb->mss;
    7e88:	bfbc      	itt	lt
    7e8a:	005a      	lsllt	r2, r3, #1
    7e8c:	f8a4 204e 	strhlt.w	r2, [r4, #78]	; 0x4e
		}

		pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    7e90:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    7e94:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
    7e98:	4413      	add	r3, r2
    7e9a:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
		pcb->flags |= TF_INFR;
    7e9e:	7fa3      	ldrb	r3, [r4, #30]
    7ea0:	f043 0304 	orr.w	r3, r3, #4
    7ea4:	77a3      	strb	r3, [r4, #30]
    7ea6:	bd10      	pop	{r4, pc}
    7ea8:	00007df5 	.word	0x00007df5

00007eac <tcp_keepalive>:
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void tcp_keepalive(struct tcp_pcb *pcb)
{
    7eac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7eb0:	b082      	sub	sp, #8
    7eb2:	4604      	mov	r4, r0
	            ("tcp_keepalive: tcp_ticks %" U32_F "   pcb->tmr %" U32_F " pcb->keep_cnt_sent %" U16_F "\n",
	             tcp_ticks,
	             pcb->tmr,
	             pcb->keep_cnt_sent));

	p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    7eb4:	6d00      	ldr	r0, [r0, #80]	; 0x50
    7eb6:	3801      	subs	r0, #1
    7eb8:	4b12      	ldr	r3, [pc, #72]	; (7f04 <tcp_keepalive+0x58>)
    7eba:	4798      	blx	r3
    7ebc:	4603      	mov	r3, r0
    7ebe:	2200      	movs	r2, #0
    7ec0:	4611      	mov	r1, r2
    7ec2:	4620      	mov	r0, r4
    7ec4:	4d10      	ldr	r5, [pc, #64]	; (7f08 <tcp_keepalive+0x5c>)
    7ec6:	47a8      	blx	r5
	if (p == NULL) {
    7ec8:	b1c0      	cbz	r0, 7efc <tcp_keepalive+0x50>
    7eca:	4605      	mov	r5, r0
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: could not allocate memory for pbuf\n"));
		return;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
    7ecc:	6847      	ldr	r7, [r0, #4]

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    7ece:	1d26      	adds	r6, r4, #4
    7ed0:	8903      	ldrh	r3, [r0, #8]
    7ed2:	9300      	str	r3, [sp, #0]
    7ed4:	2306      	movs	r3, #6
    7ed6:	4632      	mov	r2, r6
    7ed8:	4621      	mov	r1, r4
    7eda:	f8df 8038 	ldr.w	r8, [pc, #56]	; 7f14 <tcp_keepalive+0x68>
    7ede:	47c0      	blx	r8
    7ee0:	8238      	strh	r0, [r7, #16]

	/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    7ee2:	7aa3      	ldrb	r3, [r4, #10]
    7ee4:	2206      	movs	r2, #6
    7ee6:	9201      	str	r2, [sp, #4]
    7ee8:	2200      	movs	r2, #0
    7eea:	9200      	str	r2, [sp, #0]
    7eec:	4632      	mov	r2, r6
    7eee:	4621      	mov	r1, r4
    7ef0:	4628      	mov	r0, r5
    7ef2:	4c06      	ldr	r4, [pc, #24]	; (7f0c <tcp_keepalive+0x60>)
    7ef4:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

	pbuf_free(p);
    7ef6:	4628      	mov	r0, r5
    7ef8:	4b05      	ldr	r3, [pc, #20]	; (7f10 <tcp_keepalive+0x64>)
    7efa:	4798      	blx	r3

	LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %" U32_F " ackno %" U32_F ".\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    7efc:	b002      	add	sp, #8
    7efe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7f02:	bf00      	nop
    7f04:	000026f9 	.word	0x000026f9
    7f08:	00007839 	.word	0x00007839
    7f0c:	000046f9 	.word	0x000046f9
    7f10:	000054c9 	.word	0x000054c9
    7f14:	000042d1 	.word	0x000042d1

00007f18 <tcp_zero_window_probe>:
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void tcp_zero_window_probe(struct tcp_pcb *pcb)
{
    7f18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7f1c:	b082      	sub	sp, #8
	            ("tcp_zero_window_probe: tcp_ticks %" U32_F "   pcb->tmr %" U32_F " pcb->keep_cnt_sent %" U16_F "\n",
	             tcp_ticks,
	             pcb->tmr,
	             pcb->keep_cnt_sent));

	seg = pcb->unacked;
    7f1e:	6f05      	ldr	r5, [r0, #112]	; 0x70

	if (seg == NULL) {
    7f20:	b1fd      	cbz	r5, 7f62 <tcp_zero_window_probe+0x4a>
    7f22:	4604      	mov	r4, r0
	}
	if (seg == NULL) {
		return;
	}

	is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    7f24:	692b      	ldr	r3, [r5, #16]
    7f26:	8998      	ldrh	r0, [r3, #12]
    7f28:	4b26      	ldr	r3, [pc, #152]	; (7fc4 <tcp_zero_window_probe+0xac>)
    7f2a:	4798      	blx	r3
    7f2c:	f010 0f01 	tst.w	r0, #1
    7f30:	d001      	beq.n	7f36 <tcp_zero_window_probe+0x1e>
    7f32:	892b      	ldrh	r3, [r5, #8]
    7f34:	b1c3      	cbz	r3, 7f68 <tcp_zero_window_probe+0x50>
	/* we want to send one seqno: either FIN or data (no options) */
	len = is_fin ? 0 : 1;

	p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    7f36:	692b      	ldr	r3, [r5, #16]
    7f38:	685b      	ldr	r3, [r3, #4]
    7f3a:	2201      	movs	r2, #1
    7f3c:	2100      	movs	r1, #0
    7f3e:	4620      	mov	r0, r4
    7f40:	4e21      	ldr	r6, [pc, #132]	; (7fc8 <tcp_zero_window_probe+0xb0>)
    7f42:	47b0      	blx	r6
	if (p == NULL) {
    7f44:	4606      	mov	r6, r0
    7f46:	2800      	cmp	r0, #0
    7f48:	d039      	beq.n	7fbe <tcp_zero_window_probe+0xa6>
		LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
		return;
	}
	tcphdr = (struct tcp_hdr *)p->payload;
    7f4a:	6877      	ldr	r7, [r6, #4]
		/* Data segment, copy in one byte from the head of the unacked queue */
		char *d = ((char *)p->payload + TCP_HLEN);
		/* Depending on whether the segment has already been sent (unacked) or not
		   (unsent), seg->p->payload points to the IP header or TCP header.
		   Ensure we copy the first TCP data byte: */
		pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
    7f4c:	6868      	ldr	r0, [r5, #4]
    7f4e:	8903      	ldrh	r3, [r0, #8]
    7f50:	892a      	ldrh	r2, [r5, #8]
    7f52:	1a9b      	subs	r3, r3, r2
    7f54:	b29b      	uxth	r3, r3
    7f56:	2201      	movs	r2, #1
    7f58:	f107 0114 	add.w	r1, r7, #20
    7f5c:	4d1b      	ldr	r5, [pc, #108]	; (7fcc <tcp_zero_window_probe+0xb4>)
    7f5e:	47a8      	blx	r5
    7f60:	e015      	b.n	7f8e <tcp_zero_window_probe+0x76>
		seg = pcb->unsent;
    7f62:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
	if (seg == NULL) {
    7f64:	b35d      	cbz	r5, 7fbe <tcp_zero_window_probe+0xa6>
    7f66:	e7dc      	b.n	7f22 <tcp_zero_window_probe+0xa>
	p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    7f68:	692b      	ldr	r3, [r5, #16]
    7f6a:	685b      	ldr	r3, [r3, #4]
    7f6c:	2200      	movs	r2, #0
    7f6e:	4611      	mov	r1, r2
    7f70:	4620      	mov	r0, r4
    7f72:	4d15      	ldr	r5, [pc, #84]	; (7fc8 <tcp_zero_window_probe+0xb0>)
    7f74:	47a8      	blx	r5
	if (p == NULL) {
    7f76:	4606      	mov	r6, r0
    7f78:	b308      	cbz	r0, 7fbe <tcp_zero_window_probe+0xa6>
	tcphdr = (struct tcp_hdr *)p->payload;
    7f7a:	6877      	ldr	r7, [r6, #4]
		TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
    7f7c:	f9b7 500c 	ldrsh.w	r5, [r7, #12]
    7f80:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
    7f84:	2011      	movs	r0, #17
    7f86:	4b12      	ldr	r3, [pc, #72]	; (7fd0 <tcp_zero_window_probe+0xb8>)
    7f88:	4798      	blx	r3
    7f8a:	4328      	orrs	r0, r5
    7f8c:	81b8      	strh	r0, [r7, #12]
	}

#if CHECKSUM_GEN_TCP
	tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip, IP_PROTO_TCP, p->tot_len);
    7f8e:	1d25      	adds	r5, r4, #4
    7f90:	8933      	ldrh	r3, [r6, #8]
    7f92:	9300      	str	r3, [sp, #0]
    7f94:	2306      	movs	r3, #6
    7f96:	462a      	mov	r2, r5
    7f98:	4621      	mov	r1, r4
    7f9a:	4630      	mov	r0, r6
    7f9c:	f8df 803c 	ldr.w	r8, [pc, #60]	; 7fdc <tcp_zero_window_probe+0xc4>
    7fa0:	47c0      	blx	r8
    7fa2:	8238      	strh	r0, [r7, #16]

	/* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
	ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, &(pcb->addr_hint));
#else  /* LWIP_NETIF_HWADDRHINT*/
	ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    7fa4:	7aa3      	ldrb	r3, [r4, #10]
    7fa6:	2206      	movs	r2, #6
    7fa8:	9201      	str	r2, [sp, #4]
    7faa:	2200      	movs	r2, #0
    7fac:	9200      	str	r2, [sp, #0]
    7fae:	462a      	mov	r2, r5
    7fb0:	4621      	mov	r1, r4
    7fb2:	4630      	mov	r0, r6
    7fb4:	4c07      	ldr	r4, [pc, #28]	; (7fd4 <tcp_zero_window_probe+0xbc>)
    7fb6:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

	pbuf_free(p);
    7fb8:	4630      	mov	r0, r6
    7fba:	4b07      	ldr	r3, [pc, #28]	; (7fd8 <tcp_zero_window_probe+0xc0>)
    7fbc:	4798      	blx	r3

	LWIP_DEBUGF(TCP_DEBUG,
	            ("tcp_zero_window_probe: seqno %" U32_F " ackno %" U32_F ".\n", pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    7fbe:	b002      	add	sp, #8
    7fc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7fc4:	000026ef 	.word	0x000026ef
    7fc8:	00007839 	.word	0x00007839
    7fcc:	00005855 	.word	0x00005855
    7fd0:	000026e5 	.word	0x000026e5
    7fd4:	000046f9 	.word	0x000046f9
    7fd8:	000054c9 	.word	0x000054c9
    7fdc:	000042d1 	.word	0x000042d1

00007fe0 <sys_timeout>:
#if LWIP_DEBUG_TIMERNAMES
void sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else  /* LWIP_DEBUG_TIMERNAMES */
void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
    7fe0:	b570      	push	{r4, r5, r6, lr}
    7fe2:	4604      	mov	r4, r0
    7fe4:	460e      	mov	r6, r1
    7fe6:	4615      	mov	r5, r2
	struct sys_timeo *timeout, *t;

	timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    7fe8:	2007      	movs	r0, #7
    7fea:	4b1b      	ldr	r3, [pc, #108]	; (8058 <sys_timeout+0x78>)
    7fec:	4798      	blx	r3
	if (timeout == NULL) {
    7fee:	2800      	cmp	r0, #0
    7ff0:	d030      	beq.n	8054 <sys_timeout+0x74>
    7ff2:	4601      	mov	r1, r0
		LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
		return;
	}
	timeout->next = NULL;
    7ff4:	2300      	movs	r3, #0
    7ff6:	6003      	str	r3, [r0, #0]
	timeout->h    = handler;
    7ff8:	6086      	str	r6, [r0, #8]
	timeout->arg  = arg;
    7ffa:	60c5      	str	r5, [r0, #12]
	timeout->time = msecs;
    7ffc:	6044      	str	r4, [r0, #4]
	LWIP_DEBUGF(
	    TIMERS_DEBUG,
	    ("sys_timeout: %p msecs=%" U32_F " handler=%s arg=%p\n", (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

	if (next_timeout == NULL) {
    7ffe:	4b17      	ldr	r3, [pc, #92]	; (805c <sys_timeout+0x7c>)
    8000:	681d      	ldr	r5, [r3, #0]
    8002:	b1a5      	cbz	r5, 802e <sys_timeout+0x4e>
		next_timeout = timeout;
		return;
	}

	if (next_timeout->time > msecs) {
    8004:	6868      	ldr	r0, [r5, #4]
    8006:	4284      	cmp	r4, r0
    8008:	d313      	bcc.n	8032 <sys_timeout+0x52>
		next_timeout->time -= msecs;
		timeout->next = next_timeout;
		next_timeout  = timeout;
	} else {
		for (t = next_timeout; t != NULL; t = t->next) {
			timeout->time -= t->time;
    800a:	1a20      	subs	r0, r4, r0
    800c:	6048      	str	r0, [r1, #4]
			if (t->next == NULL || t->next->time > timeout->time) {
    800e:	682a      	ldr	r2, [r5, #0]
    8010:	b1f2      	cbz	r2, 8050 <sys_timeout+0x70>
    8012:	6853      	ldr	r3, [r2, #4]
    8014:	4298      	cmp	r0, r3
    8016:	d312      	bcc.n	803e <sys_timeout+0x5e>
			timeout->time -= t->time;
    8018:	6848      	ldr	r0, [r1, #4]
    801a:	6853      	ldr	r3, [r2, #4]
    801c:	1ac0      	subs	r0, r0, r3
    801e:	6048      	str	r0, [r1, #4]
			if (t->next == NULL || t->next->time > timeout->time) {
    8020:	6813      	ldr	r3, [r2, #0]
    8022:	b18b      	cbz	r3, 8048 <sys_timeout+0x68>
    8024:	685c      	ldr	r4, [r3, #4]
    8026:	42a0      	cmp	r0, r4
    8028:	d30b      	bcc.n	8042 <sys_timeout+0x62>
    802a:	461a      	mov	r2, r3
    802c:	e7f4      	b.n	8018 <sys_timeout+0x38>
		next_timeout = timeout;
    802e:	6018      	str	r0, [r3, #0]
		return;
    8030:	bd70      	pop	{r4, r5, r6, pc}
		next_timeout->time -= msecs;
    8032:	1b00      	subs	r0, r0, r4
    8034:	6068      	str	r0, [r5, #4]
		timeout->next = next_timeout;
    8036:	600d      	str	r5, [r1, #0]
		next_timeout  = timeout;
    8038:	4b08      	ldr	r3, [pc, #32]	; (805c <sys_timeout+0x7c>)
    803a:	6019      	str	r1, [r3, #0]
    803c:	bd70      	pop	{r4, r5, r6, pc}
			if (t->next == NULL || t->next->time > timeout->time) {
    803e:	4613      	mov	r3, r2
    8040:	462a      	mov	r2, r5
				if (t->next != NULL) {
					t->next->time -= timeout->time;
    8042:	685c      	ldr	r4, [r3, #4]
    8044:	1a20      	subs	r0, r4, r0
    8046:	6058      	str	r0, [r3, #4]
				}
				timeout->next = t->next;
    8048:	6813      	ldr	r3, [r2, #0]
    804a:	600b      	str	r3, [r1, #0]
				t->next       = timeout;
    804c:	6011      	str	r1, [r2, #0]
				break;
    804e:	bd70      	pop	{r4, r5, r6, pc}
			if (t->next == NULL || t->next->time > timeout->time) {
    8050:	462a      	mov	r2, r5
    8052:	e7f9      	b.n	8048 <sys_timeout+0x68>
    8054:	bd70      	pop	{r4, r5, r6, pc}
    8056:	bf00      	nop
    8058:	000051b9 	.word	0x000051b9
    805c:	20007fcc 	.word	0x20007fcc

00008060 <tcp_timer_needed>:
{
    8060:	b508      	push	{r3, lr}
	if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
    8062:	4b0a      	ldr	r3, [pc, #40]	; (808c <tcp_timer_needed+0x2c>)
    8064:	685b      	ldr	r3, [r3, #4]
    8066:	b953      	cbnz	r3, 807e <tcp_timer_needed+0x1e>
    8068:	4b09      	ldr	r3, [pc, #36]	; (8090 <tcp_timer_needed+0x30>)
    806a:	681b      	ldr	r3, [r3, #0]
    806c:	b143      	cbz	r3, 8080 <tcp_timer_needed+0x20>
		tcpip_tcp_timer_active = 1;
    806e:	2201      	movs	r2, #1
    8070:	4b06      	ldr	r3, [pc, #24]	; (808c <tcp_timer_needed+0x2c>)
    8072:	605a      	str	r2, [r3, #4]
		sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    8074:	2200      	movs	r2, #0
    8076:	4907      	ldr	r1, [pc, #28]	; (8094 <tcp_timer_needed+0x34>)
    8078:	20fa      	movs	r0, #250	; 0xfa
    807a:	4b07      	ldr	r3, [pc, #28]	; (8098 <tcp_timer_needed+0x38>)
    807c:	4798      	blx	r3
    807e:	bd08      	pop	{r3, pc}
	if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
    8080:	4b06      	ldr	r3, [pc, #24]	; (809c <tcp_timer_needed+0x3c>)
    8082:	681b      	ldr	r3, [r3, #0]
    8084:	2b00      	cmp	r3, #0
    8086:	d1f2      	bne.n	806e <tcp_timer_needed+0xe>
    8088:	e7f9      	b.n	807e <tcp_timer_needed+0x1e>
    808a:	bf00      	nop
    808c:	20007fcc 	.word	0x20007fcc
    8090:	200092e0 	.word	0x200092e0
    8094:	000080a1 	.word	0x000080a1
    8098:	00007fe1 	.word	0x00007fe1
    809c:	200092f4 	.word	0x200092f4

000080a0 <tcpip_tcp_timer>:
{
    80a0:	b508      	push	{r3, lr}
	tcp_tmr();
    80a2:	4b09      	ldr	r3, [pc, #36]	; (80c8 <tcpip_tcp_timer+0x28>)
    80a4:	4798      	blx	r3
	if (tcp_active_pcbs || tcp_tw_pcbs) {
    80a6:	4b09      	ldr	r3, [pc, #36]	; (80cc <tcpip_tcp_timer+0x2c>)
    80a8:	681b      	ldr	r3, [r3, #0]
    80aa:	b12b      	cbz	r3, 80b8 <tcpip_tcp_timer+0x18>
		sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    80ac:	2200      	movs	r2, #0
    80ae:	4908      	ldr	r1, [pc, #32]	; (80d0 <tcpip_tcp_timer+0x30>)
    80b0:	20fa      	movs	r0, #250	; 0xfa
    80b2:	4b08      	ldr	r3, [pc, #32]	; (80d4 <tcpip_tcp_timer+0x34>)
    80b4:	4798      	blx	r3
    80b6:	bd08      	pop	{r3, pc}
	if (tcp_active_pcbs || tcp_tw_pcbs) {
    80b8:	4b07      	ldr	r3, [pc, #28]	; (80d8 <tcpip_tcp_timer+0x38>)
    80ba:	681b      	ldr	r3, [r3, #0]
    80bc:	2b00      	cmp	r3, #0
    80be:	d1f5      	bne.n	80ac <tcpip_tcp_timer+0xc>
		tcpip_tcp_timer_active = 0;
    80c0:	2200      	movs	r2, #0
    80c2:	4b06      	ldr	r3, [pc, #24]	; (80dc <tcpip_tcp_timer+0x3c>)
    80c4:	605a      	str	r2, [r3, #4]
    80c6:	bd08      	pop	{r3, pc}
    80c8:	0000618d 	.word	0x0000618d
    80cc:	200092e0 	.word	0x200092e0
    80d0:	000080a1 	.word	0x000080a1
    80d4:	00007fe1 	.word	0x00007fe1
    80d8:	200092f4 	.word	0x200092f4
    80dc:	20007fcc 	.word	0x20007fcc

000080e0 <sys_timeouts_init>:
{
    80e0:	b510      	push	{r4, lr}
	sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    80e2:	2200      	movs	r2, #0
    80e4:	490c      	ldr	r1, [pc, #48]	; (8118 <sys_timeouts_init+0x38>)
    80e6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    80ea:	4c0c      	ldr	r4, [pc, #48]	; (811c <sys_timeouts_init+0x3c>)
    80ec:	47a0      	blx	r4
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    80ee:	2200      	movs	r2, #0
    80f0:	490b      	ldr	r1, [pc, #44]	; (8120 <sys_timeouts_init+0x40>)
    80f2:	f241 3088 	movw	r0, #5000	; 0x1388
    80f6:	47a0      	blx	r4
	sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
    80f8:	2200      	movs	r2, #0
    80fa:	490a      	ldr	r1, [pc, #40]	; (8124 <sys_timeouts_init+0x44>)
    80fc:	f64e 2060 	movw	r0, #60000	; 0xea60
    8100:	47a0      	blx	r4
	sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    8102:	2200      	movs	r2, #0
    8104:	4908      	ldr	r1, [pc, #32]	; (8128 <sys_timeouts_init+0x48>)
    8106:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    810a:	47a0      	blx	r4
	timeouts_last_time = sys_now();
    810c:	4b07      	ldr	r3, [pc, #28]	; (812c <sys_timeouts_init+0x4c>)
    810e:	4798      	blx	r3
    8110:	4b07      	ldr	r3, [pc, #28]	; (8130 <sys_timeouts_init+0x50>)
    8112:	6098      	str	r0, [r3, #8]
    8114:	bd10      	pop	{r4, pc}
    8116:	bf00      	nop
    8118:	00008195 	.word	0x00008195
    811c:	00007fe1 	.word	0x00007fe1
    8120:	00008175 	.word	0x00008175
    8124:	00008155 	.word	0x00008155
    8128:	00008135 	.word	0x00008135
    812c:	00009051 	.word	0x00009051
    8130:	20007fcc 	.word	0x20007fcc

00008134 <dhcp_timer_fine>:
{
    8134:	b508      	push	{r3, lr}
	dhcp_fine_tmr();
    8136:	4b04      	ldr	r3, [pc, #16]	; (8148 <dhcp_timer_fine+0x14>)
    8138:	4798      	blx	r3
	sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
    813a:	2200      	movs	r2, #0
    813c:	4903      	ldr	r1, [pc, #12]	; (814c <dhcp_timer_fine+0x18>)
    813e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    8142:	4b03      	ldr	r3, [pc, #12]	; (8150 <dhcp_timer_fine+0x1c>)
    8144:	4798      	blx	r3
    8146:	bd08      	pop	{r3, pc}
    8148:	00003ced 	.word	0x00003ced
    814c:	00008135 	.word	0x00008135
    8150:	00007fe1 	.word	0x00007fe1

00008154 <dhcp_timer_coarse>:
{
    8154:	b508      	push	{r3, lr}
	dhcp_coarse_tmr();
    8156:	4b04      	ldr	r3, [pc, #16]	; (8168 <dhcp_timer_coarse+0x14>)
    8158:	4798      	blx	r3
	sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
    815a:	2200      	movs	r2, #0
    815c:	4903      	ldr	r1, [pc, #12]	; (816c <dhcp_timer_coarse+0x18>)
    815e:	f64e 2060 	movw	r0, #60000	; 0xea60
    8162:	4b03      	ldr	r3, [pc, #12]	; (8170 <dhcp_timer_coarse+0x1c>)
    8164:	4798      	blx	r3
    8166:	bd08      	pop	{r3, pc}
    8168:	00003b21 	.word	0x00003b21
    816c:	00008155 	.word	0x00008155
    8170:	00007fe1 	.word	0x00007fe1

00008174 <arp_timer>:
{
    8174:	b508      	push	{r3, lr}
	etharp_tmr();
    8176:	4b04      	ldr	r3, [pc, #16]	; (8188 <arp_timer+0x14>)
    8178:	4798      	blx	r3
	sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    817a:	2200      	movs	r2, #0
    817c:	4903      	ldr	r1, [pc, #12]	; (818c <arp_timer+0x18>)
    817e:	f241 3088 	movw	r0, #5000	; 0x1388
    8182:	4b03      	ldr	r3, [pc, #12]	; (8190 <arp_timer+0x1c>)
    8184:	4798      	blx	r3
    8186:	bd08      	pop	{r3, pc}
    8188:	00008865 	.word	0x00008865
    818c:	00008175 	.word	0x00008175
    8190:	00007fe1 	.word	0x00007fe1

00008194 <ip_reass_timer>:
{
    8194:	b508      	push	{r3, lr}
	ip_reass_tmr();
    8196:	4b04      	ldr	r3, [pc, #16]	; (81a8 <ip_reass_timer+0x14>)
    8198:	4798      	blx	r3
	sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    819a:	2200      	movs	r2, #0
    819c:	4903      	ldr	r1, [pc, #12]	; (81ac <ip_reass_timer+0x18>)
    819e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    81a2:	4b03      	ldr	r3, [pc, #12]	; (81b0 <ip_reass_timer+0x1c>)
    81a4:	4798      	blx	r3
    81a6:	bd08      	pop	{r3, pc}
    81a8:	0000497d 	.word	0x0000497d
    81ac:	00008195 	.word	0x00008195
    81b0:	00007fe1 	.word	0x00007fe1

000081b4 <sys_check_timeouts>:
 *
 * Must be called periodically from your main loop.
 */
void sys_check_timeouts(void)
{
	if (next_timeout) {
    81b4:	4b15      	ldr	r3, [pc, #84]	; (820c <sys_check_timeouts+0x58>)
    81b6:	681b      	ldr	r3, [r3, #0]
    81b8:	b333      	cbz	r3, 8208 <sys_check_timeouts+0x54>
{
    81ba:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		sys_timeout_handler handler;
		void *              arg;
		u8_t                had_one;
		u32_t               now;

		now = sys_now();
    81be:	4b14      	ldr	r3, [pc, #80]	; (8210 <sys_check_timeouts+0x5c>)
    81c0:	4798      	blx	r3
    81c2:	4680      	mov	r8, r0
		/* this cares for wraparounds */
		diff = now - timeouts_last_time;
    81c4:	4b11      	ldr	r3, [pc, #68]	; (820c <sys_check_timeouts+0x58>)
    81c6:	689c      	ldr	r4, [r3, #8]
    81c8:	1b04      	subs	r4, r0, r4
		do {
#if PBUF_POOL_FREE_OOSEQ
			PBUF_CHECK_FREE_OOSEQ();
    81ca:	4f12      	ldr	r7, [pc, #72]	; (8214 <sys_check_timeouts+0x60>)
    81cc:	f8df 904c 	ldr.w	r9, [pc, #76]	; 821c <sys_check_timeouts+0x68>
#endif /* PBUF_POOL_FREE_OOSEQ */
			had_one    = 0;
			tmptimeout = next_timeout;
    81d0:	461d      	mov	r5, r3
			PBUF_CHECK_FREE_OOSEQ();
    81d2:	783b      	ldrb	r3, [r7, #0]
    81d4:	b9a3      	cbnz	r3, 8200 <sys_check_timeouts+0x4c>
			tmptimeout = next_timeout;
    81d6:	6829      	ldr	r1, [r5, #0]
			if (tmptimeout && (tmptimeout->time <= diff)) {
    81d8:	b1a1      	cbz	r1, 8204 <sys_check_timeouts+0x50>
    81da:	684b      	ldr	r3, [r1, #4]
    81dc:	429c      	cmp	r4, r3
    81de:	d311      	bcc.n	8204 <sys_check_timeouts+0x50>
				/* timeout has expired */
				had_one            = 1;
				timeouts_last_time = now;
    81e0:	f8c5 8008 	str.w	r8, [r5, #8]
				diff -= tmptimeout->time;
    81e4:	1ae4      	subs	r4, r4, r3
				next_timeout = tmptimeout->next;
    81e6:	680b      	ldr	r3, [r1, #0]
    81e8:	602b      	str	r3, [r5, #0]
				handler      = tmptimeout->h;
    81ea:	688e      	ldr	r6, [r1, #8]
				arg          = tmptimeout->arg;
    81ec:	f8d1 a00c 	ldr.w	sl, [r1, #12]
#if LWIP_DEBUG_TIMERNAMES
				if (handler != NULL) {
					LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s arg=%p\n", tmptimeout->handler_name, arg));
				}
#endif /* LWIP_DEBUG_TIMERNAMES */
				memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
    81f0:	2007      	movs	r0, #7
    81f2:	4b09      	ldr	r3, [pc, #36]	; (8218 <sys_check_timeouts+0x64>)
    81f4:	4798      	blx	r3
				if (handler != NULL) {
    81f6:	2e00      	cmp	r6, #0
    81f8:	d0eb      	beq.n	81d2 <sys_check_timeouts+0x1e>
					handler(arg);
    81fa:	4650      	mov	r0, sl
    81fc:	47b0      	blx	r6
    81fe:	e7e8      	b.n	81d2 <sys_check_timeouts+0x1e>
			PBUF_CHECK_FREE_OOSEQ();
    8200:	47c8      	blx	r9
    8202:	e7e8      	b.n	81d6 <sys_check_timeouts+0x22>
    8204:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8208:	4770      	bx	lr
    820a:	bf00      	nop
    820c:	20007fcc 	.word	0x20007fcc
    8210:	00009051 	.word	0x00009051
    8214:	200092d8 	.word	0x200092d8
    8218:	00005201 	.word	0x00005201
    821c:	000053a1 	.word	0x000053a1

00008220 <udp_init>:

/**
 * Initialize this module.
 */
void udp_init(void)
{
    8220:	4770      	bx	lr
	...

00008224 <udp_input>:
 * @param p pbuf to be demultiplexed to a UDP PCB.
 * @param inp network interface on which the datagram was received.
 *
 */
void udp_input(struct pbuf *p, struct netif *inp)
{
    8224:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8228:	b085      	sub	sp, #20
    822a:	4604      	mov	r4, r0
    822c:	4689      	mov	r9, r1

	PERF_START;

	UDP_STATS_INC(udp.recv);

	iphdr = (struct ip_hdr *)p->payload;
    822e:	6847      	ldr	r7, [r0, #4]
    8230:	7839      	ldrb	r1, [r7, #0]
    8232:	f001 010f 	and.w	r1, r1, #15

	/* Check minimum length (IP header + UDP header)
	 * and move payload pointer to UDP header */
	if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    8236:	8903      	ldrh	r3, [r0, #8]
    8238:	1c8a      	adds	r2, r1, #2
    823a:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
    823e:	db04      	blt.n	824a <udp_input+0x26>
    8240:	0089      	lsls	r1, r1, #2
    8242:	4249      	negs	r1, r1
    8244:	4b6a      	ldr	r3, [pc, #424]	; (83f0 <udp_input+0x1cc>)
    8246:	4798      	blx	r3
    8248:	b128      	cbz	r0, 8256 <udp_input+0x32>
		/* drop short packets */
		LWIP_DEBUGF(UDP_DEBUG, ("udp_input: short UDP datagram (%" U16_F " bytes) discarded\n", p->tot_len));
		UDP_STATS_INC(udp.lenerr);
		UDP_STATS_INC(udp.drop);
		snmp_inc_udpinerrors();
		pbuf_free(p);
    824a:	4620      	mov	r0, r4
    824c:	4b69      	ldr	r3, [pc, #420]	; (83f4 <udp_input+0x1d0>)
    824e:	4798      	blx	r3
	} else {
		pbuf_free(p);
	}
end:
	PERF_STOP("udp_input");
}
    8250:	b005      	add	sp, #20
    8252:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	udphdr = (struct udp_hdr *)p->payload;
    8256:	f8d4 a004 	ldr.w	sl, [r4, #4]
	broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    825a:	4649      	mov	r1, r9
    825c:	4b66      	ldr	r3, [pc, #408]	; (83f8 <udp_input+0x1d4>)
    825e:	6818      	ldr	r0, [r3, #0]
    8260:	4b66      	ldr	r3, [pc, #408]	; (83fc <udp_input+0x1d8>)
    8262:	4798      	blx	r3
    8264:	4680      	mov	r8, r0
	src  = ntohs(udphdr->src);
    8266:	f8ba 0000 	ldrh.w	r0, [sl]
    826a:	4e65      	ldr	r6, [pc, #404]	; (8400 <udp_input+0x1dc>)
    826c:	47b0      	blx	r6
    826e:	4605      	mov	r5, r0
	dest = ntohs(udphdr->dest);
    8270:	f8ba 0002 	ldrh.w	r0, [sl, #2]
    8274:	47b0      	blx	r6
	if (dest == DHCP_CLIENT_PORT) {
    8276:	2844      	cmp	r0, #68	; 0x44
    8278:	d014      	beq.n	82a4 <udp_input+0x80>
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    827a:	4b62      	ldr	r3, [pc, #392]	; (8404 <udp_input+0x1e0>)
    827c:	f8d3 e000 	ldr.w	lr, [r3]
    8280:	f1be 0f00 	cmp.w	lr, #0
    8284:	d010      	beq.n	82a8 <udp_input+0x84>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    8286:	4b5c      	ldr	r3, [pc, #368]	; (83f8 <udp_input+0x1d4>)
    8288:	f8d3 c000 	ldr.w	ip, [r3]
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    828c:	4b5e      	ldr	r3, [pc, #376]	; (8408 <udp_input+0x1e4>)
    828e:	f8d3 b000 	ldr.w	fp, [r3]
    8292:	4673      	mov	r3, lr
    8294:	2600      	movs	r6, #0
    8296:	4632      	mov	r2, r6
    8298:	9703      	str	r7, [sp, #12]
    829a:	4621      	mov	r1, r4
    829c:	4644      	mov	r4, r8
    829e:	46f0      	mov	r8, lr
    82a0:	468e      	mov	lr, r1
    82a2:	e097      	b.n	83d4 <udp_input+0x1b0>
		if (src == DHCP_SERVER_PORT) {
    82a4:	2d43      	cmp	r5, #67	; 0x43
    82a6:	d009      	beq.n	82bc <udp_input+0x98>
	if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    82a8:	f8d9 2004 	ldr.w	r2, [r9, #4]
    82ac:	4b52      	ldr	r3, [pc, #328]	; (83f8 <udp_input+0x1d4>)
    82ae:	681b      	ldr	r3, [r3, #0]
    82b0:	429a      	cmp	r2, r3
    82b2:	d053      	beq.n	835c <udp_input+0x138>
		pbuf_free(p);
    82b4:	4620      	mov	r0, r4
    82b6:	4b4f      	ldr	r3, [pc, #316]	; (83f4 <udp_input+0x1d0>)
    82b8:	4798      	blx	r3
}
    82ba:	e7c9      	b.n	8250 <udp_input+0x2c>
			if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
    82bc:	f8d9 3028 	ldr.w	r3, [r9, #40]	; 0x28
    82c0:	2b00      	cmp	r3, #0
    82c2:	d0f1      	beq.n	82a8 <udp_input+0x84>
    82c4:	685b      	ldr	r3, [r3, #4]
    82c6:	2b00      	cmp	r3, #0
    82c8:	d0ee      	beq.n	82a8 <udp_input+0x84>
				if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip)
    82ca:	f113 0f04 	cmn.w	r3, #4
    82ce:	d021      	beq.n	8314 <udp_input+0xf0>
    82d0:	685a      	ldr	r2, [r3, #4]
    82d2:	b1fa      	cbz	r2, 8314 <udp_input+0xf0>
				     || ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
    82d4:	494c      	ldr	r1, [pc, #304]	; (8408 <udp_input+0x1e4>)
    82d6:	6809      	ldr	r1, [r1, #0]
    82d8:	428a      	cmp	r2, r1
    82da:	d1e5      	bne.n	82a8 <udp_input+0x84>
    82dc:	e01a      	b.n	8314 <udp_input+0xf0>
					if ((uncon_pcb == NULL) && ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    82de:	7c19      	ldrb	r1, [r3, #16]
    82e0:	f001 0104 	and.w	r1, r1, #4
    82e4:	2900      	cmp	r1, #0
    82e6:	bf08      	it	eq
    82e8:	461e      	moveq	r6, r3
    82ea:	e06b      	b.n	83c4 <udp_input+0x1a0>
			    && (ip_addr_isany(&pcb->remote_ip) || ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    82ec:	f113 0f04 	cmn.w	r3, #4
    82f0:	d003      	beq.n	82fa <udp_input+0xd6>
    82f2:	6859      	ldr	r1, [r3, #4]
    82f4:	b109      	cbz	r1, 82fa <udp_input+0xd6>
    82f6:	4559      	cmp	r1, fp
    82f8:	d167      	bne.n	83ca <udp_input+0x1a6>
    82fa:	9f03      	ldr	r7, [sp, #12]
    82fc:	4671      	mov	r1, lr
    82fe:	46c6      	mov	lr, r8
    8300:	46a0      	mov	r8, r4
    8302:	460c      	mov	r4, r1
				if (prev != NULL) {
    8304:	b12a      	cbz	r2, 8312 <udp_input+0xee>
					prev->next = pcb->next;
    8306:	68d9      	ldr	r1, [r3, #12]
    8308:	60d1      	str	r1, [r2, #12]
					pcb->next  = udp_pcbs;
    830a:	f8c3 e00c 	str.w	lr, [r3, #12]
					udp_pcbs   = pcb;
    830e:	4a3d      	ldr	r2, [pc, #244]	; (8404 <udp_input+0x1e0>)
    8310:	6013      	str	r3, [r2, #0]
		if (pcb == NULL) {
    8312:	b123      	cbz	r3, 831e <udp_input+0xfa>
    8314:	461e      	mov	r6, r3
    8316:	e004      	b.n	8322 <udp_input+0xfe>
    8318:	9f03      	ldr	r7, [sp, #12]
    831a:	46a0      	mov	r8, r4
    831c:	4674      	mov	r4, lr
	if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    831e:	2e00      	cmp	r6, #0
    8320:	d0c2      	beq.n	82a8 <udp_input+0x84>
			if (udphdr->chksum != 0) {
    8322:	f8ba 3006 	ldrh.w	r3, [sl, #6]
    8326:	b14b      	cbz	r3, 833c <udp_input+0x118>
				if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(), IP_PROTO_UDP, p->tot_len)
    8328:	8923      	ldrh	r3, [r4, #8]
    832a:	9300      	str	r3, [sp, #0]
    832c:	2311      	movs	r3, #17
    832e:	4a32      	ldr	r2, [pc, #200]	; (83f8 <udp_input+0x1d4>)
    8330:	4935      	ldr	r1, [pc, #212]	; (8408 <udp_input+0x1e4>)
    8332:	4620      	mov	r0, r4
    8334:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 8410 <udp_input+0x1ec>
    8338:	47c8      	blx	r9
    833a:	b988      	cbnz	r0, 8360 <udp_input+0x13c>
		if (pbuf_header(p, -UDP_HLEN)) {
    833c:	f06f 0107 	mvn.w	r1, #7
    8340:	4620      	mov	r0, r4
    8342:	4b2b      	ldr	r3, [pc, #172]	; (83f0 <udp_input+0x1cc>)
    8344:	4798      	blx	r3
    8346:	b978      	cbnz	r0, 8368 <udp_input+0x144>
		if (pcb != NULL) {
    8348:	b1b6      	cbz	r6, 8378 <udp_input+0x154>
			if (pcb->recv != NULL) {
    834a:	69b7      	ldr	r7, [r6, #24]
    834c:	b187      	cbz	r7, 8370 <udp_input+0x14c>
				pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
    834e:	69f0      	ldr	r0, [r6, #28]
    8350:	9500      	str	r5, [sp, #0]
    8352:	4b2d      	ldr	r3, [pc, #180]	; (8408 <udp_input+0x1e4>)
    8354:	4622      	mov	r2, r4
    8356:	4631      	mov	r1, r6
    8358:	47b8      	blx	r7
    835a:	e779      	b.n	8250 <udp_input+0x2c>
    835c:	2600      	movs	r6, #0
    835e:	e7e0      	b.n	8322 <udp_input+0xfe>
					pbuf_free(p);
    8360:	4620      	mov	r0, r4
    8362:	4b24      	ldr	r3, [pc, #144]	; (83f4 <udp_input+0x1d0>)
    8364:	4798      	blx	r3
					goto end;
    8366:	e773      	b.n	8250 <udp_input+0x2c>
			pbuf_free(p);
    8368:	4620      	mov	r0, r4
    836a:	4b22      	ldr	r3, [pc, #136]	; (83f4 <udp_input+0x1d0>)
    836c:	4798      	blx	r3
			goto end;
    836e:	e76f      	b.n	8250 <udp_input+0x2c>
				pbuf_free(p);
    8370:	4620      	mov	r0, r4
    8372:	4b20      	ldr	r3, [pc, #128]	; (83f4 <udp_input+0x1d0>)
    8374:	4798      	blx	r3
				goto end;
    8376:	e76b      	b.n	8250 <udp_input+0x2c>
			if (!broadcast && !ip_addr_ismulticast(&current_iphdr_dest)) {
    8378:	f1b8 0f00 	cmp.w	r8, #0
    837c:	d111      	bne.n	83a2 <udp_input+0x17e>
    837e:	4b1e      	ldr	r3, [pc, #120]	; (83f8 <udp_input+0x1d4>)
    8380:	681b      	ldr	r3, [r3, #0]
    8382:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    8386:	2be0      	cmp	r3, #224	; 0xe0
    8388:	d00b      	beq.n	83a2 <udp_input+0x17e>
				pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
    838a:	7839      	ldrb	r1, [r7, #0]
    838c:	f001 010f 	and.w	r1, r1, #15
    8390:	3102      	adds	r1, #2
    8392:	0089      	lsls	r1, r1, #2
    8394:	4620      	mov	r0, r4
    8396:	4b16      	ldr	r3, [pc, #88]	; (83f0 <udp_input+0x1cc>)
    8398:	4798      	blx	r3
				icmp_dest_unreach(p, ICMP_DUR_PORT);
    839a:	2103      	movs	r1, #3
    839c:	4620      	mov	r0, r4
    839e:	4b1b      	ldr	r3, [pc, #108]	; (840c <udp_input+0x1e8>)
    83a0:	4798      	blx	r3
			pbuf_free(p);
    83a2:	4620      	mov	r0, r4
    83a4:	4b13      	ldr	r3, [pc, #76]	; (83f4 <udp_input+0x1d0>)
    83a6:	4798      	blx	r3
    83a8:	e752      	b.n	8250 <udp_input+0x2c>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    83aa:	6819      	ldr	r1, [r3, #0]
    83ac:	458c      	cmp	ip, r1
    83ae:	d007      	beq.n	83c0 <udp_input+0x19c>
				     && (ip_addr_isany(&pcb->local_ip)
    83b0:	b133      	cbz	r3, 83c0 <udp_input+0x19c>
    83b2:	b129      	cbz	r1, 83c0 <udp_input+0x19c>
				         || ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
    83b4:	ea8c 0701 	eor.w	r7, ip, r1
    83b8:	f8d9 1008 	ldr.w	r1, [r9, #8]
    83bc:	420f      	tst	r7, r1
    83be:	d104      	bne.n	83ca <udp_input+0x1a6>
					if ((uncon_pcb == NULL) && ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    83c0:	2e00      	cmp	r6, #0
    83c2:	d08c      	beq.n	82de <udp_input+0xba>
			if ((local_match != 0) && (pcb->remote_port == src)
    83c4:	8a99      	ldrh	r1, [r3, #20]
    83c6:	42a9      	cmp	r1, r5
    83c8:	d090      	beq.n	82ec <udp_input+0xc8>
		for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    83ca:	68d9      	ldr	r1, [r3, #12]
    83cc:	461a      	mov	r2, r3
    83ce:	2900      	cmp	r1, #0
    83d0:	d0a2      	beq.n	8318 <udp_input+0xf4>
    83d2:	460b      	mov	r3, r1
			if (pcb->local_port == dest) {
    83d4:	8a59      	ldrh	r1, [r3, #18]
    83d6:	4281      	cmp	r1, r0
    83d8:	d1f7      	bne.n	83ca <udp_input+0x1a6>
				if ((!broadcast && ip_addr_isany(&pcb->local_ip)) || ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)
    83da:	2c00      	cmp	r4, #0
    83dc:	d1e5      	bne.n	83aa <udp_input+0x186>
    83de:	2b00      	cmp	r3, #0
    83e0:	d0ee      	beq.n	83c0 <udp_input+0x19c>
    83e2:	6819      	ldr	r1, [r3, #0]
    83e4:	2900      	cmp	r1, #0
    83e6:	d0eb      	beq.n	83c0 <udp_input+0x19c>
    83e8:	4561      	cmp	r1, ip
    83ea:	d1ee      	bne.n	83ca <udp_input+0x1a6>
    83ec:	e7e8      	b.n	83c0 <udp_input+0x19c>
    83ee:	bf00      	nop
    83f0:	00005435 	.word	0x00005435
    83f4:	000054c9 	.word	0x000054c9
    83f8:	20008314 	.word	0x20008314
    83fc:	00004739 	.word	0x00004739
    8400:	000026ef 	.word	0x000026ef
    8404:	200092fc 	.word	0x200092fc
    8408:	2000830c 	.word	0x2000830c
    840c:	00004239 	.word	0x00004239
    8410:	000042d1 	.word	0x000042d1

00008414 <udp_bind>:
 * another UDP PCB.
 *
 * @see udp_disconnect()
 */
err_t udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    8414:	b5f0      	push	{r4, r5, r6, r7, lr}
	ip_addr_debug_print(UDP_DEBUG, ipaddr);
	LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %" U16_F ")\n", port));

	rebind = 0;
	/* Check for double bind and rebind of the same pcb */
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    8416:	4b34      	ldr	r3, [pc, #208]	; (84e8 <udp_bind+0xd4>)
    8418:	681b      	ldr	r3, [r3, #0]
    841a:	b1cb      	cbz	r3, 8450 <udp_bind+0x3c>
    841c:	2600      	movs	r6, #0
		/* is this UDP PCB already on active list? */
		if (pcb == ipcb) {
			/* pcb may occur at most once in active list */
			LWIP_ASSERT("rebind == 0", rebind == 0);
			/* pcb already in list, just rebind */
			rebind = 1;
    841e:	2701      	movs	r7, #1
    8420:	e002      	b.n	8428 <udp_bind+0x14>
    8422:	463e      	mov	r6, r7
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    8424:	68db      	ldr	r3, [r3, #12]
    8426:	b1a3      	cbz	r3, 8452 <udp_bind+0x3e>
		if (pcb == ipcb) {
    8428:	4298      	cmp	r0, r3
    842a:	d0fa      	beq.n	8422 <udp_bind+0xe>
		else if (!ip_get_option(pcb, SOF_REUSEADDR) && !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else  /* SO_REUSE */
		/* port matches that of PCB in list and REUSEADDR not set -> reject */
		else {
#endif /* SO_REUSE */
			if ((ipcb->local_port == port) &&
    842c:	8a5c      	ldrh	r4, [r3, #18]
    842e:	4294      	cmp	r4, r2
    8430:	d1f8      	bne.n	8424 <udp_bind+0x10>
    8432:	2b00      	cmp	r3, #0
    8434:	d04a      	beq.n	84cc <udp_bind+0xb8>
			    /* IP address matches, or one is IP_ADDR_ANY? */
			    (ip_addr_isany(&(ipcb->local_ip)) || ip_addr_isany(ipaddr) || ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
    8436:	681c      	ldr	r4, [r3, #0]
    8438:	2c00      	cmp	r4, #0
    843a:	d04a      	beq.n	84d2 <udp_bind+0xbe>
    843c:	2900      	cmp	r1, #0
    843e:	d04b      	beq.n	84d8 <udp_bind+0xc4>
    8440:	680d      	ldr	r5, [r1, #0]
    8442:	2d00      	cmp	r5, #0
    8444:	d04b      	beq.n	84de <udp_bind+0xca>
    8446:	42ac      	cmp	r4, r5
    8448:	d1ec      	bne.n	8424 <udp_bind+0x10>
				/* other PCB already binds to this local IP and port */
				LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: local port %" U16_F " already bound by another pcb\n", port));
				return ERR_USE;
    844a:	f06f 0007 	mvn.w	r0, #7
    844e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	rebind = 0;
    8450:	2600      	movs	r6, #0
			}
		}
	}

	ip_addr_set(&pcb->local_ip, ipaddr);
    8452:	b159      	cbz	r1, 846c <udp_bind+0x58>
    8454:	680b      	ldr	r3, [r1, #0]
    8456:	6003      	str	r3, [r0, #0]

	/* no port specified? */
	if (port == 0) {
    8458:	b152      	cbz	r2, 8470 <udp_bind+0x5c>
			/* no more ports available in local range */
			LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
			return ERR_USE;
		}
	}
	pcb->local_port = port;
    845a:	8242      	strh	r2, [r0, #18]
	snmp_insert_udpidx_tree(pcb);
	/* pcb not active yet? */
	if (rebind == 0) {
    845c:	2e00      	cmp	r6, #0
    845e:	d141      	bne.n	84e4 <udp_bind+0xd0>
		/* place the PCB on the active list if not already there */
		pcb->next = udp_pcbs;
    8460:	4b21      	ldr	r3, [pc, #132]	; (84e8 <udp_bind+0xd4>)
    8462:	681a      	ldr	r2, [r3, #0]
    8464:	60c2      	str	r2, [r0, #12]
		udp_pcbs  = pcb;
    8466:	6018      	str	r0, [r3, #0]
	             ip4_addr1_16(&pcb->local_ip),
	             ip4_addr2_16(&pcb->local_ip),
	             ip4_addr3_16(&pcb->local_ip),
	             ip4_addr4_16(&pcb->local_ip),
	             pcb->local_port));
	return ERR_OK;
    8468:	2000      	movs	r0, #0
    846a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ip_addr_set(&pcb->local_ip, ipaddr);
    846c:	2300      	movs	r3, #0
    846e:	e7f2      	b.n	8456 <udp_bind+0x42>
    8470:	4b1e      	ldr	r3, [pc, #120]	; (84ec <udp_bind+0xd8>)
    8472:	8819      	ldrh	r1, [r3, #0]
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    8474:	4b1c      	ldr	r3, [pc, #112]	; (84e8 <udp_bind+0xd4>)
    8476:	681c      	ldr	r4, [r3, #0]
    8478:	f44f 4580 	mov.w	r5, #16384	; 0x4000
	if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    847c:	f64f 77ff 	movw	r7, #65535	; 0xffff
		udp_port = UDP_LOCAL_PORT_RANGE_START;
    8480:	f44f 4e40 	mov.w	lr, #49152	; 0xc000
	if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    8484:	42b9      	cmp	r1, r7
    8486:	bf1a      	itte	ne
    8488:	3101      	addne	r1, #1
    848a:	b289      	uxthne	r1, r1
		udp_port = UDP_LOCAL_PORT_RANGE_START;
    848c:	4671      	moveq	r1, lr
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    848e:	b18c      	cbz	r4, 84b4 <udp_bind+0xa0>
		if (pcb->local_port == udp_port) {
    8490:	8a63      	ldrh	r3, [r4, #18]
    8492:	428b      	cmp	r3, r1
    8494:	d005      	beq.n	84a2 <udp_bind+0x8e>
    8496:	4623      	mov	r3, r4
	for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    8498:	68db      	ldr	r3, [r3, #12]
    849a:	b173      	cbz	r3, 84ba <udp_bind+0xa6>
		if (pcb->local_port == udp_port) {
    849c:	8a5a      	ldrh	r2, [r3, #18]
    849e:	428a      	cmp	r2, r1
    84a0:	d1fa      	bne.n	8498 <udp_bind+0x84>
    84a2:	3d01      	subs	r5, #1
    84a4:	b2ad      	uxth	r5, r5
			if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
    84a6:	2d00      	cmp	r5, #0
    84a8:	d1ec      	bne.n	8484 <udp_bind+0x70>
    84aa:	4b10      	ldr	r3, [pc, #64]	; (84ec <udp_bind+0xd8>)
    84ac:	8019      	strh	r1, [r3, #0]
			return ERR_USE;
    84ae:	f06f 0007 	mvn.w	r0, #7
    84b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    84b4:	4b0d      	ldr	r3, [pc, #52]	; (84ec <udp_bind+0xd8>)
    84b6:	8019      	strh	r1, [r3, #0]
    84b8:	e001      	b.n	84be <udp_bind+0xaa>
    84ba:	4b0c      	ldr	r3, [pc, #48]	; (84ec <udp_bind+0xd8>)
    84bc:	8019      	strh	r1, [r3, #0]
	return udp_port;
    84be:	4b0b      	ldr	r3, [pc, #44]	; (84ec <udp_bind+0xd8>)
    84c0:	881a      	ldrh	r2, [r3, #0]
		if (port == 0) {
    84c2:	2a00      	cmp	r2, #0
    84c4:	d1c9      	bne.n	845a <udp_bind+0x46>
			return ERR_USE;
    84c6:	f06f 0007 	mvn.w	r0, #7
    84ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
				return ERR_USE;
    84cc:	f06f 0007 	mvn.w	r0, #7
    84d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    84d2:	f06f 0007 	mvn.w	r0, #7
    84d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    84d8:	f06f 0007 	mvn.w	r0, #7
    84dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    84de:	f06f 0007 	mvn.w	r0, #7
    84e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return ERR_OK;
    84e4:	2000      	movs	r0, #0
}
    84e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    84e8:	200092fc 	.word	0x200092fc
    84ec:	2000000c 	.word	0x2000000c

000084f0 <udp_sendto_if>:
{
    84f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    84f4:	b085      	sub	sp, #20
    84f6:	4604      	mov	r4, r0
    84f8:	460f      	mov	r7, r1
    84fa:	4692      	mov	sl, r2
    84fc:	469b      	mov	fp, r3
    84fe:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
	if (pcb->local_port == 0) {
    8502:	8a43      	ldrh	r3, [r0, #18]
    8504:	b933      	cbnz	r3, 8514 <udp_sendto_if+0x24>
		err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    8506:	2200      	movs	r2, #0
    8508:	4601      	mov	r1, r0
    850a:	4b35      	ldr	r3, [pc, #212]	; (85e0 <udp_sendto_if+0xf0>)
    850c:	4798      	blx	r3
		if (err != ERR_OK) {
    850e:	4605      	mov	r5, r0
    8510:	2800      	cmp	r0, #0
    8512:	d13f      	bne.n	8594 <udp_sendto_if+0xa4>
	if (pbuf_header(p, UDP_HLEN)) {
    8514:	2108      	movs	r1, #8
    8516:	4638      	mov	r0, r7
    8518:	4b32      	ldr	r3, [pc, #200]	; (85e4 <udp_sendto_if+0xf4>)
    851a:	4798      	blx	r3
    851c:	b168      	cbz	r0, 853a <udp_sendto_if+0x4a>
		q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    851e:	2200      	movs	r2, #0
    8520:	2108      	movs	r1, #8
    8522:	2001      	movs	r0, #1
    8524:	4b30      	ldr	r3, [pc, #192]	; (85e8 <udp_sendto_if+0xf8>)
    8526:	4798      	blx	r3
		if (q == NULL) {
    8528:	4606      	mov	r6, r0
    852a:	2800      	cmp	r0, #0
    852c:	d052      	beq.n	85d4 <udp_sendto_if+0xe4>
		if (p->tot_len != 0) {
    852e:	893b      	ldrh	r3, [r7, #8]
    8530:	b123      	cbz	r3, 853c <udp_sendto_if+0x4c>
			pbuf_chain(q, p);
    8532:	4639      	mov	r1, r7
    8534:	4b2d      	ldr	r3, [pc, #180]	; (85ec <udp_sendto_if+0xfc>)
    8536:	4798      	blx	r3
    8538:	e000      	b.n	853c <udp_sendto_if+0x4c>
		q = p;
    853a:	463e      	mov	r6, r7
	udphdr       = (struct udp_hdr *)q->payload;
    853c:	6875      	ldr	r5, [r6, #4]
	udphdr->src  = htons(pcb->local_port);
    853e:	8a60      	ldrh	r0, [r4, #18]
    8540:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 85f0 <udp_sendto_if+0x100>
    8544:	47c0      	blx	r8
    8546:	8028      	strh	r0, [r5, #0]
	udphdr->dest = htons(dst_port);
    8548:	4658      	mov	r0, fp
    854a:	47c0      	blx	r8
    854c:	8068      	strh	r0, [r5, #2]
	udphdr->chksum = 0x0000;
    854e:	2300      	movs	r3, #0
    8550:	71ab      	strb	r3, [r5, #6]
    8552:	71eb      	strb	r3, [r5, #7]
	if (ip_addr_isany(&pcb->local_ip)) {
    8554:	46a0      	mov	r8, r4
    8556:	b10c      	cbz	r4, 855c <udp_sendto_if+0x6c>
    8558:	6823      	ldr	r3, [r4, #0]
    855a:	b9fb      	cbnz	r3, 859c <udp_sendto_if+0xac>
		src_ip = &(netif->ip_addr);
    855c:	f109 0804 	add.w	r8, r9, #4
		udphdr->len = htons(q->tot_len);
    8560:	8930      	ldrh	r0, [r6, #8]
    8562:	4b23      	ldr	r3, [pc, #140]	; (85f0 <udp_sendto_if+0x100>)
    8564:	4798      	blx	r3
    8566:	80a8      	strh	r0, [r5, #4]
		if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
    8568:	7c23      	ldrb	r3, [r4, #16]
    856a:	f013 0f01 	tst.w	r3, #1
    856e:	d021      	beq.n	85b4 <udp_sendto_if+0xc4>
		err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
    8570:	7aa3      	ldrb	r3, [r4, #10]
    8572:	f8cd 9008 	str.w	r9, [sp, #8]
    8576:	2211      	movs	r2, #17
    8578:	9201      	str	r2, [sp, #4]
    857a:	7a62      	ldrb	r2, [r4, #9]
    857c:	9200      	str	r2, [sp, #0]
    857e:	4652      	mov	r2, sl
    8580:	4641      	mov	r1, r8
    8582:	4630      	mov	r0, r6
    8584:	4c1b      	ldr	r4, [pc, #108]	; (85f4 <udp_sendto_if+0x104>)
    8586:	47a0      	blx	r4
    8588:	4605      	mov	r5, r0
	if (q != p) {
    858a:	42be      	cmp	r6, r7
    858c:	d002      	beq.n	8594 <udp_sendto_if+0xa4>
		pbuf_free(q);
    858e:	4630      	mov	r0, r6
    8590:	4b19      	ldr	r3, [pc, #100]	; (85f8 <udp_sendto_if+0x108>)
    8592:	4798      	blx	r3
}
    8594:	4628      	mov	r0, r5
    8596:	b005      	add	sp, #20
    8598:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
    859c:	f8d9 2004 	ldr.w	r2, [r9, #4]
    85a0:	4293      	cmp	r3, r2
    85a2:	d0dd      	beq.n	8560 <udp_sendto_if+0x70>
			if (q != p) {
    85a4:	42be      	cmp	r6, r7
    85a6:	d018      	beq.n	85da <udp_sendto_if+0xea>
				pbuf_free(q);
    85a8:	4630      	mov	r0, r6
    85aa:	4b13      	ldr	r3, [pc, #76]	; (85f8 <udp_sendto_if+0x108>)
    85ac:	4798      	blx	r3
			return ERR_VAL;
    85ae:	f06f 0505 	mvn.w	r5, #5
    85b2:	e7ef      	b.n	8594 <udp_sendto_if+0xa4>
				udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
    85b4:	8933      	ldrh	r3, [r6, #8]
    85b6:	9300      	str	r3, [sp, #0]
    85b8:	2311      	movs	r3, #17
    85ba:	4652      	mov	r2, sl
    85bc:	4641      	mov	r1, r8
    85be:	4630      	mov	r0, r6
    85c0:	f8df b038 	ldr.w	fp, [pc, #56]	; 85fc <udp_sendto_if+0x10c>
    85c4:	47d8      	blx	fp
			udphdr->chksum = udpchksum;
    85c6:	f64f 73ff 	movw	r3, #65535	; 0xffff
    85ca:	2800      	cmp	r0, #0
    85cc:	bf08      	it	eq
    85ce:	4618      	moveq	r0, r3
    85d0:	80e8      	strh	r0, [r5, #6]
    85d2:	e7cd      	b.n	8570 <udp_sendto_if+0x80>
			return ERR_MEM;
    85d4:	f04f 35ff 	mov.w	r5, #4294967295
    85d8:	e7dc      	b.n	8594 <udp_sendto_if+0xa4>
			return ERR_VAL;
    85da:	f06f 0505 	mvn.w	r5, #5
    85de:	e7d9      	b.n	8594 <udp_sendto_if+0xa4>
    85e0:	00008415 	.word	0x00008415
    85e4:	00005435 	.word	0x00005435
    85e8:	00005531 	.word	0x00005531
    85ec:	0000573d 	.word	0x0000573d
    85f0:	000026e5 	.word	0x000026e5
    85f4:	000045fd 	.word	0x000045fd
    85f8:	000054c9 	.word	0x000054c9
    85fc:	000042d1 	.word	0x000042d1

00008600 <udp_sendto>:
{
    8600:	b5f0      	push	{r4, r5, r6, r7, lr}
    8602:	b083      	sub	sp, #12
    8604:	4605      	mov	r5, r0
    8606:	460e      	mov	r6, r1
    8608:	4614      	mov	r4, r2
    860a:	461f      	mov	r7, r3
	netif = ip_route(dst_ip);
    860c:	4610      	mov	r0, r2
    860e:	4b07      	ldr	r3, [pc, #28]	; (862c <udp_sendto+0x2c>)
    8610:	4798      	blx	r3
	if (netif == NULL) {
    8612:	b140      	cbz	r0, 8626 <udp_sendto+0x26>
	return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
    8614:	9000      	str	r0, [sp, #0]
    8616:	463b      	mov	r3, r7
    8618:	4622      	mov	r2, r4
    861a:	4631      	mov	r1, r6
    861c:	4628      	mov	r0, r5
    861e:	4c04      	ldr	r4, [pc, #16]	; (8630 <udp_sendto+0x30>)
    8620:	47a0      	blx	r4
}
    8622:	b003      	add	sp, #12
    8624:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_RTE;
    8626:	f06f 0003 	mvn.w	r0, #3
    862a:	e7fa      	b.n	8622 <udp_sendto+0x22>
    862c:	000043cd 	.word	0x000043cd
    8630:	000084f1 	.word	0x000084f1

00008634 <udp_connect>:
 * The udp pcb is bound to a random local port if not already bound.
 *
 * @see udp_disconnect()
 */
err_t udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    8634:	b570      	push	{r4, r5, r6, lr}
    8636:	4604      	mov	r4, r0
    8638:	460d      	mov	r5, r1
    863a:	4616      	mov	r6, r2
	struct udp_pcb *ipcb;

	if (pcb->local_port == 0) {
    863c:	8a43      	ldrh	r3, [r0, #18]
    863e:	b19b      	cbz	r3, 8668 <udp_connect+0x34>
		if (err != ERR_OK) {
			return err;
		}
	}

	ip_addr_set(&pcb->remote_ip, ipaddr);
    8640:	b1d5      	cbz	r5, 8678 <udp_connect+0x44>
    8642:	682b      	ldr	r3, [r5, #0]
    8644:	6063      	str	r3, [r4, #4]
	pcb->remote_port = port;
    8646:	82a6      	strh	r6, [r4, #20]
	pcb->flags |= UDP_FLAGS_CONNECTED;
    8648:	7c23      	ldrb	r3, [r4, #16]
    864a:	f043 0304 	orr.w	r3, r3, #4
    864e:	7423      	strb	r3, [r4, #16]
	             ip4_addr3_16(&pcb->local_ip),
	             ip4_addr4_16(&pcb->local_ip),
	             pcb->local_port));

	/* Insert UDP PCB into the list of active UDP PCBs. */
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    8650:	4b0e      	ldr	r3, [pc, #56]	; (868c <udp_connect+0x58>)
    8652:	681a      	ldr	r2, [r3, #0]
    8654:	b192      	cbz	r2, 867c <udp_connect+0x48>
		if (pcb == ipcb) {
    8656:	4294      	cmp	r4, r2
    8658:	d016      	beq.n	8688 <udp_connect+0x54>
    865a:	4613      	mov	r3, r2
	for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    865c:	68db      	ldr	r3, [r3, #12]
    865e:	b16b      	cbz	r3, 867c <udp_connect+0x48>
		if (pcb == ipcb) {
    8660:	429c      	cmp	r4, r3
    8662:	d1fb      	bne.n	865c <udp_connect+0x28>
			/* already on the list, just return */
			return ERR_OK;
    8664:	2300      	movs	r3, #0
    8666:	e00d      	b.n	8684 <udp_connect+0x50>
		err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    8668:	2200      	movs	r2, #0
    866a:	4601      	mov	r1, r0
    866c:	4b08      	ldr	r3, [pc, #32]	; (8690 <udp_connect+0x5c>)
    866e:	4798      	blx	r3
		if (err != ERR_OK) {
    8670:	4603      	mov	r3, r0
    8672:	2800      	cmp	r0, #0
    8674:	d0e4      	beq.n	8640 <udp_connect+0xc>
    8676:	e005      	b.n	8684 <udp_connect+0x50>
	ip_addr_set(&pcb->remote_ip, ipaddr);
    8678:	2300      	movs	r3, #0
    867a:	e7e3      	b.n	8644 <udp_connect+0x10>
		}
	}
	/* PCB not yet on the list, add PCB now */
	pcb->next = udp_pcbs;
    867c:	60e2      	str	r2, [r4, #12]
	udp_pcbs  = pcb;
    867e:	4b03      	ldr	r3, [pc, #12]	; (868c <udp_connect+0x58>)
    8680:	601c      	str	r4, [r3, #0]
	return ERR_OK;
    8682:	2300      	movs	r3, #0
}
    8684:	4618      	mov	r0, r3
    8686:	bd70      	pop	{r4, r5, r6, pc}
			return ERR_OK;
    8688:	2300      	movs	r3, #0
    868a:	e7fb      	b.n	8684 <udp_connect+0x50>
    868c:	200092fc 	.word	0x200092fc
    8690:	00008415 	.word	0x00008415

00008694 <udp_recv>:
 * @param recv_arg additional argument to pass to the callback function
 */
void udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
	/* remember recv() callback and user data */
	pcb->recv     = recv;
    8694:	6181      	str	r1, [r0, #24]
	pcb->recv_arg = recv_arg;
    8696:	61c2      	str	r2, [r0, #28]
    8698:	4770      	bx	lr
	...

0000869c <udp_remove>:
 * UDP PCB's and the data structure is freed from memory.
 *
 * @see udp_new()
 */
void udp_remove(struct udp_pcb *pcb)
{
    869c:	b508      	push	{r3, lr}
    869e:	4601      	mov	r1, r0
	struct udp_pcb *pcb2;

	snmp_delete_udpidx_tree(pcb);
	/* pcb to be removed is first in list? */
	if (udp_pcbs == pcb) {
    86a0:	4b0b      	ldr	r3, [pc, #44]	; (86d0 <udp_remove+0x34>)
    86a2:	681a      	ldr	r2, [r3, #0]
    86a4:	4282      	cmp	r2, r0
    86a6:	d001      	beq.n	86ac <udp_remove+0x10>
		/* make list start at 2nd pcb */
		udp_pcbs = udp_pcbs->next;
		/* pcb not 1st in list */
	} else {
		for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    86a8:	b942      	cbnz	r2, 86bc <udp_remove+0x20>
    86aa:	e002      	b.n	86b2 <udp_remove+0x16>
		udp_pcbs = udp_pcbs->next;
    86ac:	68d2      	ldr	r2, [r2, #12]
    86ae:	4b08      	ldr	r3, [pc, #32]	; (86d0 <udp_remove+0x34>)
    86b0:	601a      	str	r2, [r3, #0]
				/* remove pcb from list */
				pcb2->next = pcb->next;
			}
		}
	}
	memp_free(MEMP_UDP_PCB, pcb);
    86b2:	2001      	movs	r0, #1
    86b4:	4b07      	ldr	r3, [pc, #28]	; (86d4 <udp_remove+0x38>)
    86b6:	4798      	blx	r3
    86b8:	bd08      	pop	{r3, pc}
{
    86ba:	461a      	mov	r2, r3
			if (pcb2->next != NULL && pcb2->next == pcb) {
    86bc:	68d3      	ldr	r3, [r2, #12]
    86be:	2b00      	cmp	r3, #0
    86c0:	d0f7      	beq.n	86b2 <udp_remove+0x16>
    86c2:	4299      	cmp	r1, r3
    86c4:	d1f9      	bne.n	86ba <udp_remove+0x1e>
				pcb2->next = pcb->next;
    86c6:	68cb      	ldr	r3, [r1, #12]
    86c8:	60d3      	str	r3, [r2, #12]
		for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    86ca:	2b00      	cmp	r3, #0
    86cc:	d1f5      	bne.n	86ba <udp_remove+0x1e>
    86ce:	e7f0      	b.n	86b2 <udp_remove+0x16>
    86d0:	200092fc 	.word	0x200092fc
    86d4:	00005201 	.word	0x00005201

000086d8 <udp_new>:
 * could not be allocated.
 *
 * @see udp_remove()
 */
struct udp_pcb *udp_new(void)
{
    86d8:	b510      	push	{r4, lr}
	struct udp_pcb *pcb;
	pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
    86da:	2001      	movs	r0, #1
    86dc:	4b05      	ldr	r3, [pc, #20]	; (86f4 <udp_new+0x1c>)
    86de:	4798      	blx	r3
	/* could allocate UDP PCB? */
	if (pcb != NULL) {
    86e0:	4604      	mov	r4, r0
    86e2:	b128      	cbz	r0, 86f0 <udp_new+0x18>
		/* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
		 * which means checksum is generated over the whole datagram per default
		 * (recommended as default by RFC 3828). */
		/* initialize PCB to all zeroes */
		memset(pcb, 0, sizeof(struct udp_pcb));
    86e4:	2220      	movs	r2, #32
    86e6:	2100      	movs	r1, #0
    86e8:	4b03      	ldr	r3, [pc, #12]	; (86f8 <udp_new+0x20>)
    86ea:	4798      	blx	r3
		pcb->ttl = UDP_TTL;
    86ec:	23ff      	movs	r3, #255	; 0xff
    86ee:	72a3      	strb	r3, [r4, #10]
	}
	return pcb;
}
    86f0:	4620      	mov	r0, r4
    86f2:	bd10      	pop	{r4, pc}
    86f4:	000051b9 	.word	0x000051b9
    86f8:	00009805 	.word	0x00009805

000086fc <etharp_free_entry>:

#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void etharp_free_entry(int i)
{
    86fc:	b510      	push	{r4, lr}
    86fe:	4604      	mov	r4, r0
	/* remove from SNMP ARP index tree */
	snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
	/* and empty packet queue */
	if (arp_table[i].q != NULL) {
    8700:	eb00 0280 	add.w	r2, r0, r0, lsl #2
    8704:	4b0c      	ldr	r3, [pc, #48]	; (8738 <etharp_free_entry+0x3c>)
    8706:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
    870a:	b138      	cbz	r0, 871c <etharp_free_entry+0x20>
		/* remove all queued packets */
		LWIP_DEBUGF(
		    ETHARP_DEBUG,
		    ("etharp_free_entry: freeing entry %" U16_F ", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
		free_etharp_q(arp_table[i].q);
    870c:	4b0b      	ldr	r3, [pc, #44]	; (873c <etharp_free_entry+0x40>)
    870e:	4798      	blx	r3
		arp_table[i].q = NULL;
    8710:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    8714:	009b      	lsls	r3, r3, #2
    8716:	2100      	movs	r1, #0
    8718:	4a07      	ldr	r2, [pc, #28]	; (8738 <etharp_free_entry+0x3c>)
    871a:	50d1      	str	r1, [r2, r3]
	}
	/* recycle entry for re-use */
	arp_table[i].state = ETHARP_STATE_EMPTY;
    871c:	4906      	ldr	r1, [pc, #24]	; (8738 <etharp_free_entry+0x3c>)
    871e:	00a0      	lsls	r0, r4, #2
    8720:	1902      	adds	r2, r0, r4
    8722:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    8726:	2300      	movs	r3, #0
    8728:	7493      	strb	r3, [r2, #18]
#ifdef LWIP_DEBUG
	/* for debugging, clean out the complete entry */
	arp_table[i].ctime = 0;
    872a:	74d3      	strb	r3, [r2, #19]
	arp_table[i].netif = NULL;
    872c:	6093      	str	r3, [r2, #8]
	ip_addr_set_zero(&arp_table[i].ipaddr);
    872e:	6053      	str	r3, [r2, #4]
	arp_table[i].ethaddr = ethzero;
    8730:	4614      	mov	r4, r2
    8732:	60e3      	str	r3, [r4, #12]
    8734:	8223      	strh	r3, [r4, #16]
    8736:	bd10      	pop	{r4, pc}
    8738:	20007fd8 	.word	0x20007fd8
    873c:	000054c9 	.word	0x000054c9

00008740 <etharp_find_entry>:
 *
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
    8740:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8744:	b083      	sub	sp, #12
    8746:	4a3c      	ldr	r2, [pc, #240]	; (8838 <etharp_find_entry+0xf8>)
    8748:	2300      	movs	r3, #0
	s8_t empty = ARP_TABLE_SIZE;
	u8_t i = 0, age_pending = 0, age_stable = 0;
	/* oldest entry with packets on queue */
	s8_t old_queue = ARP_TABLE_SIZE;
	/* its age */
	u8_t age_queue = 0;
    874a:	4699      	mov	r9, r3
	s8_t old_queue = ARP_TABLE_SIZE;
    874c:	f04f 0e0a 	mov.w	lr, #10
	u8_t i = 0, age_pending = 0, age_stable = 0;
    8750:	469c      	mov	ip, r3
	s8_t empty = ARP_TABLE_SIZE;
    8752:	4675      	mov	r5, lr
	s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
    8754:	46f0      	mov	r8, lr
    8756:	46f2      	mov	sl, lr
    8758:	9301      	str	r3, [sp, #4]
    875a:	e005      	b.n	8768 <etharp_find_entry+0x28>
	 */

	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
		u8_t state = arp_table[i].state;
		/* no empty entry found yet and now we do find one? */
		if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    875c:	b957      	cbnz	r7, 8774 <etharp_find_entry+0x34>
			LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %" U16_F "\n", (u16_t)i));
			/* remember first empty entry */
			empty = i;
    875e:	b25d      	sxtb	r5, r3
    8760:	3301      	adds	r3, #1
    8762:	3214      	adds	r2, #20
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    8764:	2b0a      	cmp	r3, #10
    8766:	d029      	beq.n	87bc <etharp_find_entry+0x7c>
    8768:	4614      	mov	r4, r2
		u8_t state = arp_table[i].state;
    876a:	7c97      	ldrb	r7, [r2, #18]
		if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    876c:	2d0a      	cmp	r5, #10
    876e:	d0f5      	beq.n	875c <etharp_find_entry+0x1c>
		} else if (state != ETHARP_STATE_EMPTY) {
    8770:	2f00      	cmp	r7, #0
    8772:	d0f5      	beq.n	8760 <etharp_find_entry+0x20>
			LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
			            state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
			/* if given, does IP address match IP address in ARP entry? */
			if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
    8774:	b120      	cbz	r0, 8780 <etharp_find_entry+0x40>
    8776:	6806      	ldr	r6, [r0, #0]
    8778:	46b3      	mov	fp, r6
    877a:	6866      	ldr	r6, [r4, #4]
    877c:	45b3      	cmp	fp, r6
    877e:	d00a      	beq.n	8796 <etharp_find_entry+0x56>
				            ("etharp_find_entry: found matching entry %" U16_F "\n", (u16_t)i));
				/* found exact IP address match, simply bail out */
				return i;
			}
			/* pending entry? */
			if (state == ETHARP_STATE_PENDING) {
    8780:	2f01      	cmp	r7, #1
    8782:	d00a      	beq.n	879a <etharp_find_entry+0x5a>
						old_pending = i;
						age_pending = arp_table[i].ctime;
					}
				}
				/* stable entry? */
			} else if (state >= ETHARP_STATE_STABLE) {
    8784:	2f01      	cmp	r7, #1
    8786:	d9eb      	bls.n	8760 <etharp_find_entry+0x20>
				/* don't record old_stable for static entries since they never expire */
				if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
				{
					/* remember entry with oldest stable entry in oldest, its age in maxtime */
					if (arp_table[i].ctime >= age_stable) {
    8788:	7ce4      	ldrb	r4, [r4, #19]
    878a:	4564      	cmp	r4, ip
						old_stable = i;
    878c:	bf24      	itt	cs
    878e:	fa4f f883 	sxtbcs.w	r8, r3
						age_stable = arp_table[i].ctime;
    8792:	46a4      	movcs	ip, r4
    8794:	e7e4      	b.n	8760 <etharp_find_entry+0x20>
				return i;
    8796:	b258      	sxtb	r0, r3
    8798:	e029      	b.n	87ee <etharp_find_entry+0xae>
				if (arp_table[i].q != NULL) {
    879a:	6827      	ldr	r7, [r4, #0]
    879c:	b137      	cbz	r7, 87ac <etharp_find_entry+0x6c>
					if (arp_table[i].ctime >= age_queue) {
    879e:	7ce4      	ldrb	r4, [r4, #19]
    87a0:	454c      	cmp	r4, r9
    87a2:	d3dd      	bcc.n	8760 <etharp_find_entry+0x20>
						old_queue = i;
    87a4:	fa4f fe83 	sxtb.w	lr, r3
						age_queue = arp_table[i].ctime;
    87a8:	46a1      	mov	r9, r4
    87aa:	e7d9      	b.n	8760 <etharp_find_entry+0x20>
					if (arp_table[i].ctime >= age_pending) {
    87ac:	7ce4      	ldrb	r4, [r4, #19]
    87ae:	9e01      	ldr	r6, [sp, #4]
    87b0:	42b4      	cmp	r4, r6
    87b2:	d3d5      	bcc.n	8760 <etharp_find_entry+0x20>
						old_pending = i;
    87b4:	fa4f fa83 	sxtb.w	sl, r3
						age_pending = arp_table[i].ctime;
    87b8:	9401      	str	r4, [sp, #4]
    87ba:	e7d1      	b.n	8760 <etharp_find_entry+0x20>
		}
	}
	/* { we have no match } => try to create a new entry */

	/* don't create new entry, only search? */
	if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
    87bc:	f011 0f02 	tst.w	r1, #2
    87c0:	d130      	bne.n	8824 <etharp_find_entry+0xe4>
    87c2:	4604      	mov	r4, r0
    87c4:	2d0a      	cmp	r5, #10
    87c6:	d015      	beq.n	87f4 <etharp_find_entry+0xb4>
	 *
	 * { ETHARP_FLAG_TRY_HARD is set at this point }
	 */

	/* 1) empty entry available? */
	if (empty < ARP_TABLE_SIZE) {
    87c8:	2d09      	cmp	r5, #9
    87ca:	dc16      	bgt.n	87fa <etharp_find_entry+0xba>
		i = empty;
    87cc:	b2ed      	uxtb	r5, r5

	LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
	LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY", arp_table[i].state == ETHARP_STATE_EMPTY);

	/* IP address given? */
	if (ipaddr != NULL) {
    87ce:	b134      	cbz	r4, 87de <etharp_find_entry+0x9e>
		/* set IP address */
		ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
    87d0:	6821      	ldr	r1, [r4, #0]
    87d2:	eb05 0385 	add.w	r3, r5, r5, lsl #2
    87d6:	4a18      	ldr	r2, [pc, #96]	; (8838 <etharp_find_entry+0xf8>)
    87d8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    87dc:	6059      	str	r1, [r3, #4]
	}
	arp_table[i].ctime = 0;
    87de:	eb05 0285 	add.w	r2, r5, r5, lsl #2
    87e2:	4b15      	ldr	r3, [pc, #84]	; (8838 <etharp_find_entry+0xf8>)
    87e4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    87e8:	2200      	movs	r2, #0
    87ea:	74da      	strb	r2, [r3, #19]
	return (err_t)i;
    87ec:	b268      	sxtb	r0, r5
}
    87ee:	b003      	add	sp, #12
    87f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
    87f4:	f011 0f01 	tst.w	r1, #1
    87f8:	d017      	beq.n	882a <etharp_find_entry+0xea>
		if (old_stable < ARP_TABLE_SIZE) {
    87fa:	f1b8 0f09 	cmp.w	r8, #9
    87fe:	dc05      	bgt.n	880c <etharp_find_entry+0xcc>
			i = old_stable;
    8800:	fa5f f588 	uxtb.w	r5, r8
		etharp_free_entry(i);
    8804:	4628      	mov	r0, r5
    8806:	4b0d      	ldr	r3, [pc, #52]	; (883c <etharp_find_entry+0xfc>)
    8808:	4798      	blx	r3
    880a:	e7e0      	b.n	87ce <etharp_find_entry+0x8e>
		} else if (old_pending < ARP_TABLE_SIZE) {
    880c:	f1ba 0f09 	cmp.w	sl, #9
    8810:	dc02      	bgt.n	8818 <etharp_find_entry+0xd8>
			i = old_pending;
    8812:	fa5f f58a 	uxtb.w	r5, sl
    8816:	e7f5      	b.n	8804 <etharp_find_entry+0xc4>
		} else if (old_queue < ARP_TABLE_SIZE) {
    8818:	f1be 0f09 	cmp.w	lr, #9
    881c:	dc08      	bgt.n	8830 <etharp_find_entry+0xf0>
			i = old_queue;
    881e:	fa5f f58e 	uxtb.w	r5, lr
    8822:	e7ef      	b.n	8804 <etharp_find_entry+0xc4>
		return (s8_t)ERR_MEM;
    8824:	f04f 30ff 	mov.w	r0, #4294967295
    8828:	e7e1      	b.n	87ee <etharp_find_entry+0xae>
    882a:	f04f 30ff 	mov.w	r0, #4294967295
    882e:	e7de      	b.n	87ee <etharp_find_entry+0xae>
			return (s8_t)ERR_MEM;
    8830:	f04f 30ff 	mov.w	r0, #4294967295
    8834:	e7db      	b.n	87ee <etharp_find_entry+0xae>
    8836:	bf00      	nop
    8838:	20007fd8 	.word	0x20007fd8
    883c:	000086fd 	.word	0x000086fd

00008840 <etharp_send_ip>:
 * @params src the source MAC address to be copied into the ethernet header
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
    8840:	b538      	push	{r3, r4, r5, lr}
	struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    8842:	684c      	ldr	r4, [r1, #4]

	LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
	            (netif->hwaddr_len == ETHARP_HWADDR_LEN));
	ETHADDR32_COPY(&ethhdr->dest, dst);
    8844:	681d      	ldr	r5, [r3, #0]
    8846:	6025      	str	r5, [r4, #0]
    8848:	889b      	ldrh	r3, [r3, #4]
    884a:	80a3      	strh	r3, [r4, #4]
	ETHADDR16_COPY(&ethhdr->src, src);
    884c:	6813      	ldr	r3, [r2, #0]
    884e:	f8c4 3006 	str.w	r3, [r4, #6]
    8852:	8893      	ldrh	r3, [r2, #4]
    8854:	8163      	strh	r3, [r4, #10]
	ethhdr->type = PP_HTONS(ETHTYPE_IP);
    8856:	2308      	movs	r3, #8
    8858:	7323      	strb	r3, [r4, #12]
    885a:	2300      	movs	r3, #0
    885c:	7363      	strb	r3, [r4, #13]
	LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
	/* send the packet */
	return netif->linkoutput(netif, p);
    885e:	6983      	ldr	r3, [r0, #24]
    8860:	4798      	blx	r3
}
    8862:	bd38      	pop	{r3, r4, r5, pc}

00008864 <etharp_tmr>:
{
    8864:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8866:	4c0e      	ldr	r4, [pc, #56]	; (88a0 <etharp_tmr+0x3c>)
    8868:	2500      	movs	r5, #0
				etharp_free_entry(i);
    886a:	4e0e      	ldr	r6, [pc, #56]	; (88a4 <etharp_tmr+0x40>)
				arp_table[i].state = ETHARP_STATE_STABLE;
    886c:	2702      	movs	r7, #2
    886e:	e006      	b.n	887e <etharp_tmr+0x1a>
			} else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
    8870:	2a03      	cmp	r2, #3
				arp_table[i].state = ETHARP_STATE_STABLE;
    8872:	bf08      	it	eq
    8874:	74a7      	strbeq	r7, [r4, #18]
    8876:	3501      	adds	r5, #1
    8878:	3414      	adds	r4, #20
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    887a:	2d0a      	cmp	r5, #10
    887c:	d00f      	beq.n	889e <etharp_tmr+0x3a>
		u8_t state = arp_table[i].state;
    887e:	4628      	mov	r0, r5
    8880:	7ca2      	ldrb	r2, [r4, #18]
		if (state != ETHARP_STATE_EMPTY
    8882:	2a00      	cmp	r2, #0
    8884:	d0f7      	beq.n	8876 <etharp_tmr+0x12>
			arp_table[i].ctime++;
    8886:	7ce3      	ldrb	r3, [r4, #19]
    8888:	3301      	adds	r3, #1
    888a:	b2db      	uxtb	r3, r3
    888c:	74e3      	strb	r3, [r4, #19]
			if ((arp_table[i].ctime >= ARP_MAXAGE)
    888e:	2bef      	cmp	r3, #239	; 0xef
    8890:	d803      	bhi.n	889a <etharp_tmr+0x36>
			    || ((arp_table[i].state == ETHARP_STATE_PENDING) && (arp_table[i].ctime >= ARP_MAXPENDING))) {
    8892:	2a01      	cmp	r2, #1
    8894:	d1ec      	bne.n	8870 <etharp_tmr+0xc>
    8896:	2b01      	cmp	r3, #1
    8898:	d9ed      	bls.n	8876 <etharp_tmr+0x12>
				etharp_free_entry(i);
    889a:	47b0      	blx	r6
    889c:	e7eb      	b.n	8876 <etharp_tmr+0x12>
}
    889e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    88a0:	20007fd8 	.word	0x20007fd8
    88a4:	000086fd 	.word	0x000086fd

000088a8 <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
    88a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    88aa:	4606      	mov	r6, r0
    88ac:	4d08      	ldr	r5, [pc, #32]	; (88d0 <etharp_cleanup_netif+0x28>)
    88ae:	2400      	movs	r4, #0
	u8_t i;

	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
		u8_t state = arp_table[i].state;
		if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
			etharp_free_entry(i);
    88b0:	4f08      	ldr	r7, [pc, #32]	; (88d4 <etharp_cleanup_netif+0x2c>)
    88b2:	e003      	b.n	88bc <etharp_cleanup_netif+0x14>
    88b4:	3401      	adds	r4, #1
    88b6:	3514      	adds	r5, #20
	for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    88b8:	2c0a      	cmp	r4, #10
    88ba:	d008      	beq.n	88ce <etharp_cleanup_netif+0x26>
		u8_t state = arp_table[i].state;
    88bc:	4620      	mov	r0, r4
		if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
    88be:	7cab      	ldrb	r3, [r5, #18]
    88c0:	2b00      	cmp	r3, #0
    88c2:	d0f7      	beq.n	88b4 <etharp_cleanup_netif+0xc>
    88c4:	68ab      	ldr	r3, [r5, #8]
    88c6:	42b3      	cmp	r3, r6
    88c8:	d1f4      	bne.n	88b4 <etharp_cleanup_netif+0xc>
			etharp_free_entry(i);
    88ca:	47b8      	blx	r7
    88cc:	e7f2      	b.n	88b4 <etharp_cleanup_netif+0xc>
		}
	}
}
    88ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    88d0:	20007fd8 	.word	0x20007fd8
    88d4:	000086fd 	.word	0x000086fd

000088d8 <etharp_request>:
 * @return ERR_OK if the request has been sent
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
    88d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    88dc:	4605      	mov	r5, r0
    88de:	4688      	mov	r8, r1
	p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
    88e0:	2200      	movs	r2, #0
    88e2:	212a      	movs	r1, #42	; 0x2a
    88e4:	2003      	movs	r0, #3
    88e6:	4b21      	ldr	r3, [pc, #132]	; (896c <etharp_request+0x94>)
    88e8:	4798      	blx	r3
	if (p == NULL) {
    88ea:	2800      	cmp	r0, #0
    88ec:	d03b      	beq.n	8966 <etharp_request+0x8e>
    88ee:	4607      	mov	r7, r0
	ethhdr = (struct eth_hdr *)p->payload;
    88f0:	6844      	ldr	r4, [r0, #4]
	hdr->opcode = htons(opcode);
    88f2:	2001      	movs	r0, #1
    88f4:	4b1e      	ldr	r3, [pc, #120]	; (8970 <etharp_request+0x98>)
    88f6:	4798      	blx	r3
    88f8:	82a0      	strh	r0, [r4, #20]
	ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    88fa:	f8d5 302f 	ldr.w	r3, [r5, #47]	; 0x2f
    88fe:	f8c4 3016 	str.w	r3, [r4, #22]
    8902:	f8b5 3033 	ldrh.w	r3, [r5, #51]	; 0x33
    8906:	8363      	strh	r3, [r4, #26]
	ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    8908:	4b1a      	ldr	r3, [pc, #104]	; (8974 <etharp_request+0x9c>)
    890a:	6818      	ldr	r0, [r3, #0]
    890c:	6220      	str	r0, [r4, #32]
    890e:	889a      	ldrh	r2, [r3, #4]
    8910:	84a2      	strh	r2, [r4, #36]	; 0x24
	ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    8912:	6898      	ldr	r0, [r3, #8]
    8914:	6020      	str	r0, [r4, #0]
    8916:	899b      	ldrh	r3, [r3, #12]
    8918:	80a3      	strh	r3, [r4, #4]
	ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    891a:	f8d5 302f 	ldr.w	r3, [r5, #47]	; 0x2f
    891e:	f8c4 3006 	str.w	r3, [r4, #6]
    8922:	f8b5 3033 	ldrh.w	r3, [r5, #51]	; 0x33
    8926:	8163      	strh	r3, [r4, #10]
	IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
    8928:	686b      	ldr	r3, [r5, #4]
    892a:	61e3      	str	r3, [r4, #28]
	IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
    892c:	f8d8 3000 	ldr.w	r3, [r8]
    8930:	f8c4 3026 	str.w	r3, [r4, #38]	; 0x26
	hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    8934:	2200      	movs	r2, #0
    8936:	73a2      	strb	r2, [r4, #14]
    8938:	2301      	movs	r3, #1
    893a:	73e3      	strb	r3, [r4, #15]
	hdr->proto  = PP_HTONS(ETHTYPE_IP);
    893c:	2308      	movs	r3, #8
    893e:	7423      	strb	r3, [r4, #16]
    8940:	7462      	strb	r2, [r4, #17]
	hdr->hwlen    = ETHARP_HWADDR_LEN;
    8942:	2206      	movs	r2, #6
    8944:	74a2      	strb	r2, [r4, #18]
	hdr->protolen = sizeof(ip_addr_t);
    8946:	2204      	movs	r2, #4
    8948:	74e2      	strb	r2, [r4, #19]
	ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    894a:	7323      	strb	r3, [r4, #12]
    894c:	2306      	movs	r3, #6
    894e:	7363      	strb	r3, [r4, #13]
	result = netif->linkoutput(netif, p);
    8950:	69ab      	ldr	r3, [r5, #24]
    8952:	4639      	mov	r1, r7
    8954:	4628      	mov	r0, r5
    8956:	4798      	blx	r3
    8958:	4604      	mov	r4, r0
	pbuf_free(p);
    895a:	4638      	mov	r0, r7
    895c:	4b06      	ldr	r3, [pc, #24]	; (8978 <etharp_request+0xa0>)
    895e:	4798      	blx	r3
	                  (struct eth_addr *)netif->hwaddr,
	                  &netif->ip_addr,
	                  &ethzero,
	                  ipaddr,
	                  ARP_REQUEST);
}
    8960:	4620      	mov	r0, r4
    8962:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return ERR_MEM;
    8966:	f04f 34ff 	mov.w	r4, #4294967295
    896a:	e7f9      	b.n	8960 <etharp_request+0x88>
    896c:	00005531 	.word	0x00005531
    8970:	000026e5 	.word	0x000026e5
    8974:	0000bdfc 	.word	0x0000bdfc
    8978:	000054c9 	.word	0x000054c9

0000897c <etharp_output_to_arp_index>:
{
    897c:	b570      	push	{r4, r5, r6, lr}
    897e:	4605      	mov	r5, r0
    8980:	460e      	mov	r6, r1
    8982:	4614      	mov	r4, r2
	if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    8984:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    8988:	4b15      	ldr	r3, [pc, #84]	; (89e0 <etharp_output_to_arp_index+0x64>)
    898a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    898e:	7c9b      	ldrb	r3, [r3, #18]
    8990:	2b02      	cmp	r3, #2
    8992:	d00c      	beq.n	89ae <etharp_output_to_arp_index+0x32>
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr);
    8994:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    8998:	4b11      	ldr	r3, [pc, #68]	; (89e0 <etharp_output_to_arp_index+0x64>)
    899a:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    899e:	330c      	adds	r3, #12
    89a0:	f105 022f 	add.w	r2, r5, #47	; 0x2f
    89a4:	4631      	mov	r1, r6
    89a6:	4628      	mov	r0, r5
    89a8:	4c0e      	ldr	r4, [pc, #56]	; (89e4 <etharp_output_to_arp_index+0x68>)
    89aa:	47a0      	blx	r4
}
    89ac:	bd70      	pop	{r4, r5, r6, pc}
	if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    89ae:	4613      	mov	r3, r2
    89b0:	4a0b      	ldr	r2, [pc, #44]	; (89e0 <etharp_output_to_arp_index+0x64>)
    89b2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    89b6:	7cdb      	ldrb	r3, [r3, #19]
    89b8:	2be3      	cmp	r3, #227	; 0xe3
    89ba:	d9eb      	bls.n	8994 <etharp_output_to_arp_index+0x18>
		if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
    89bc:	eb04 0184 	add.w	r1, r4, r4, lsl #2
    89c0:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    89c4:	3104      	adds	r1, #4
    89c6:	4b08      	ldr	r3, [pc, #32]	; (89e8 <etharp_output_to_arp_index+0x6c>)
    89c8:	4798      	blx	r3
    89ca:	2800      	cmp	r0, #0
    89cc:	d1e2      	bne.n	8994 <etharp_output_to_arp_index+0x18>
			arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    89ce:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    89d2:	4a03      	ldr	r2, [pc, #12]	; (89e0 <etharp_output_to_arp_index+0x64>)
    89d4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    89d8:	2203      	movs	r2, #3
    89da:	749a      	strb	r2, [r3, #18]
    89dc:	e7da      	b.n	8994 <etharp_output_to_arp_index+0x18>
    89de:	bf00      	nop
    89e0:	20007fd8 	.word	0x20007fd8
    89e4:	00008841 	.word	0x00008841
    89e8:	000088d9 	.word	0x000088d9

000089ec <etharp_query>:
{
    89ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    89f0:	4680      	mov	r8, r0
    89f2:	460d      	mov	r5, r1
    89f4:	4616      	mov	r6, r2
	if (ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr) || ip_addr_isany(ipaddr)) {
    89f6:	4601      	mov	r1, r0
    89f8:	6828      	ldr	r0, [r5, #0]
    89fa:	4b49      	ldr	r3, [pc, #292]	; (8b20 <etharp_query+0x134>)
    89fc:	4798      	blx	r3
    89fe:	2800      	cmp	r0, #0
    8a00:	d161      	bne.n	8ac6 <etharp_query+0xda>
    8a02:	682b      	ldr	r3, [r5, #0]
    8a04:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    8a08:	2ae0      	cmp	r2, #224	; 0xe0
    8a0a:	d05f      	beq.n	8acc <etharp_query+0xe0>
    8a0c:	2d00      	cmp	r5, #0
    8a0e:	d060      	beq.n	8ad2 <etharp_query+0xe6>
    8a10:	2b00      	cmp	r3, #0
    8a12:	d061      	beq.n	8ad8 <etharp_query+0xec>
	i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
    8a14:	2101      	movs	r1, #1
    8a16:	4628      	mov	r0, r5
    8a18:	4b42      	ldr	r3, [pc, #264]	; (8b24 <etharp_query+0x138>)
    8a1a:	4798      	blx	r3
	if (i < 0) {
    8a1c:	1e04      	subs	r4, r0, #0
    8a1e:	db49      	blt.n	8ab4 <etharp_query+0xc8>
	if (arp_table[i].state == ETHARP_STATE_EMPTY) {
    8a20:	4627      	mov	r7, r4
    8a22:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    8a26:	4a40      	ldr	r2, [pc, #256]	; (8b28 <etharp_query+0x13c>)
    8a28:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    8a2c:	7c9b      	ldrb	r3, [r3, #18]
    8a2e:	bb6b      	cbnz	r3, 8a8c <etharp_query+0xa0>
		arp_table[i].state = ETHARP_STATE_PENDING;
    8a30:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    8a34:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    8a38:	2201      	movs	r2, #1
    8a3a:	749a      	strb	r2, [r3, #18]
		result = etharp_request(netif, ipaddr);
    8a3c:	4629      	mov	r1, r5
    8a3e:	4640      	mov	r0, r8
    8a40:	4b3a      	ldr	r3, [pc, #232]	; (8b2c <etharp_query+0x140>)
    8a42:	4798      	blx	r3
		if (q == NULL) {
    8a44:	2e00      	cmp	r6, #0
    8a46:	d04a      	beq.n	8ade <etharp_query+0xf2>
	if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    8a48:	eb07 0387 	add.w	r3, r7, r7, lsl #2
    8a4c:	4a36      	ldr	r2, [pc, #216]	; (8b28 <etharp_query+0x13c>)
    8a4e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    8a52:	7c9b      	ldrb	r3, [r3, #18]
    8a54:	2b01      	cmp	r3, #1
    8a56:	d81e      	bhi.n	8a96 <etharp_query+0xaa>
	} else if (arp_table[i].state == ETHARP_STATE_PENDING) {
    8a58:	2b01      	cmp	r3, #1
    8a5a:	d142      	bne.n	8ae2 <etharp_query+0xf6>
			if (p->type != PBUF_ROM) {
    8a5c:	7b33      	ldrb	r3, [r6, #12]
    8a5e:	2b01      	cmp	r3, #1
    8a60:	d15c      	bne.n	8b1c <etharp_query+0x130>
    8a62:	4633      	mov	r3, r6
			p = p->next;
    8a64:	681b      	ldr	r3, [r3, #0]
		while (p) {
    8a66:	2b00      	cmp	r3, #0
    8a68:	d046      	beq.n	8af8 <etharp_query+0x10c>
			if (p->type != PBUF_ROM) {
    8a6a:	7b1a      	ldrb	r2, [r3, #12]
    8a6c:	2a01      	cmp	r2, #1
    8a6e:	d0f9      	beq.n	8a64 <etharp_query+0x78>
			p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    8a70:	2200      	movs	r2, #0
    8a72:	8919      	ldrh	r1, [r3, #8]
    8a74:	2003      	movs	r0, #3
    8a76:	4b2e      	ldr	r3, [pc, #184]	; (8b30 <etharp_query+0x144>)
    8a78:	4798      	blx	r3
			if (p != NULL) {
    8a7a:	4604      	mov	r4, r0
    8a7c:	b300      	cbz	r0, 8ac0 <etharp_query+0xd4>
				if (pbuf_copy(p, q) != ERR_OK) {
    8a7e:	4631      	mov	r1, r6
    8a80:	4620      	mov	r0, r4
    8a82:	4b2c      	ldr	r3, [pc, #176]	; (8b34 <etharp_query+0x148>)
    8a84:	4798      	blx	r3
    8a86:	b9c0      	cbnz	r0, 8aba <etharp_query+0xce>
			p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    8a88:	4626      	mov	r6, r4
    8a8a:	e038      	b.n	8afe <etharp_query+0x112>
	if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    8a8c:	2b01      	cmp	r3, #1
    8a8e:	d0d5      	beq.n	8a3c <etharp_query+0x50>
    8a90:	b34e      	cbz	r6, 8ae6 <etharp_query+0xfa>
	if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    8a92:	2b01      	cmp	r3, #1
    8a94:	d92d      	bls.n	8af2 <etharp_query+0x106>
		ETHARP_SET_HINT(netif, i);
    8a96:	4b24      	ldr	r3, [pc, #144]	; (8b28 <etharp_query+0x13c>)
    8a98:	f883 40c8 	strb.w	r4, [r3, #200]	; 0xc8
		result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    8a9c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    8aa0:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    8aa4:	330c      	adds	r3, #12
    8aa6:	f108 022f 	add.w	r2, r8, #47	; 0x2f
    8aaa:	4631      	mov	r1, r6
    8aac:	4640      	mov	r0, r8
    8aae:	4c22      	ldr	r4, [pc, #136]	; (8b38 <etharp_query+0x14c>)
    8ab0:	47a0      	blx	r4
    8ab2:	4604      	mov	r4, r0
}
    8ab4:	4620      	mov	r0, r4
    8ab6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					pbuf_free(p);
    8aba:	4620      	mov	r0, r4
    8abc:	4b1f      	ldr	r3, [pc, #124]	; (8b3c <etharp_query+0x150>)
    8abe:	4798      	blx	r3
			result = ERR_MEM;
    8ac0:	f04f 34ff 	mov.w	r4, #4294967295
    8ac4:	e7f6      	b.n	8ab4 <etharp_query+0xc8>
		return ERR_ARG;
    8ac6:	f06f 040d 	mvn.w	r4, #13
    8aca:	e7f3      	b.n	8ab4 <etharp_query+0xc8>
    8acc:	f06f 040d 	mvn.w	r4, #13
    8ad0:	e7f0      	b.n	8ab4 <etharp_query+0xc8>
    8ad2:	f06f 040d 	mvn.w	r4, #13
    8ad6:	e7ed      	b.n	8ab4 <etharp_query+0xc8>
    8ad8:	f06f 040d 	mvn.w	r4, #13
    8adc:	e7ea      	b.n	8ab4 <etharp_query+0xc8>
		result = etharp_request(netif, ipaddr);
    8ade:	4604      	mov	r4, r0
    8ae0:	e7e8      	b.n	8ab4 <etharp_query+0xc8>
    8ae2:	4604      	mov	r4, r0
    8ae4:	e7e6      	b.n	8ab4 <etharp_query+0xc8>
    8ae6:	4629      	mov	r1, r5
    8ae8:	4640      	mov	r0, r8
    8aea:	4b10      	ldr	r3, [pc, #64]	; (8b2c <etharp_query+0x140>)
    8aec:	4798      	blx	r3
    8aee:	4604      	mov	r4, r0
    8af0:	e7e0      	b.n	8ab4 <etharp_query+0xc8>
	err_t            result  = ERR_MEM;
    8af2:	f04f 34ff 	mov.w	r4, #4294967295
    8af6:	e7dd      	b.n	8ab4 <etharp_query+0xc8>
			pbuf_ref(p);
    8af8:	4630      	mov	r0, r6
    8afa:	4b11      	ldr	r3, [pc, #68]	; (8b40 <etharp_query+0x154>)
    8afc:	4798      	blx	r3
			if (arp_table[i].q != NULL) {
    8afe:	eb07 0387 	add.w	r3, r7, r7, lsl #2
    8b02:	4a09      	ldr	r2, [pc, #36]	; (8b28 <etharp_query+0x13c>)
    8b04:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    8b08:	b108      	cbz	r0, 8b0e <etharp_query+0x122>
				pbuf_free(arp_table[i].q);
    8b0a:	4b0c      	ldr	r3, [pc, #48]	; (8b3c <etharp_query+0x150>)
    8b0c:	4798      	blx	r3
			arp_table[i].q = p;
    8b0e:	eb07 0787 	add.w	r7, r7, r7, lsl #2
    8b12:	4b05      	ldr	r3, [pc, #20]	; (8b28 <etharp_query+0x13c>)
    8b14:	f843 6027 	str.w	r6, [r3, r7, lsl #2]
			result = ERR_OK;
    8b18:	2400      	movs	r4, #0
    8b1a:	e7cb      	b.n	8ab4 <etharp_query+0xc8>
			if (p->type != PBUF_ROM) {
    8b1c:	4633      	mov	r3, r6
    8b1e:	e7a7      	b.n	8a70 <etharp_query+0x84>
    8b20:	00004739 	.word	0x00004739
    8b24:	00008741 	.word	0x00008741
    8b28:	20007fd8 	.word	0x20007fd8
    8b2c:	000088d9 	.word	0x000088d9
    8b30:	00005531 	.word	0x00005531
    8b34:	00005755 	.word	0x00005755
    8b38:	00008841 	.word	0x00008841
    8b3c:	000054c9 	.word	0x000054c9
    8b40:	000056e3 	.word	0x000056e3

00008b44 <etharp_output>:
{
    8b44:	b570      	push	{r4, r5, r6, lr}
    8b46:	b082      	sub	sp, #8
    8b48:	4605      	mov	r5, r0
    8b4a:	460e      	mov	r6, r1
    8b4c:	4614      	mov	r4, r2
	if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    8b4e:	210e      	movs	r1, #14
    8b50:	4630      	mov	r0, r6
    8b52:	4b3d      	ldr	r3, [pc, #244]	; (8c48 <etharp_output+0x104>)
    8b54:	4798      	blx	r3
    8b56:	2800      	cmp	r0, #0
    8b58:	d16d      	bne.n	8c36 <etharp_output+0xf2>
	if (ip_addr_isbroadcast(ipaddr, netif)) {
    8b5a:	4629      	mov	r1, r5
    8b5c:	6820      	ldr	r0, [r4, #0]
    8b5e:	4b3b      	ldr	r3, [pc, #236]	; (8c4c <etharp_output+0x108>)
    8b60:	4798      	blx	r3
    8b62:	2800      	cmp	r0, #0
    8b64:	d15e      	bne.n	8c24 <etharp_output+0xe0>
	} else if (ip_addr_ismulticast(ipaddr)) {
    8b66:	6823      	ldr	r3, [r4, #0]
    8b68:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
    8b6c:	2ae0      	cmp	r2, #224	; 0xe0
    8b6e:	d024      	beq.n	8bba <etharp_output+0x76>
		if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) && !ip_addr_islinklocal(ipaddr)) {
    8b70:	686a      	ldr	r2, [r5, #4]
    8b72:	405a      	eors	r2, r3
    8b74:	68a9      	ldr	r1, [r5, #8]
    8b76:	420a      	tst	r2, r1
    8b78:	d00a      	beq.n	8b90 <etharp_output+0x4c>
    8b7a:	b29b      	uxth	r3, r3
    8b7c:	f64f 62a9 	movw	r2, #65193	; 0xfea9
    8b80:	4293      	cmp	r3, r2
    8b82:	d005      	beq.n	8b90 <etharp_output+0x4c>
				if (!ip_addr_isany(&netif->gw)) {
    8b84:	f115 040c 	adds.w	r4, r5, #12
    8b88:	d058      	beq.n	8c3c <etharp_output+0xf8>
    8b8a:	68eb      	ldr	r3, [r5, #12]
    8b8c:	2b00      	cmp	r3, #0
    8b8e:	d058      	beq.n	8c42 <etharp_output+0xfe>
				if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE)
    8b90:	4b2f      	ldr	r3, [pc, #188]	; (8c50 <etharp_output+0x10c>)
    8b92:	f893 20c8 	ldrb.w	r2, [r3, #200]	; 0xc8
    8b96:	eb02 0182 	add.w	r1, r2, r2, lsl #2
    8b9a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    8b9e:	7c9b      	ldrb	r3, [r3, #18]
    8ba0:	2b01      	cmp	r3, #1
    8ba2:	d907      	bls.n	8bb4 <etharp_output+0x70>
				    && (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
    8ba4:	460b      	mov	r3, r1
    8ba6:	492a      	ldr	r1, [pc, #168]	; (8c50 <etharp_output+0x10c>)
    8ba8:	eb01 0383 	add.w	r3, r1, r3, lsl #2
    8bac:	6821      	ldr	r1, [r4, #0]
    8bae:	685b      	ldr	r3, [r3, #4]
    8bb0:	4299      	cmp	r1, r3
    8bb2:	d018      	beq.n	8be6 <etharp_output+0xa2>
    8bb4:	4b26      	ldr	r3, [pc, #152]	; (8c50 <etharp_output+0x10c>)
{
    8bb6:	2200      	movs	r2, #0
    8bb8:	e01e      	b.n	8bf8 <etharp_output+0xb4>
		mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    8bba:	2301      	movs	r3, #1
    8bbc:	f88d 3000 	strb.w	r3, [sp]
		mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    8bc0:	2300      	movs	r3, #0
    8bc2:	f88d 3001 	strb.w	r3, [sp, #1]
		mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    8bc6:	235e      	movs	r3, #94	; 0x5e
    8bc8:	f88d 3002 	strb.w	r3, [sp, #2]
		mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    8bcc:	7863      	ldrb	r3, [r4, #1]
    8bce:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    8bd2:	f88d 3003 	strb.w	r3, [sp, #3]
		mcastaddr.addr[4] = ip4_addr3(ipaddr);
    8bd6:	78a3      	ldrb	r3, [r4, #2]
    8bd8:	f88d 3004 	strb.w	r3, [sp, #4]
		mcastaddr.addr[5] = ip4_addr4(ipaddr);
    8bdc:	78e3      	ldrb	r3, [r4, #3]
    8bde:	f88d 3005 	strb.w	r3, [sp, #5]
		dest = &mcastaddr;
    8be2:	466b      	mov	r3, sp
    8be4:	e01f      	b.n	8c26 <etharp_output+0xe2>
					return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
    8be6:	4631      	mov	r1, r6
    8be8:	4628      	mov	r0, r5
    8bea:	4b1a      	ldr	r3, [pc, #104]	; (8c54 <etharp_output+0x110>)
    8bec:	4798      	blx	r3
    8bee:	e020      	b.n	8c32 <etharp_output+0xee>
    8bf0:	3201      	adds	r2, #1
    8bf2:	3314      	adds	r3, #20
		for (i = 0; i < ARP_TABLE_SIZE; i++) {
    8bf4:	2a0a      	cmp	r2, #10
    8bf6:	d00f      	beq.n	8c18 <etharp_output+0xd4>
			if ((arp_table[i].state >= ETHARP_STATE_STABLE) && (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
    8bf8:	7c99      	ldrb	r1, [r3, #18]
    8bfa:	2901      	cmp	r1, #1
    8bfc:	d9f8      	bls.n	8bf0 <etharp_output+0xac>
    8bfe:	6820      	ldr	r0, [r4, #0]
    8c00:	6859      	ldr	r1, [r3, #4]
    8c02:	4288      	cmp	r0, r1
    8c04:	d1f4      	bne.n	8bf0 <etharp_output+0xac>
				ETHARP_SET_HINT(netif, i);
    8c06:	b2d2      	uxtb	r2, r2
    8c08:	4b11      	ldr	r3, [pc, #68]	; (8c50 <etharp_output+0x10c>)
    8c0a:	f883 20c8 	strb.w	r2, [r3, #200]	; 0xc8
				return etharp_output_to_arp_index(netif, q, i);
    8c0e:	4631      	mov	r1, r6
    8c10:	4628      	mov	r0, r5
    8c12:	4b10      	ldr	r3, [pc, #64]	; (8c54 <etharp_output+0x110>)
    8c14:	4798      	blx	r3
    8c16:	e00c      	b.n	8c32 <etharp_output+0xee>
		return etharp_query(netif, dst_addr, q);
    8c18:	4632      	mov	r2, r6
    8c1a:	4621      	mov	r1, r4
    8c1c:	4628      	mov	r0, r5
    8c1e:	4b0e      	ldr	r3, [pc, #56]	; (8c58 <etharp_output+0x114>)
    8c20:	4798      	blx	r3
    8c22:	e006      	b.n	8c32 <etharp_output+0xee>
		dest = (struct eth_addr *)&ethbroadcast;
    8c24:	4b0d      	ldr	r3, [pc, #52]	; (8c5c <etharp_output+0x118>)
	return etharp_send_ip(netif, q, (struct eth_addr *)(netif->hwaddr), dest);
    8c26:	f105 022f 	add.w	r2, r5, #47	; 0x2f
    8c2a:	4631      	mov	r1, r6
    8c2c:	4628      	mov	r0, r5
    8c2e:	4c0c      	ldr	r4, [pc, #48]	; (8c60 <etharp_output+0x11c>)
    8c30:	47a0      	blx	r4
}
    8c32:	b002      	add	sp, #8
    8c34:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_BUF;
    8c36:	f06f 0001 	mvn.w	r0, #1
    8c3a:	e7fa      	b.n	8c32 <etharp_output+0xee>
					return ERR_RTE;
    8c3c:	f06f 0003 	mvn.w	r0, #3
    8c40:	e7f7      	b.n	8c32 <etharp_output+0xee>
    8c42:	f06f 0003 	mvn.w	r0, #3
    8c46:	e7f4      	b.n	8c32 <etharp_output+0xee>
    8c48:	00005435 	.word	0x00005435
    8c4c:	00004739 	.word	0x00004739
    8c50:	20007fd8 	.word	0x20007fd8
    8c54:	0000897d 	.word	0x0000897d
    8c58:	000089ed 	.word	0x000089ed
    8c5c:	0000be04 	.word	0x0000be04
    8c60:	00008841 	.word	0x00008841

00008c64 <ethernet_input>:
 *
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t ethernet_input(struct pbuf *p, struct netif *netif)
{
    8c64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8c68:	b083      	sub	sp, #12
    8c6a:	4604      	mov	r4, r0
	u16_t           type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
	s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

	if (p->len <= SIZEOF_ETH_HDR) {
    8c6c:	8946      	ldrh	r6, [r0, #10]
    8c6e:	2e0e      	cmp	r6, #14
    8c70:	d919      	bls.n	8ca6 <ethernet_input+0x42>
    8c72:	460f      	mov	r7, r1
		ETHARP_STATS_INC(etharp.drop);
		goto free_and_return;
	}

	/* points to packet payload, which starts with an Ethernet header */
	ethhdr = (struct eth_hdr *)p->payload;
    8c74:	6845      	ldr	r5, [r0, #4]
	             (unsigned)ethhdr->src.addr[3],
	             (unsigned)ethhdr->src.addr[4],
	             (unsigned)ethhdr->src.addr[5],
	             (unsigned)htons(ethhdr->type)));

	type = ethhdr->type;
    8c76:	f8b5 800c 	ldrh.w	r8, [r5, #12]

#if LWIP_ARP_FILTER_NETIF
	netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

	if (ethhdr->dest.addr[0] & 1) {
    8c7a:	782b      	ldrb	r3, [r5, #0]
    8c7c:	f013 0f01 	tst.w	r3, #1
    8c80:	d00b      	beq.n	8c9a <ethernet_input+0x36>
		/* this might be a multicast or broadcast packet */
		if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
    8c82:	2b01      	cmp	r3, #1
    8c84:	d016      	beq.n	8cb4 <ethernet_input+0x50>
			if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) && (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
				/* mark the pbuf as link-layer multicast */
				p->flags |= PBUF_FLAG_LLMCAST;
			}
		} else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
    8c86:	2206      	movs	r2, #6
    8c88:	4976      	ldr	r1, [pc, #472]	; (8e64 <ethernet_input+0x200>)
    8c8a:	4628      	mov	r0, r5
    8c8c:	4b76      	ldr	r3, [pc, #472]	; (8e68 <ethernet_input+0x204>)
    8c8e:	4798      	blx	r3
    8c90:	b918      	cbnz	r0, 8c9a <ethernet_input+0x36>
			/* mark the pbuf as link-layer broadcast */
			p->flags |= PBUF_FLAG_LLBCAST;
    8c92:	7b63      	ldrb	r3, [r4, #13]
    8c94:	f043 0308 	orr.w	r3, r3, #8
    8c98:	7363      	strb	r3, [r4, #13]
		}
	}

	switch (type) {
    8c9a:	f1b8 0f08 	cmp.w	r8, #8
    8c9e:	d014      	beq.n	8cca <ethernet_input+0x66>
    8ca0:	f5b8 6fc1 	cmp.w	r8, #1544	; 0x608
    8ca4:	d022      	beq.n	8cec <ethernet_input+0x88>
	/* This means the pbuf is freed or consumed,
	   so the caller doesn't have to free it again */
	return ERR_OK;

free_and_return:
	pbuf_free(p);
    8ca6:	4620      	mov	r0, r4
    8ca8:	4b70      	ldr	r3, [pc, #448]	; (8e6c <ethernet_input+0x208>)
    8caa:	4798      	blx	r3
	return ERR_OK;
}
    8cac:	2000      	movs	r0, #0
    8cae:	b003      	add	sp, #12
    8cb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) && (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
    8cb4:	786b      	ldrb	r3, [r5, #1]
    8cb6:	2b00      	cmp	r3, #0
    8cb8:	d1ef      	bne.n	8c9a <ethernet_input+0x36>
    8cba:	78ab      	ldrb	r3, [r5, #2]
    8cbc:	2b5e      	cmp	r3, #94	; 0x5e
    8cbe:	d1ec      	bne.n	8c9a <ethernet_input+0x36>
				p->flags |= PBUF_FLAG_LLMCAST;
    8cc0:	7b43      	ldrb	r3, [r0, #13]
    8cc2:	f043 0310 	orr.w	r3, r3, #16
    8cc6:	7343      	strb	r3, [r0, #13]
    8cc8:	e7e7      	b.n	8c9a <ethernet_input+0x36>
		if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    8cca:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
    8cce:	f013 0f20 	tst.w	r3, #32
    8cd2:	d0e8      	beq.n	8ca6 <ethernet_input+0x42>
		if (pbuf_header(p, -ip_hdr_offset)) {
    8cd4:	f06f 010d 	mvn.w	r1, #13
    8cd8:	4620      	mov	r0, r4
    8cda:	4b65      	ldr	r3, [pc, #404]	; (8e70 <ethernet_input+0x20c>)
    8cdc:	4798      	blx	r3
    8cde:	2800      	cmp	r0, #0
    8ce0:	d1e1      	bne.n	8ca6 <ethernet_input+0x42>
			ip_input(p, netif);
    8ce2:	4639      	mov	r1, r7
    8ce4:	4620      	mov	r0, r4
    8ce6:	4b63      	ldr	r3, [pc, #396]	; (8e74 <ethernet_input+0x210>)
    8ce8:	4798      	blx	r3
		break;
    8cea:	e7df      	b.n	8cac <ethernet_input+0x48>
		if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    8cec:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
    8cf0:	f013 0f20 	tst.w	r3, #32
    8cf4:	d0d7      	beq.n	8ca6 <ethernet_input+0x42>
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    8cf6:	b167      	cbz	r7, 8d12 <ethernet_input+0xae>
	if (p->len < SIZEOF_ETHARP_PACKET) {
    8cf8:	2e29      	cmp	r6, #41	; 0x29
    8cfa:	d912      	bls.n	8d22 <ethernet_input+0xbe>
	if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) || (hdr->hwlen != ETHARP_HWADDR_LEN)
    8cfc:	89eb      	ldrh	r3, [r5, #14]
    8cfe:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    8d02:	d102      	bne.n	8d0a <ethernet_input+0xa6>
    8d04:	7cab      	ldrb	r3, [r5, #18]
    8d06:	2b06      	cmp	r3, #6
    8d08:	d00f      	beq.n	8d2a <ethernet_input+0xc6>
		pbuf_free(p);
    8d0a:	4620      	mov	r0, r4
    8d0c:	4b57      	ldr	r3, [pc, #348]	; (8e6c <ethernet_input+0x208>)
    8d0e:	4798      	blx	r3
    8d10:	e7cc      	b.n	8cac <ethernet_input+0x48>
	LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    8d12:	4b59      	ldr	r3, [pc, #356]	; (8e78 <ethernet_input+0x214>)
    8d14:	f44f 7233 	mov.w	r2, #716	; 0x2cc
    8d18:	4958      	ldr	r1, [pc, #352]	; (8e7c <ethernet_input+0x218>)
    8d1a:	4859      	ldr	r0, [pc, #356]	; (8e80 <ethernet_input+0x21c>)
    8d1c:	4c59      	ldr	r4, [pc, #356]	; (8e84 <ethernet_input+0x220>)
    8d1e:	47a0      	blx	r4
    8d20:	e7fe      	b.n	8d20 <ethernet_input+0xbc>
		pbuf_free(p);
    8d22:	4620      	mov	r0, r4
    8d24:	4b51      	ldr	r3, [pc, #324]	; (8e6c <ethernet_input+0x208>)
    8d26:	4798      	blx	r3
    8d28:	e7c0      	b.n	8cac <ethernet_input+0x48>
	    || (hdr->protolen != sizeof(ip_addr_t)) || (hdr->proto != PP_HTONS(ETHTYPE_IP))) {
    8d2a:	7ceb      	ldrb	r3, [r5, #19]
    8d2c:	2b04      	cmp	r3, #4
    8d2e:	d1ec      	bne.n	8d0a <ethernet_input+0xa6>
    8d30:	8a2b      	ldrh	r3, [r5, #16]
    8d32:	2b08      	cmp	r3, #8
    8d34:	d1e9      	bne.n	8d0a <ethernet_input+0xa6>
	IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
    8d36:	69e8      	ldr	r0, [r5, #28]
    8d38:	9001      	str	r0, [sp, #4]
	IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
    8d3a:	f8d5 2026 	ldr.w	r2, [r5, #38]	; 0x26
	if (ip_addr_isany(&netif->ip_addr)) {
    8d3e:	f117 0f04 	cmn.w	r7, #4
    8d42:	f000 8087 	beq.w	8e54 <ethernet_input+0x1f0>
    8d46:	687b      	ldr	r3, [r7, #4]
    8d48:	2b00      	cmp	r3, #0
    8d4a:	f000 8083 	beq.w	8e54 <ethernet_input+0x1f0>
		for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
    8d4e:	429a      	cmp	r2, r3
    8d50:	bf0c      	ite	eq
    8d52:	f04f 0901 	moveq.w	r9, #1
    8d56:	f04f 0900 	movne.w	r9, #0
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    8d5a:	f105 0616 	add.w	r6, r5, #22
    8d5e:	bf12      	itee	ne
    8d60:	f04f 0a02 	movne.w	sl, #2
		for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
    8d64:	f04f 0901 	moveq.w	r9, #1
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    8d68:	46ca      	moveq	sl, r9
		etharp_arp_input(netif, (struct eth_addr *)(netif->hwaddr), p);
    8d6a:	f107 082f 	add.w	r8, r7, #47	; 0x2f
	if (ip_addr_isany(ipaddr) || ip_addr_isbroadcast(ipaddr, netif) || ip_addr_ismulticast(ipaddr)) {
    8d6e:	2800      	cmp	r0, #0
    8d70:	d03a      	beq.n	8de8 <ethernet_input+0x184>
    8d72:	4639      	mov	r1, r7
    8d74:	4b44      	ldr	r3, [pc, #272]	; (8e88 <ethernet_input+0x224>)
    8d76:	4798      	blx	r3
    8d78:	bbb0      	cbnz	r0, 8de8 <ethernet_input+0x184>
    8d7a:	9b01      	ldr	r3, [sp, #4]
    8d7c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    8d80:	2be0      	cmp	r3, #224	; 0xe0
    8d82:	d031      	beq.n	8de8 <ethernet_input+0x184>
	i = etharp_find_entry(ipaddr, flags);
    8d84:	4651      	mov	r1, sl
    8d86:	a801      	add	r0, sp, #4
    8d88:	4b40      	ldr	r3, [pc, #256]	; (8e8c <ethernet_input+0x228>)
    8d8a:	4798      	blx	r3
	if (i < 0) {
    8d8c:	1e03      	subs	r3, r0, #0
    8d8e:	db2b      	blt.n	8de8 <ethernet_input+0x184>
		arp_table[i].state = ETHARP_STATE_STABLE;
    8d90:	f8df e104 	ldr.w	lr, [pc, #260]	; 8e98 <ethernet_input+0x234>
    8d94:	009a      	lsls	r2, r3, #2
    8d96:	18d1      	adds	r1, r2, r3
    8d98:	0089      	lsls	r1, r1, #2
    8d9a:	eb0e 0c01 	add.w	ip, lr, r1
    8d9e:	2002      	movs	r0, #2
    8da0:	f88c 0012 	strb.w	r0, [ip, #18]
	arp_table[i].netif = netif;
    8da4:	f8cc 7008 	str.w	r7, [ip, #8]
	ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    8da8:	460a      	mov	r2, r1
    8daa:	320c      	adds	r2, #12
    8dac:	eb0e 0a02 	add.w	sl, lr, r2
    8db0:	6830      	ldr	r0, [r6, #0]
    8db2:	f84e 0002 	str.w	r0, [lr, r2]
    8db6:	88b2      	ldrh	r2, [r6, #4]
    8db8:	f8aa 2004 	strh.w	r2, [sl, #4]
	arp_table[i].ctime = 0;
    8dbc:	2200      	movs	r2, #0
    8dbe:	f88c 2013 	strb.w	r2, [ip, #19]
	if (arp_table[i].q != NULL) {
    8dc2:	f85e a001 	ldr.w	sl, [lr, r1]
    8dc6:	f1ba 0f00 	cmp.w	sl, #0
    8dca:	d00d      	beq.n	8de8 <ethernet_input+0x184>
		arp_table[i].q = NULL;
    8dcc:	460b      	mov	r3, r1
    8dce:	4611      	mov	r1, r2
    8dd0:	f84e 1003 	str.w	r1, [lr, r3]
		etharp_send_ip(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr);
    8dd4:	4633      	mov	r3, r6
    8dd6:	4642      	mov	r2, r8
    8dd8:	4651      	mov	r1, sl
    8dda:	4638      	mov	r0, r7
    8ddc:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 8e9c <ethernet_input+0x238>
    8de0:	47d8      	blx	fp
		pbuf_free(p);
    8de2:	4650      	mov	r0, sl
    8de4:	4b21      	ldr	r3, [pc, #132]	; (8e6c <ethernet_input+0x208>)
    8de6:	4798      	blx	r3
	switch (hdr->opcode) {
    8de8:	8aab      	ldrh	r3, [r5, #20]
    8dea:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    8dee:	d006      	beq.n	8dfe <ethernet_input+0x19a>
    8df0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    8df4:	d029      	beq.n	8e4a <ethernet_input+0x1e6>
	pbuf_free(p);
    8df6:	4620      	mov	r0, r4
    8df8:	4b1c      	ldr	r3, [pc, #112]	; (8e6c <ethernet_input+0x208>)
    8dfa:	4798      	blx	r3
    8dfc:	e756      	b.n	8cac <ethernet_input+0x48>
		if (for_us) {
    8dfe:	f1b9 0f00 	cmp.w	r9, #0
    8e02:	d0f8      	beq.n	8df6 <ethernet_input+0x192>
			hdr->opcode = htons(ARP_REPLY);
    8e04:	2002      	movs	r0, #2
    8e06:	4b22      	ldr	r3, [pc, #136]	; (8e90 <ethernet_input+0x22c>)
    8e08:	4798      	blx	r3
    8e0a:	82a8      	strh	r0, [r5, #20]
			IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
    8e0c:	69eb      	ldr	r3, [r5, #28]
    8e0e:	f8c5 3026 	str.w	r3, [r5, #38]	; 0x26
			IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
    8e12:	687b      	ldr	r3, [r7, #4]
    8e14:	61eb      	str	r3, [r5, #28]
			ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
    8e16:	6833      	ldr	r3, [r6, #0]
    8e18:	622b      	str	r3, [r5, #32]
    8e1a:	88b3      	ldrh	r3, [r6, #4]
    8e1c:	84ab      	strh	r3, [r5, #36]	; 0x24
			ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
    8e1e:	6833      	ldr	r3, [r6, #0]
    8e20:	602b      	str	r3, [r5, #0]
    8e22:	88b3      	ldrh	r3, [r6, #4]
    8e24:	80ab      	strh	r3, [r5, #4]
			ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
    8e26:	f8d8 3000 	ldr.w	r3, [r8]
    8e2a:	6033      	str	r3, [r6, #0]
    8e2c:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    8e30:	80b3      	strh	r3, [r6, #4]
			ETHADDR16_COPY(&ethhdr->src, ethaddr);
    8e32:	f8d8 3000 	ldr.w	r3, [r8]
    8e36:	f8c5 3006 	str.w	r3, [r5, #6]
    8e3a:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    8e3e:	816b      	strh	r3, [r5, #10]
			netif->linkoutput(netif, p);
    8e40:	69bb      	ldr	r3, [r7, #24]
    8e42:	4621      	mov	r1, r4
    8e44:	4638      	mov	r0, r7
    8e46:	4798      	blx	r3
    8e48:	e7d5      	b.n	8df6 <ethernet_input+0x192>
		dhcp_arp_reply(netif, &sipaddr);
    8e4a:	a901      	add	r1, sp, #4
    8e4c:	4638      	mov	r0, r7
    8e4e:	4b11      	ldr	r3, [pc, #68]	; (8e94 <ethernet_input+0x230>)
    8e50:	4798      	blx	r3
    8e52:	e7d0      	b.n	8df6 <ethernet_input+0x192>
	etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
    8e54:	f105 0616 	add.w	r6, r5, #22
    8e58:	f04f 0900 	mov.w	r9, #0
    8e5c:	f04f 0a02 	mov.w	sl, #2
    8e60:	e783      	b.n	8d6a <ethernet_input+0x106>
    8e62:	bf00      	nop
    8e64:	0000be04 	.word	0x0000be04
    8e68:	000097d1 	.word	0x000097d1
    8e6c:	000054c9 	.word	0x000054c9
    8e70:	00005435 	.word	0x00005435
    8e74:	00004411 	.word	0x00004411
    8e78:	0000be0c 	.word	0x0000be0c
    8e7c:	0000b418 	.word	0x0000b418
    8e80:	0000ab0c 	.word	0x0000ab0c
    8e84:	00009815 	.word	0x00009815
    8e88:	00004739 	.word	0x00004739
    8e8c:	00008741 	.word	0x00008741
    8e90:	000026e5 	.word	0x000026e5
    8e94:	0000391d 	.word	0x0000391d
    8e98:	20007fd8 	.word	0x20007fd8
    8e9c:	00008841 	.word	0x00008841

00008ea0 <mac_transmit_cb>:
	//gpio_set_pin_level(PHY_YELLOW_LED_PIN,false);
	gpio_set_pin_level(PHY_YELLOW_LED_PIN,true);
}

void mac_transmit_cb(struct mac_async_descriptor *desc)
{
    8ea0:	4770      	bx	lr
	...

00008ea4 <MotorTimerTask_cb>:
#endif		
		
static struct timer_task MotorTimerTask;

static void MotorTimerTask_cb(const struct timer_task *const timer_task)
{
    8ea4:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint8_t temp;
	uint8_t i;


	//go through each motor status and set/reset the correct PORTB and PORTC pins
	for(i=0;i<NumMotors;i++) {//NUM_MOTORS;i++) {
    8ea6:	4b39      	ldr	r3, [pc, #228]	; (8f8c <MotorTimerTask_cb+0xe8>)
    8ea8:	781e      	ldrb	r6, [r3, #0]
    8eaa:	2e00      	cmp	r6, #0
    8eac:	d06c      	beq.n	8f88 <MotorTimerTask_cb+0xe4>
				//*Motor[i].PulsePort&=Motor[i].PulseBitMask;
				gpio_set_pin_level(Motor[i].PulsePin,false);
			} //if (Motor[i].StrengthCount<motor[i].Strength)

			Motor[i].StrengthCount++;  //increase duty cycle count
			if (Motor[i].StrengthCount>=NumClocksInMotorDutyCycle) {  //reached end of duty cycle, reset count
    8eae:	4b38      	ldr	r3, [pc, #224]	; (8f90 <MotorTimerTask_cb+0xec>)
    8eb0:	f8d3 e000 	ldr.w	lr, [r3]
    8eb4:	4b37      	ldr	r3, [pc, #220]	; (8f94 <MotorTimerTask_cb+0xf0>)
    8eb6:	2000      	movs	r0, #0
				Motor[i].Duration--;  //currently units are timer interrupts
			}
			//which depend on MotorDutyCycleClock
		} else {  //no motor Duration - set motor pins to 0

			Motor[i].StrengthCount=0;
    8eb8:	4607      	mov	r7, r0
 * \param[in] level true  = Pin level set to "high" state
 *                  false = Pin level set to "low" state
 */
static inline void gpio_set_pin_level(const uint8_t pin, const bool level)
{
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    8eba:	2501      	movs	r5, #1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    8ebc:	4c36      	ldr	r4, [pc, #216]	; (8f98 <MotorTimerTask_cb+0xf4>)
    8ebe:	e03e      	b.n	8f3e <MotorTimerTask_cb+0x9a>
					gpio_set_pin_level(Motor[i].DirPin,false);
    8ec0:	7919      	ldrb	r1, [r3, #4]
    8ec2:	f001 0c1f 	and.w	ip, r1, #31
    8ec6:	fa05 fc0c 	lsl.w	ip, r5, ip
    8eca:	0949      	lsrs	r1, r1, #5
    8ecc:	eb04 11c1 	add.w	r1, r4, r1, lsl #7
    8ed0:	f8c1 c014 	str.w	ip, [r1, #20]
    8ed4:	e04d      	b.n	8f72 <MotorTimerTask_cb+0xce>
				if (Motor[i].flags&MOTOR_INST_FIRST_RUN) {
    8ed6:	7819      	ldrb	r1, [r3, #0]
    8ed8:	f011 0f02 	tst.w	r1, #2
    8edc:	d115      	bne.n	8f0a <MotorTimerTask_cb+0x66>
				gpio_set_pin_level(Motor[i].PulsePin,false);
    8ede:	7a11      	ldrb	r1, [r2, #8]
    8ee0:	f001 0c1f 	and.w	ip, r1, #31
    8ee4:	fa05 fc0c 	lsl.w	ip, r5, ip
    8ee8:	0949      	lsrs	r1, r1, #5
    8eea:	eb04 11c1 	add.w	r1, r4, r1, lsl #7
    8eee:	f8c1 c014 	str.w	ip, [r1, #20]
			Motor[i].StrengthCount++;  //increase duty cycle count
    8ef2:	8c51      	ldrh	r1, [r2, #34]	; 0x22
    8ef4:	3101      	adds	r1, #1
    8ef6:	b289      	uxth	r1, r1
    8ef8:	8451      	strh	r1, [r2, #34]	; 0x22
			if (Motor[i].StrengthCount>=NumClocksInMotorDutyCycle) {  //reached end of duty cycle, reset count
    8efa:	4571      	cmp	r1, lr
				Motor[i].StrengthCount=0;
    8efc:	bfa8      	it	ge
    8efe:	8457      	strhge	r7, [r2, #34]	; 0x22
			if (Motor[i].Duration!=0) { //new inst might set Duration=0
    8f00:	6a51      	ldr	r1, [r2, #36]	; 0x24
    8f02:	b1b9      	cbz	r1, 8f34 <MotorTimerTask_cb+0x90>
				Motor[i].Duration--;  //currently units are timer interrupts
    8f04:	3901      	subs	r1, #1
    8f06:	6251      	str	r1, [r2, #36]	; 0x24
    8f08:	e014      	b.n	8f34 <MotorTimerTask_cb+0x90>
					Motor[i].flags&=~MOTOR_INST_FIRST_RUN; //clear first run bit
    8f0a:	f021 0102 	bic.w	r1, r1, #2
    8f0e:	7011      	strb	r1, [r2, #0]
					if (Motor[i].StrengthCount>0) {
    8f10:	f1bc 0f00 	cmp.w	ip, #0
    8f14:	d0e3      	beq.n	8ede <MotorTimerTask_cb+0x3a>
						Motor[i].StrengthCount--; //set back 1 so direction can get set above
    8f16:	f10c 3cff 	add.w	ip, ip, #4294967295
    8f1a:	f8a2 c022 	strh.w	ip, [r2, #34]	; 0x22
    8f1e:	e7de      	b.n	8ede <MotorTimerTask_cb+0x3a>
			Motor[i].StrengthCount=0;
    8f20:	845f      	strh	r7, [r3, #34]	; 0x22
									    
			gpio_set_pin_level(Motor[i].PulsePin,false);
    8f22:	7a1a      	ldrb	r2, [r3, #8]
    8f24:	f002 011f 	and.w	r1, r2, #31
    8f28:	fa05 f101 	lsl.w	r1, r5, r1
    8f2c:	0952      	lsrs	r2, r2, #5
    8f2e:	eb04 12c2 	add.w	r2, r4, r2, lsl #7
    8f32:	6151      	str	r1, [r2, #20]
    8f34:	3001      	adds	r0, #1
    8f36:	332c      	adds	r3, #44	; 0x2c
	for(i=0;i<NumMotors;i++) {//NUM_MOTORS;i++) {
    8f38:	b2c2      	uxtb	r2, r0
    8f3a:	4296      	cmp	r6, r2
    8f3c:	d924      	bls.n	8f88 <MotorTimerTask_cb+0xe4>
    8f3e:	461a      	mov	r2, r3
		if (Motor[i].Duration>0) { //this motor is moving, or will start moving
    8f40:	6a59      	ldr	r1, [r3, #36]	; 0x24
    8f42:	2900      	cmp	r1, #0
    8f44:	d0ec      	beq.n	8f20 <MotorTimerTask_cb+0x7c>
			if (Motor[i].StrengthCount<Motor[i].Strength && !(Motor[i].flags&MOTOR_INST_FIRST_RUN)) { //set motor pins
    8f46:	f8b3 c022 	ldrh.w	ip, [r3, #34]	; 0x22
    8f4a:	8c19      	ldrh	r1, [r3, #32]
    8f4c:	4561      	cmp	r1, ip
    8f4e:	d9c2      	bls.n	8ed6 <MotorTimerTask_cb+0x32>
    8f50:	7819      	ldrb	r1, [r3, #0]
    8f52:	f011 0f02 	tst.w	r1, #2
    8f56:	d1d8      	bne.n	8f0a <MotorTimerTask_cb+0x66>
				if (Motor[i].Direction) {
    8f58:	68d9      	ldr	r1, [r3, #12]
    8f5a:	2900      	cmp	r1, #0
    8f5c:	d0b0      	beq.n	8ec0 <MotorTimerTask_cb+0x1c>
					gpio_set_pin_level(Motor[i].DirPin,true);
    8f5e:	7919      	ldrb	r1, [r3, #4]
    8f60:	f001 0c1f 	and.w	ip, r1, #31
    8f64:	fa05 fc0c 	lsl.w	ip, r5, ip
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8f68:	0949      	lsrs	r1, r1, #5
    8f6a:	eb04 11c1 	add.w	r1, r4, r1, lsl #7
    8f6e:	f8c1 c018 	str.w	ip, [r1, #24]
				gpio_set_pin_level(Motor[i].PulsePin,true);
    8f72:	7a11      	ldrb	r1, [r2, #8]
    8f74:	f001 0c1f 	and.w	ip, r1, #31
    8f78:	fa05 fc0c 	lsl.w	ip, r5, ip
    8f7c:	0949      	lsrs	r1, r1, #5
    8f7e:	eb04 11c1 	add.w	r1, r4, r1, lsl #7
    8f82:	f8c1 c018 	str.w	ip, [r1, #24]
    8f86:	e7b4      	b.n	8ef2 <MotorTimerTask_cb+0x4e>
    8f88:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8f8a:	bf00      	nop
    8f8c:	20009300 	.word	0x20009300
    8f90:	200095cc 	.word	0x200095cc
    8f94:	2000930c 	.word	0x2000930c
    8f98:	41008000 	.word	0x41008000

00008f9c <mac_receive_cb>:
{
    8f9c:	b538      	push	{r3, r4, r5, lr}
	gmac_recv_flag = true;
    8f9e:	2001      	movs	r0, #1
    8fa0:	4b05      	ldr	r3, [pc, #20]	; (8fb8 <mac_receive_cb+0x1c>)
    8fa2:	7018      	strb	r0, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    8fa4:	4c05      	ldr	r4, [pc, #20]	; (8fbc <mac_receive_cb+0x20>)
    8fa6:	f44f 4580 	mov.w	r5, #16384	; 0x4000
    8faa:	f8c4 5114 	str.w	r5, [r4, #276]	; 0x114
	delay_ms(1);
    8fae:	4b04      	ldr	r3, [pc, #16]	; (8fc0 <mac_receive_cb+0x24>)
    8fb0:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8fb2:	f8c4 5118 	str.w	r5, [r4, #280]	; 0x118
    8fb6:	bd38      	pop	{r3, r4, r5, pc}
    8fb8:	200080a4 	.word	0x200080a4
    8fbc:	41008000 	.word	0x41008000
    8fc0:	00000e05 	.word	0x00000e05

00008fc4 <status_callback>:
{
    8fc4:	b508      	push	{r3, lr}
	if (n->flags & NETIF_FLAG_UP) {
    8fc6:	f890 1035 	ldrb.w	r1, [r0, #53]	; 0x35
    8fca:	f011 0f01 	tst.w	r1, #1
    8fce:	d00b      	beq.n	8fe8 <status_callback+0x24>
		printf("Interface Up %s:\n",
    8fd0:	f001 0108 	and.w	r1, r1, #8
    8fd4:	4b06      	ldr	r3, [pc, #24]	; (8ff0 <status_callback+0x2c>)
    8fd6:	4a07      	ldr	r2, [pc, #28]	; (8ff4 <status_callback+0x30>)
    8fd8:	2900      	cmp	r1, #0
    8fda:	bf14      	ite	ne
    8fdc:	4611      	movne	r1, r2
    8fde:	4619      	moveq	r1, r3
    8fe0:	4805      	ldr	r0, [pc, #20]	; (8ff8 <status_callback+0x34>)
    8fe2:	4b06      	ldr	r3, [pc, #24]	; (8ffc <status_callback+0x38>)
    8fe4:	4798      	blx	r3
    8fe6:	bd08      	pop	{r3, pc}
		printf("Interface Down.\n");
    8fe8:	4805      	ldr	r0, [pc, #20]	; (9000 <status_callback+0x3c>)
    8fea:	4b06      	ldr	r3, [pc, #24]	; (9004 <status_callback+0x40>)
    8fec:	4798      	blx	r3
    8fee:	bd08      	pop	{r3, pc}
    8ff0:	0000be3c 	.word	0x0000be3c
    8ff4:	0000be34 	.word	0x0000be34
    8ff8:	0000be48 	.word	0x0000be48
    8ffc:	00009815 	.word	0x00009815
    9000:	0000be5c 	.word	0x0000be5c
    9004:	000098fd 	.word	0x000098fd

00009008 <link_callback>:
{
    9008:	b510      	push	{r4, lr}
	if (n->flags & NETIF_FLAG_LINK_UP) {
    900a:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
    900e:	f013 0f10 	tst.w	r3, #16
    9012:	d00f      	beq.n	9034 <link_callback+0x2c>
    9014:	4604      	mov	r4, r0
		printf("Link Up.\n");
    9016:	4809      	ldr	r0, [pc, #36]	; (903c <link_callback+0x34>)
    9018:	4b09      	ldr	r3, [pc, #36]	; (9040 <link_callback+0x38>)
    901a:	4798      	blx	r3
		if (n->flags & NETIF_FLAG_DHCP) {
    901c:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
    9020:	f013 0f08 	tst.w	r3, #8
    9024:	d009      	beq.n	903a <link_callback+0x32>
			printf("Restarting DHCP\n");
    9026:	4807      	ldr	r0, [pc, #28]	; (9044 <link_callback+0x3c>)
    9028:	4b05      	ldr	r3, [pc, #20]	; (9040 <link_callback+0x38>)
    902a:	4798      	blx	r3
			dhcp_start(n);
    902c:	4620      	mov	r0, r4
    902e:	4b06      	ldr	r3, [pc, #24]	; (9048 <link_callback+0x40>)
    9030:	4798      	blx	r3
    9032:	bd10      	pop	{r4, pc}
		printf("Link Down.\n");
    9034:	4805      	ldr	r0, [pc, #20]	; (904c <link_callback+0x44>)
    9036:	4b02      	ldr	r3, [pc, #8]	; (9040 <link_callback+0x38>)
    9038:	4798      	blx	r3
    903a:	bd10      	pop	{r4, pc}
    903c:	0000be6c 	.word	0x0000be6c
    9040:	000098fd 	.word	0x000098fd
    9044:	0000be78 	.word	0x0000be78
    9048:	00003e89 	.word	0x00003e89
    904c:	0000be88 	.word	0x0000be88

00009050 <sys_now>:
	return systick_timems;
    9050:	4b01      	ldr	r3, [pc, #4]	; (9058 <sys_now+0x8>)
    9052:	6858      	ldr	r0, [r3, #4]
}
    9054:	4770      	bx	lr
    9056:	bf00      	nop
    9058:	200080a4 	.word	0x200080a4

0000905c <SysTick_Handler>:
	systick_timems++;
    905c:	4a02      	ldr	r2, [pc, #8]	; (9068 <SysTick_Handler+0xc>)
    905e:	6853      	ldr	r3, [r2, #4]
    9060:	3301      	adds	r3, #1
    9062:	6053      	str	r3, [r2, #4]
    9064:	4770      	bx	lr
    9066:	bf00      	nop
    9068:	200080a4 	.word	0x200080a4

0000906c <systick_enable>:
	systick_timems = 0;
    906c:	2200      	movs	r2, #0
    906e:	4b06      	ldr	r3, [pc, #24]	; (9088 <systick_enable+0x1c>)
    9070:	605a      	str	r2, [r3, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    9072:	4b06      	ldr	r3, [pc, #24]	; (908c <systick_enable+0x20>)
    9074:	4906      	ldr	r1, [pc, #24]	; (9090 <systick_enable+0x24>)
    9076:	6059      	str	r1, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9078:	20e0      	movs	r0, #224	; 0xe0
    907a:	4906      	ldr	r1, [pc, #24]	; (9094 <systick_enable+0x28>)
    907c:	f881 0023 	strb.w	r0, [r1, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    9080:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    9082:	2207      	movs	r2, #7
    9084:	601a      	str	r2, [r3, #0]
    9086:	4770      	bx	lr
    9088:	200080a4 	.word	0x200080a4
    908c:	e000e010 	.word	0xe000e010
    9090:	0001d4bf 	.word	0x0001d4bf
    9094:	e000ed00 	.word	0xe000ed00

00009098 <ringbuffer_last>:
{
    9098:	b510      	push	{r4, lr}
    ASSERT(rb);
    909a:	4604      	mov	r4, r0
    909c:	223f      	movs	r2, #63	; 0x3f
    909e:	4906      	ldr	r1, [pc, #24]	; (90b8 <ringbuffer_last+0x20>)
    90a0:	3000      	adds	r0, #0
    90a2:	bf18      	it	ne
    90a4:	2001      	movne	r0, #1
    90a6:	4b05      	ldr	r3, [pc, #20]	; (90bc <ringbuffer_last+0x24>)
    90a8:	4798      	blx	r3
    uint8_t data = rb->buf[(rb->write_index-1) & rb->size];
    90aa:	68e3      	ldr	r3, [r4, #12]
    90ac:	3b01      	subs	r3, #1
    90ae:	6862      	ldr	r2, [r4, #4]
    90b0:	4013      	ands	r3, r2
    90b2:	6822      	ldr	r2, [r4, #0]
}
    90b4:	5cd0      	ldrb	r0, [r2, r3]
    90b6:	bd10      	pop	{r4, pc}
    90b8:	0000be94 	.word	0x0000be94
    90bc:	000016f5 	.word	0x000016f5

000090c0 <usart1_receive_cb>:
{
    90c0:	b508      	push	{r3, lr}
    if( ringbuffer_last(&io_descr->rx) == 0x0a ) {
    90c2:	3034      	adds	r0, #52	; 0x34
    90c4:	4b04      	ldr	r3, [pc, #16]	; (90d8 <usart1_receive_cb+0x18>)
    90c6:	4798      	blx	r3
    90c8:	280a      	cmp	r0, #10
    90ca:	d000      	beq.n	90ce <usart1_receive_cb+0xe>
    90cc:	bd08      	pop	{r3, pc}
        line_available = true;
    90ce:	2201      	movs	r2, #1
    90d0:	4b02      	ldr	r3, [pc, #8]	; (90dc <usart1_receive_cb+0x1c>)
    90d2:	721a      	strb	r2, [r3, #8]
}
    90d4:	e7fa      	b.n	90cc <usart1_receive_cb+0xc>
    90d6:	bf00      	nop
    90d8:	00009099 	.word	0x00009099
    90dc:	200080a4 	.word	0x200080a4

000090e0 <MotorTimer_Initialize>:



//tph - TIMER_0 uses the TC0 peripheral which takes as input the 12MHz general clock divided by 4 = 3Mhz to produce (/75) a 40khz (25us) signal for Motor pwm
void MotorTimer_Initialize(void)
{
    90e0:	b510      	push	{r4, lr}
	MotorTimerTask.interval = 1; //clock ticks
    90e2:	4907      	ldr	r1, [pc, #28]	; (9100 <MotorTimer_Initialize+0x20>)
    90e4:	2301      	movs	r3, #1
    90e6:	614b      	str	r3, [r1, #20]
	MotorTimerTask.cb       = MotorTimerTask_cb;
    90e8:	4a06      	ldr	r2, [pc, #24]	; (9104 <MotorTimer_Initialize+0x24>)
    90ea:	618a      	str	r2, [r1, #24]
	MotorTimerTask.mode     = TIMER_TASK_REPEAT;
    90ec:	770b      	strb	r3, [r1, #28]

	timer_add_task(&TIMER_0, &MotorTimerTask);
    90ee:	4c06      	ldr	r4, [pc, #24]	; (9108 <MotorTimer_Initialize+0x28>)
    90f0:	310c      	adds	r1, #12
    90f2:	4620      	mov	r0, r4
    90f4:	4b05      	ldr	r3, [pc, #20]	; (910c <MotorTimer_Initialize+0x2c>)
    90f6:	4798      	blx	r3
	timer_start(&TIMER_0);
    90f8:	4620      	mov	r0, r4
    90fa:	4b05      	ldr	r3, [pc, #20]	; (9110 <MotorTimer_Initialize+0x30>)
    90fc:	4798      	blx	r3
    90fe:	bd10      	pop	{r4, pc}
    9100:	200080a4 	.word	0x200080a4
    9104:	00008ea5 	.word	0x00008ea5
    9108:	20008268 	.word	0x20008268
    910c:	000011d5 	.word	0x000011d5
    9110:	00001199 	.word	0x00001199

00009114 <SendMotorInst>:
//and contains (in 4 bytes):
//Motor# (0:3),unused(4:7),direction(8),thrust(9:15),duration(16:31)
//was 3 bytes:
//motor# (address):4, direction:1, strength:3,duration:16
void SendMotorInst(uint8_t *MInst)
{
    9114:	b430      	push	{r4, r5}
    uint32_t Duration;

    //set the motor status so the timer interrupt
    //will find that a motor has a duration and needs to be moved
    //determine which motor
    MotorNum=(MInst[0]&0xf0)>>4;
    9116:	7803      	ldrb	r3, [r0, #0]

    Motor[MotorNum].Duration=0; //just in case motor is currently running (pulsing)
    9118:	091b      	lsrs	r3, r3, #4
    911a:	4924      	ldr	r1, [pc, #144]	; (91ac <SendMotorInst+0x98>)
    911c:	222c      	movs	r2, #44	; 0x2c
    911e:	fb02 f203 	mul.w	r2, r2, r3
    9122:	188c      	adds	r4, r1, r2
    9124:	2500      	movs	r5, #0
    9126:	6265      	str	r5, [r4, #36]	; 0x24
    //SYS_TMR_DelayMS(1);  //wait to make sure motor is stopped if running (pulsing)
    Motor[MotorNum].flags|=MOTOR_INST_FIRST_RUN; //first set motor pins to 00 to avoid short circuit
    9128:	5c8c      	ldrb	r4, [r1, r2]
    912a:	f044 0402 	orr.w	r4, r4, #2
    912e:	548c      	strb	r4, [r1, r2]
    //for example, motor is turning with 10 then a 01 instruction is sent, and for a nanosecond when LATB is being set, possibly 2 pins might be 1 and cause a short at the h-bridge.

    //if ((MInst[0]&0x08)!=0) {
    if ((MInst[1]&0x80)!=0) {
    9130:	f990 2001 	ldrsb.w	r2, [r0, #1]
    9134:	42aa      	cmp	r2, r5
    9136:	db2d      	blt.n	9194 <SendMotorInst+0x80>
         Motor[MotorNum].Direction=MOTOR_COUNTERCLOCKWISE;
    } else {
        //clock-wise
        //Motor[MotorNum].DirectionMask=0x80>>(MotorNum*2);  //clockwise
        //Motor[MotorNum].DirectionMask=0x2<<(MotorNum*2);  //clockwise
        Motor[MotorNum].Direction=MOTOR_CLOCKWISE;
    9138:	222c      	movs	r2, #44	; 0x2c
    913a:	491c      	ldr	r1, [pc, #112]	; (91ac <SendMotorInst+0x98>)
    913c:	fb02 1203 	mla	r2, r2, r3, r1
    9140:	2100      	movs	r1, #0
    9142:	60d1      	str	r1, [r2, #12]
    //0=stop 20=full speed (NumClkInDutyCycle)
    //this number is multiplied by the NumClocksInMotorDutyCycle/20
    //so for strength=1, Strength*NumClocksInMotorDutyCycle/20 (1 clks of 20 are on)
    //for strength=20 the motor is on for every clock (20 of 20)
    //Motor[MotorNum].Strength=((MInst[0]&0x07)*NumClocksInMotorDutyCycle)/ROBOT_MOTORS_DEFAULT_NUM_CLKS_IN_MOTOR_DUTY_CYCLE;
    Strength=(MInst[1]&0x7f);//max is currently 0 to 127
    9144:	7842      	ldrb	r2, [r0, #1]
    9146:	f002 027f 	and.w	r2, r2, #127	; 0x7f
        Strength=ROBOT_MOTORS_DEFAULT_NUM_CLKS_IN_MOTOR_DUTY_CYCLE;
    }

    //set motor turn duration (is 16-bit little endian int)
    //Motor[MotorNum].Duration=(uint16_t)((MInst[2]<<8)+MInst[1]);
    Duration=(uint32_t)((MInst[3]<<8)+MInst[2]);
    914a:	78c1      	ldrb	r1, [r0, #3]
    914c:	7880      	ldrb	r0, [r0, #2]
    914e:	eb00 2101 	add.w	r1, r0, r1, lsl #8
    //convert ms to 25us units
    //so Duration of 100ms in 25uS units=0.1/0.000025=4000 clocks * 2= 8000
    //in us: (100)*1000/25=4000, so generalizing in us:
    //Duration*1000/MotorDutyCycle = number of TimerInterrupts for 
    //user sent Duration in ms.
    Duration*=1000; //Duration is divided by MotorDutyCycleClock below
    9152:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    9156:	fb00 f001 	mul.w	r0, r0, r1
    //at 40khz (25us) a pulse:
	//duty cycle is 25us*20=500us
	//so 1/20 speed is 25us on 475us off (shortest pulse possible for drv8800- 40khz)
	//   19/20 speed is 475us on 25us off

    Motor[MotorNum].Strength=Strength;
    915a:	212c      	movs	r1, #44	; 0x2c
    915c:	4c13      	ldr	r4, [pc, #76]	; (91ac <SendMotorInst+0x98>)
    915e:	fb01 4103 	mla	r1, r1, r3, r4
    9162:	2a14      	cmp	r2, #20
    9164:	bf28      	it	cs
    9166:	2214      	movcs	r2, #20
    9168:	840a      	strh	r2, [r1, #32]
    Motor[MotorNum].StrengthCount=0;
    916a:	2200      	movs	r2, #0
    916c:	844a      	strh	r2, [r1, #34]	; 0x22

    //Convert duration in us to duration in number of timer interrupts
    //since multiplying by 1000 above, I doubt Duration would ever be < MotorDutyCycleClock
    //but just as a failsafe in case Motor[].Duration somehow will get set to 0]
    //and somebody is trying to set strength=0 - probably not needed
    if ((Duration/MotorDutyCycleClock)==0 && Duration>0) {
    916e:	4a10      	ldr	r2, [pc, #64]	; (91b0 <SendMotorInst+0x9c>)
    9170:	6812      	ldr	r2, [r2, #0]
    9172:	fbb0 f2f2 	udiv	r2, r0, r2
    9176:	b902      	cbnz	r2, 917a <SendMotorInst+0x66>
    9178:	b990      	cbnz	r0, 91a0 <SendMotorInst+0x8c>
      Motor[MotorNum].Duration=1;
    } else {
      Motor[MotorNum].Duration=Duration/MotorDutyCycleClock;  //note: this is the equivalent of enabling the motor
    917a:	212c      	movs	r1, #44	; 0x2c
    917c:	480b      	ldr	r0, [pc, #44]	; (91ac <SendMotorInst+0x98>)
    917e:	fb01 0103 	mla	r1, r1, r3, r0
    9182:	624a      	str	r2, [r1, #36]	; 0x24
    } 

    Motor[MotorNum].DurationCount=0;
    9184:	212c      	movs	r1, #44	; 0x2c
    9186:	4a09      	ldr	r2, [pc, #36]	; (91ac <SendMotorInst+0x98>)
    9188:	fb01 2303 	mla	r3, r1, r3, r2
    918c:	2200      	movs	r2, #0
    918e:	629a      	str	r2, [r3, #40]	; 0x28

	//was: start timer3 if not already started
} //SendMotorInst
    9190:	bc30      	pop	{r4, r5}
    9192:	4770      	bx	lr
         Motor[MotorNum].Direction=MOTOR_COUNTERCLOCKWISE;
    9194:	222c      	movs	r2, #44	; 0x2c
    9196:	fb02 1203 	mla	r2, r2, r3, r1
    919a:	2101      	movs	r1, #1
    919c:	60d1      	str	r1, [r2, #12]
    919e:	e7d1      	b.n	9144 <SendMotorInst+0x30>
      Motor[MotorNum].Duration=1;
    91a0:	222c      	movs	r2, #44	; 0x2c
    91a2:	fb02 4203 	mla	r2, r2, r3, r4
    91a6:	2101      	movs	r1, #1
    91a8:	6251      	str	r1, [r2, #36]	; 0x24
    91aa:	e7eb      	b.n	9184 <SendMotorInst+0x70>
    91ac:	2000930c 	.word	0x2000930c
    91b0:	20009308 	.word	0x20009308

000091b4 <USART_1_input>:
{
    91b4:	b530      	push	{r4, r5, lr}
    91b6:	b085      	sub	sp, #20
    usart_async_get_io_descriptor(&USART_1, &io);	// Get the pointer to statically allocated io_descriptor structure.
    91b8:	a903      	add	r1, sp, #12
    91ba:	4823      	ldr	r0, [pc, #140]	; (9248 <USART_1_input+0x94>)
    91bc:	4b23      	ldr	r3, [pc, #140]	; (924c <USART_1_input+0x98>)
    91be:	4798      	blx	r3
    if( nread <= 0 ) {
    91c0:	4b23      	ldr	r3, [pc, #140]	; (9250 <USART_1_input+0x9c>)
    91c2:	6a1b      	ldr	r3, [r3, #32]
    91c4:	2b00      	cmp	r3, #0
    91c6:	dd01      	ble.n	91cc <USART_1_input+0x18>
}
    91c8:	b005      	add	sp, #20
    91ca:	bd30      	pop	{r4, r5, pc}
        CRITICAL_SECTION_ENTER()
    91cc:	a801      	add	r0, sp, #4
    91ce:	4b21      	ldr	r3, [pc, #132]	; (9254 <USART_1_input+0xa0>)
    91d0:	4798      	blx	r3
        if(line_available) {
    91d2:	4b1f      	ldr	r3, [pc, #124]	; (9250 <USART_1_input+0x9c>)
    91d4:	7a1b      	ldrb	r3, [r3, #8]
    91d6:	2b00      	cmp	r3, #0
    91d8:	d031      	beq.n	923e <USART_1_input+0x8a>
            line_available = false;		// Decrementing the semaphore count from 1 to 0.
    91da:	4c1d      	ldr	r4, [pc, #116]	; (9250 <USART_1_input+0x9c>)
    91dc:	2300      	movs	r3, #0
    91de:	7223      	strb	r3, [r4, #8]
        CRITICAL_SECTION_LEAVE()
    91e0:	a801      	add	r0, sp, #4
    91e2:	4b1d      	ldr	r3, [pc, #116]	; (9258 <USART_1_input+0xa4>)
    91e4:	4798      	blx	r3
			nread = io_read(io, buffer, sizeof(buffer));	// Returns count of characters read (or negative error flag).
    91e6:	f44f 7280 	mov.w	r2, #256	; 0x100
    91ea:	f104 0124 	add.w	r1, r4, #36	; 0x24
    91ee:	9803      	ldr	r0, [sp, #12]
    91f0:	4b1a      	ldr	r3, [pc, #104]	; (925c <USART_1_input+0xa8>)
    91f2:	4798      	blx	r3
    91f4:	6220      	str	r0, [r4, #32]
			if (nread>0) {
    91f6:	2800      	cmp	r0, #0
    91f8:	dde6      	ble.n	91c8 <USART_1_input+0x14>
				buffer[nread]=0; //terminate string
    91fa:	4420      	add	r0, r4
    91fc:	2500      	movs	r5, #0
    91fe:	f880 5024 	strb.w	r5, [r0, #36]	; 0x24
				printf("W: %s:W\n",buffer); //each USART packet ends with 0x0a
    9202:	f104 0124 	add.w	r1, r4, #36	; 0x24
    9206:	4816      	ldr	r0, [pc, #88]	; (9260 <USART_1_input+0xac>)
    9208:	4b16      	ldr	r3, [pc, #88]	; (9264 <USART_1_input+0xb0>)
    920a:	4798      	blx	r3
				nread=0;
    920c:	6225      	str	r5, [r4, #32]
				if (buffer[4]==ROBOT_MOTORS_SEND_4BYTE_INST) {
    920e:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
    9212:	2b20      	cmp	r3, #32
    9214:	d1d8      	bne.n	91c8 <USART_1_input+0x14>
					MotorInst[0]=buffer[5];  //Motor Num<<4
    9216:	f894 2029 	ldrb.w	r2, [r4, #41]	; 0x29
    921a:	f88d 2008 	strb.w	r2, [sp, #8]
					MotorInst[1]=buffer[6];  //Dir+Strength
    921e:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
    9222:	f88d 2009 	strb.w	r2, [sp, #9]
					MotorInst[2]=buffer[7];  //duration low byte
    9226:	f894 202b 	ldrb.w	r2, [r4, #43]	; 0x2b
    922a:	f88d 200a 	strb.w	r2, [sp, #10]
					MotorInst[3]=buffer[8];  //duration high byte
    922e:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    9232:	f88d 300b 	strb.w	r3, [sp, #11]
					SendMotorInst(MotorInst);
    9236:	a802      	add	r0, sp, #8
    9238:	4b0b      	ldr	r3, [pc, #44]	; (9268 <USART_1_input+0xb4>)
    923a:	4798      	blx	r3
}
    923c:	e7c4      	b.n	91c8 <USART_1_input+0x14>
        CRITICAL_SECTION_LEAVE()
    923e:	a801      	add	r0, sp, #4
    9240:	4b05      	ldr	r3, [pc, #20]	; (9258 <USART_1_input+0xa4>)
    9242:	4798      	blx	r3
    9244:	e7c0      	b.n	91c8 <USART_1_input+0x14>
    9246:	bf00      	nop
    9248:	200081fc 	.word	0x200081fc
    924c:	000014e9 	.word	0x000014e9
    9250:	200080a4 	.word	0x200080a4
    9254:	00000de9 	.word	0x00000de9
    9258:	00000df7 	.word	0x00000df7
    925c:	00000e55 	.word	0x00000e55
    9260:	0000bea0 	.word	0x0000bea0
    9264:	00009815 	.word	0x00009815
    9268:	00009115 	.word	0x00009115

0000926c <udpserver_recv>:
	struct io_descriptor *io; //for ESP-01 UART1
	uint8_t buffer[256]; //temporary buffer
	
	//printf("received at %d, echoing to the same port\n",pcb->local_port);
	//dst_ip = &(pcb->remote_ip); // this is zero always
	if (p != NULL) {
    926c:	2a00      	cmp	r2, #0
    926e:	f000 8088 	beq.w	9382 <udpserver_recv+0x116>
{
    9272:	b5f0      	push	{r4, r5, r6, r7, lr}
    9274:	b0c3      	sub	sp, #268	; 0x10c
    9276:	4614      	mov	r4, r2
    9278:	461e      	mov	r6, r3
    927a:	460d      	mov	r5, r1
		//printf("UDP rcv %d bytes: ", (*p).len);
		printf("%d ", (*p).len);
    927c:	8951      	ldrh	r1, [r2, #10]
    927e:	4841      	ldr	r0, [pc, #260]	; (9384 <udpserver_recv+0x118>)
    9280:	4b41      	ldr	r3, [pc, #260]	; (9388 <udpserver_recv+0x11c>)
    9282:	4798      	blx	r3
		//    	printf("\n");
		//udp_sendto(pcb, p, IP_ADDR_BROADCAST, 1234); //dest port
				//		udp_sendto(pcb, p, &forward_ip, fwd_port); //dest port
				
		//Process any UDP instructions recognized
		if (pcb->local_port==UDP_PORT) {  //note that currently there could never be a different port because UDP server only listens to this port
    9284:	8a6a      	ldrh	r2, [r5, #18]
    9286:	f24d 1306 	movw	r3, #53510	; 0xd106
    928a:	429a      	cmp	r2, r3
    928c:	d004      	beq.n	9298 <udpserver_recv+0x2c>
				io_write(io, (uint8_t *)&InstData[5], InstLen-5);
			break;
			} //switch

		} //if (pcb->local_port==UDP_PORT) {
		pbuf_free(p);
    928e:	4620      	mov	r0, r4
    9290:	4b3e      	ldr	r3, [pc, #248]	; (938c <udpserver_recv+0x120>)
    9292:	4798      	blx	r3
	} //if (p != NULL) {
} //void udpserver_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
    9294:	b043      	add	sp, #268	; 0x10c
    9296:	bdf0      	pop	{r4, r5, r6, r7, pc}
			InstData=(uint8_t *)(*p).payload;  //shorthand to data
    9298:	6867      	ldr	r7, [r4, #4]
			switch(InstData[4]) //Robot Instruction
    929a:	793b      	ldrb	r3, [r7, #4]
    929c:	2b01      	cmp	r3, #1
    929e:	d03c      	beq.n	931a <udpserver_recv+0xae>
    92a0:	b1e3      	cbz	r3, 92dc <udpserver_recv+0x70>
    92a2:	2b20      	cmp	r3, #32
    92a4:	d05d      	beq.n	9362 <udpserver_recv+0xf6>
    92a6:	2b40      	cmp	r3, #64	; 0x40
    92a8:	d1f1      	bne.n	928e <udpserver_recv+0x22>
			InstLen=(*p).len;
    92aa:	8965      	ldrh	r5, [r4, #10]
				usart_async_get_io_descriptor(&USART_1, &io);
    92ac:	a940      	add	r1, sp, #256	; 0x100
    92ae:	4838      	ldr	r0, [pc, #224]	; (9390 <udpserver_recv+0x124>)
    92b0:	4b38      	ldr	r3, [pc, #224]	; (9394 <udpserver_recv+0x128>)
    92b2:	4798      	blx	r3
				memcpy(buffer,&InstData[5],InstLen-5);
    92b4:	3705      	adds	r7, #5
    92b6:	3d05      	subs	r5, #5
    92b8:	462a      	mov	r2, r5
    92ba:	4639      	mov	r1, r7
    92bc:	4668      	mov	r0, sp
    92be:	4b36      	ldr	r3, [pc, #216]	; (9398 <udpserver_recv+0x12c>)
    92c0:	4798      	blx	r3
				buffer[InstLen-5]=0; //terminate string
    92c2:	2300      	movs	r3, #0
    92c4:	f80d 3005 	strb.w	r3, [sp, r5]
				printf("%s",buffer);
    92c8:	4669      	mov	r1, sp
    92ca:	4834      	ldr	r0, [pc, #208]	; (939c <udpserver_recv+0x130>)
    92cc:	4b2e      	ldr	r3, [pc, #184]	; (9388 <udpserver_recv+0x11c>)
    92ce:	4798      	blx	r3
				io_write(io, (uint8_t *)&InstData[5], InstLen-5);
    92d0:	b2aa      	uxth	r2, r5
    92d2:	4639      	mov	r1, r7
    92d4:	9840      	ldr	r0, [sp, #256]	; 0x100
    92d6:	4b32      	ldr	r3, [pc, #200]	; (93a0 <udpserver_recv+0x134>)
    92d8:	4798      	blx	r3
			break;
    92da:	e7d8      	b.n	928e <udpserver_recv+0x22>
				retbuf = pbuf_alloc(PBUF_TRANSPORT, 10, PBUF_RAM);
    92dc:	2200      	movs	r2, #0
    92de:	210a      	movs	r1, #10
    92e0:	4610      	mov	r0, r2
    92e2:	4b30      	ldr	r3, [pc, #192]	; (93a4 <udpserver_recv+0x138>)
    92e4:	4798      	blx	r3
    92e6:	4607      	mov	r7, r0
				ReturnInst=retbuf->payload;
    92e8:	6843      	ldr	r3, [r0, #4]
				memcpy(ReturnInst,p->payload,5); //copy IP + inst byte to return instruction
    92ea:	6862      	ldr	r2, [r4, #4]
    92ec:	6811      	ldr	r1, [r2, #0]
    92ee:	6019      	str	r1, [r3, #0]
    92f0:	7912      	ldrb	r2, [r2, #4]
    92f2:	711a      	strb	r2, [r3, #4]
				ReturnInst[6]=0x12;
    92f4:	2212      	movs	r2, #18
    92f6:	719a      	strb	r2, [r3, #6]
				ReturnInst[7]=0x34;
    92f8:	2234      	movs	r2, #52	; 0x34
    92fa:	71da      	strb	r2, [r3, #7]
				ReturnInst[8]=0x56;
    92fc:	2256      	movs	r2, #86	; 0x56
    92fe:	721a      	strb	r2, [r3, #8]
				ReturnInst[9]=0x78;
    9300:	2278      	movs	r2, #120	; 0x78
    9302:	725a      	strb	r2, [r3, #9]
				udp_sendto(pcb, retbuf, addr, UDP_PORT); //dest port
    9304:	f24d 1306 	movw	r3, #53510	; 0xd106
    9308:	4632      	mov	r2, r6
    930a:	4601      	mov	r1, r0
    930c:	4628      	mov	r0, r5
    930e:	4d26      	ldr	r5, [pc, #152]	; (93a8 <udpserver_recv+0x13c>)
    9310:	47a8      	blx	r5
				pbuf_free(retbuf);
    9312:	4638      	mov	r0, r7
    9314:	4b1d      	ldr	r3, [pc, #116]	; (938c <udpserver_recv+0x120>)
    9316:	4798      	blx	r3
				break;
    9318:	e7b9      	b.n	928e <udpserver_recv+0x22>
				retbuf = pbuf_alloc(PBUF_TRANSPORT, 5+sizeof(LWIP_MACIF_hwaddr)+PCB_NAME_LENGTH, PBUF_RAM);
    931a:	2200      	movs	r2, #0
    931c:	2110      	movs	r1, #16
    931e:	4610      	mov	r0, r2
    9320:	4b20      	ldr	r3, [pc, #128]	; (93a4 <udpserver_recv+0x138>)
    9322:	4798      	blx	r3
    9324:	4607      	mov	r7, r0
				ReturnInst=retbuf->payload;
    9326:	6843      	ldr	r3, [r0, #4]
				memcpy(ReturnInst,p->payload,5); //copy IP + inst byte to return instruction
    9328:	6862      	ldr	r2, [r4, #4]
    932a:	6811      	ldr	r1, [r2, #0]
    932c:	6019      	str	r1, [r3, #0]
    932e:	7912      	ldrb	r2, [r2, #4]
    9330:	711a      	strb	r2, [r3, #4]
				memcpy(ReturnInst+ReturnInstLen,LWIP_MACIF_hwaddr,sizeof(LWIP_MACIF_hwaddr));//copy mac
    9332:	4a1e      	ldr	r2, [pc, #120]	; (93ac <udpserver_recv+0x140>)
    9334:	6811      	ldr	r1, [r2, #0]
    9336:	f8c3 1005 	str.w	r1, [r3, #5]
    933a:	8892      	ldrh	r2, [r2, #4]
    933c:	f8a3 2009 	strh.w	r2, [r3, #9]
				memcpy(ReturnInst+ReturnInstLen,PCB_Name,PCB_NAME_LENGTH);//copy name
    9340:	4a1b      	ldr	r2, [pc, #108]	; (93b0 <udpserver_recv+0x144>)
    9342:	6810      	ldr	r0, [r2, #0]
    9344:	f8c3 000b 	str.w	r0, [r3, #11]
    9348:	7912      	ldrb	r2, [r2, #4]
    934a:	73da      	strb	r2, [r3, #15]
				udp_sendto(pcb, retbuf, addr, UDP_PORT); //dest port
    934c:	f24d 1306 	movw	r3, #53510	; 0xd106
    9350:	4632      	mov	r2, r6
    9352:	4639      	mov	r1, r7
    9354:	4628      	mov	r0, r5
    9356:	4d14      	ldr	r5, [pc, #80]	; (93a8 <udpserver_recv+0x13c>)
    9358:	47a8      	blx	r5
				pbuf_free(retbuf);
    935a:	4638      	mov	r0, r7
    935c:	4b0b      	ldr	r3, [pc, #44]	; (938c <udpserver_recv+0x120>)
    935e:	4798      	blx	r3
			break;
    9360:	e795      	b.n	928e <udpserver_recv+0x22>
				MotorInst[0]=InstData[5];  //Motor Num<<4
    9362:	797b      	ldrb	r3, [r7, #5]
    9364:	f88d 3104 	strb.w	r3, [sp, #260]	; 0x104
				MotorInst[1]=InstData[6];  //Dir+Strength
    9368:	79bb      	ldrb	r3, [r7, #6]
    936a:	f88d 3105 	strb.w	r3, [sp, #261]	; 0x105
				MotorInst[2]=InstData[7];  //duration low byte
    936e:	79fb      	ldrb	r3, [r7, #7]
    9370:	f88d 3106 	strb.w	r3, [sp, #262]	; 0x106
				MotorInst[3]=InstData[8];  //duration high byte
    9374:	7a3b      	ldrb	r3, [r7, #8]
    9376:	f88d 3107 	strb.w	r3, [sp, #263]	; 0x107
				SendMotorInst(MotorInst);
    937a:	a841      	add	r0, sp, #260	; 0x104
    937c:	4b0d      	ldr	r3, [pc, #52]	; (93b4 <udpserver_recv+0x148>)
    937e:	4798      	blx	r3
			break; 
    9380:	e785      	b.n	928e <udpserver_recv+0x22>
    9382:	4770      	bx	lr
    9384:	0000beac 	.word	0x0000beac
    9388:	00009815 	.word	0x00009815
    938c:	000054c9 	.word	0x000054c9
    9390:	200081fc 	.word	0x200081fc
    9394:	000014e9 	.word	0x000014e9
    9398:	000097ef 	.word	0x000097ef
    939c:	0000beb8 	.word	0x0000beb8
    93a0:	00000e25 	.word	0x00000e25
    93a4:	00005531 	.word	0x00005531
    93a8:	00008601 	.word	0x00008601
    93ac:	20008284 	.word	0x20008284
    93b0:	0000beb0 	.word	0x0000beb0
    93b4:	00009115 	.word	0x00009115

000093b8 <InitializeMotors>:

int InitializeMotors(void) 
{
    93b8:	b410      	push	{r4}
	
	
	//set number of clocks in motor duty cycle
	//is 7 (but was 14), 7 timer2 interrupts make 1 full motor duty cycle
	NumClocksInMotorDutyCycle=ROBOT_MOTORS_DEFAULT_NUM_CLKS_IN_MOTOR_DUTY_CYCLE;
    93ba:	2214      	movs	r2, #20
    93bc:	4b14      	ldr	r3, [pc, #80]	; (9410 <InitializeMotors+0x58>)
    93be:	601a      	str	r2, [r3, #0]
	MotorDutyCycleClock=ROBOT_MOTORS_DEFAULT_MOTOR_DUTY_CYCLE_CLK;
    93c0:	2219      	movs	r2, #25
    93c2:	4b14      	ldr	r3, [pc, #80]	; (9414 <InitializeMotors+0x5c>)
    93c4:	601a      	str	r2, [r3, #0]
	
	
	NumMotors=1;
    93c6:	2001      	movs	r0, #1
    93c8:	4b13      	ldr	r3, [pc, #76]	; (9418 <InitializeMotors+0x60>)
    93ca:	7018      	strb	r0, [r3, #0]
	//Clear the robot status array
	memset(Motor,sizeof(MotorStatus)*NumMotors,0);

	//Motor[0].flags|=MOTOR_DRIVER_USES_PULSE_PIN;
	Motor[0].DirPin=GPIO(GPIO_PORTB, 13);
    93cc:	4b13      	ldr	r3, [pc, #76]	; (941c <InitializeMotors+0x64>)
    93ce:	222d      	movs	r2, #45	; 0x2d
    93d0:	605a      	str	r2, [r3, #4]
	Motor[0].PulsePin=GPIO(GPIO_PORTB, 12);
    93d2:	222c      	movs	r2, #44	; 0x2c
    93d4:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    93d6:	4b12      	ldr	r3, [pc, #72]	; (9420 <InitializeMotors+0x68>)
    93d8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    93dc:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    93e0:	4910      	ldr	r1, [pc, #64]	; (9424 <InitializeMotors+0x6c>)
    93e2:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
    93e6:	f04f 4140 	mov.w	r1, #3221225472	; 0xc0000000
    93ea:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    93ee:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    93f2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    93f6:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    93fa:	4c0b      	ldr	r4, [pc, #44]	; (9428 <InitializeMotors+0x70>)
    93fc:	f8c3 40a8 	str.w	r4, [r3, #168]	; 0xa8
    9400:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9404:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
	
//	Motor[1].DirPin=GPIO(GPIO_PORTB, 11); //13);
//	Motor[1].PulsePin=GPIO(GPIO_PORTB, 10);//12);

	return(1);
} //int InitializeMotors(void)
    9408:	f85d 4b04 	ldr.w	r4, [sp], #4
    940c:	4770      	bx	lr
    940e:	bf00      	nop
    9410:	200095cc 	.word	0x200095cc
    9414:	20009308 	.word	0x20009308
    9418:	20009300 	.word	0x20009300
    941c:	2000930c 	.word	0x2000930c
    9420:	41008000 	.word	0x41008000
    9424:	40002000 	.word	0x40002000
    9428:	40001000 	.word	0x40001000

0000942c <main>:


int main(void)
{
    942c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9430:	b0c5      	sub	sp, #276	; 0x114
	u8_t    mac[6];
	u8_t ReadBuffer[256];
	//struct usart_async_status iostat;  //currently needed for usart async

	/* Initializes MCU, drivers and middleware - tph - inits phy and uarts*/
	atmel_start_init();
    9432:	4b6d      	ldr	r3, [pc, #436]	; (95e8 <main+0x1bc>)
    9434:	4798      	blx	r3
	// Set pin direction to output
	//gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
	//gpio_set_pin_function(LED0, GPIO_PIN_FUNCTION_OFF);

//USART_ASYNC_TXC_CB
	usart_async_register_callback(&USART_1, USART_ASYNC_RXC_CB, usart1_receive_cb);
    9436:	4c6d      	ldr	r4, [pc, #436]	; (95ec <main+0x1c0>)
    9438:	4a6d      	ldr	r2, [pc, #436]	; (95f0 <main+0x1c4>)
    943a:	2100      	movs	r1, #0
    943c:	4620      	mov	r0, r4
    943e:	4b6d      	ldr	r3, [pc, #436]	; (95f4 <main+0x1c8>)
    9440:	4798      	blx	r3
	usart_async_enable(&USART_1);
    9442:	4620      	mov	r0, r4
    9444:	4b6c      	ldr	r3, [pc, #432]	; (95f8 <main+0x1cc>)
    9446:	4798      	blx	r3
	mac[0]=0x74;
    9448:	2374      	movs	r3, #116	; 0x74
    944a:	f88d 3004 	strb.w	r3, [sp, #4]
	mac[1]=0x27;
    944e:	2327      	movs	r3, #39	; 0x27
    9450:	f88d 3005 	strb.w	r3, [sp, #5]
	mac[2]=0xea;
    9454:	23ea      	movs	r3, #234	; 0xea
    9456:	f88d 3006 	strb.w	r3, [sp, #6]
	mac[3]=0xda;
    945a:	23da      	movs	r3, #218	; 0xda
    945c:	f88d 3007 	strb.w	r3, [sp, #7]
	mac[4]=0x89;
    9460:	2389      	movs	r3, #137	; 0x89
    9462:	f88d 3008 	strb.w	r3, [sp, #8]
	mac[5]=0x85;
    9466:	2385      	movs	r3, #133	; 0x85
    9468:	f88d 3009 	strb.w	r3, [sp, #9]


	/* Read MacAddress from EEPROM */  //tph: currently just adding a valid public MAC address
	read_macaddress(mac);

	systick_enable();
    946c:	4b63      	ldr	r3, [pc, #396]	; (95fc <main+0x1d0>)
    946e:	4798      	blx	r3

	//MACIF_example();
	
	ETHERNET_PHY_0_example();  //restarts autonegotiation
    9470:	4b63      	ldr	r3, [pc, #396]	; (9600 <main+0x1d4>)
    9472:	4798      	blx	r3

	//init usart
	usart_sync_get_io_descriptor(&USART_0, &io);
    9474:	4c63      	ldr	r4, [pc, #396]	; (9604 <main+0x1d8>)
    9476:	a943      	add	r1, sp, #268	; 0x10c
    9478:	4620      	mov	r0, r4
    947a:	4b63      	ldr	r3, [pc, #396]	; (9608 <main+0x1dc>)
    947c:	4798      	blx	r3
	usart_sync_enable(&USART_0);
    947e:	4620      	mov	r0, r4
    9480:	4b62      	ldr	r3, [pc, #392]	; (960c <main+0x1e0>)
    9482:	4798      	blx	r3
	//usart_async_get_io_descriptor(&USART_0, &io);
	//usart_async_enable(&USART_0);
	count=0;
	sprintf((char *)OutStr,"**************************\n");
    9484:	4e62      	ldr	r6, [pc, #392]	; (9610 <main+0x1e4>)
    9486:	ad03      	add	r5, sp, #12
    9488:	4634      	mov	r4, r6
    948a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    948c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    948e:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
    9492:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	io_write(io,OutStr,strlen(OutStr));
    9496:	a803      	add	r0, sp, #12
    9498:	f8df 9204 	ldr.w	r9, [pc, #516]	; 96a0 <main+0x274>
    949c:	47c8      	blx	r9
    949e:	b282      	uxth	r2, r0
    94a0:	a903      	add	r1, sp, #12
    94a2:	9843      	ldr	r0, [sp, #268]	; 0x10c
    94a4:	f8df 81fc 	ldr.w	r8, [pc, #508]	; 96a4 <main+0x278>
    94a8:	47c0      	blx	r8
	
	//while (usart_async_get_status(&USART_0, &iostat)==ERR_BUSY);
	//sprintf((char *)OutStr,"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\n");
	//io_write(io,OutStr,strlen(OutStr));
	sprintf((char *)OutStr,"EthMotorsArm_DRV8800_rev02\n");
    94aa:	ad03      	add	r5, sp, #12
    94ac:	4f59      	ldr	r7, [pc, #356]	; (9614 <main+0x1e8>)
    94ae:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    94b0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    94b2:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    94b6:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	io_write(io,OutStr,strlen(OutStr));
    94ba:	a803      	add	r0, sp, #12
    94bc:	47c8      	blx	r9
    94be:	b282      	uxth	r2, r0
    94c0:	a903      	add	r1, sp, #12
    94c2:	9843      	ldr	r0, [sp, #268]	; 0x10c
    94c4:	47c0      	blx	r8
	//while (usart_async_get_status(&USART_0, &iostat)==ERR_BUSY);

	//sprintf((char *)OutStr,"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\n");
	//io_write(io,OutStr,strlen(OutStr));
	sprintf((char *)OutStr,"**************************\n");
    94c6:	ad03      	add	r5, sp, #12
    94c8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    94ca:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    94cc:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
    94d0:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	io_write(io,OutStr,strlen(OutStr));
    94d4:	a803      	add	r0, sp, #12
    94d6:	47c8      	blx	r9
    94d8:	b282      	uxth	r2, r0
    94da:	a903      	add	r1, sp, #12
    94dc:	9843      	ldr	r0, [sp, #268]	; 0x10c
    94de:	47c0      	blx	r8
	//sprintf((char *)OutStr,"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\n");
	//io_write(io,OutStr,strlen(OutStr));



	printf("\r\nHello ATMEL World!\r\n");
    94e0:	484d      	ldr	r0, [pc, #308]	; (9618 <main+0x1ec>)
    94e2:	4b4e      	ldr	r3, [pc, #312]	; (961c <main+0x1f0>)
    94e4:	4798      	blx	r3
	//fflush(stdio_io);

	//below does not work for printf because printf calls _puts_r which must send one char at a time 
	//while (usart_async_get_status(&USART_0, &iostat)==ERR_BUSY); 

	mac_async_register_callback(&ETHERNET_MAC_0, MAC_ASYNC_RECEIVE_CB, (FUNC_PTR)mac_receive_cb);
    94e6:	4d4e      	ldr	r5, [pc, #312]	; (9620 <main+0x1f4>)
    94e8:	4a4e      	ldr	r2, [pc, #312]	; (9624 <main+0x1f8>)
    94ea:	2100      	movs	r1, #0
    94ec:	4628      	mov	r0, r5
    94ee:	4c4e      	ldr	r4, [pc, #312]	; (9628 <main+0x1fc>)
    94f0:	47a0      	blx	r4
	mac_async_register_callback(&ETHERNET_MAC_0, MAC_ASYNC_TRANSMIT_CB, (FUNC_PTR)mac_transmit_cb);
    94f2:	4a4e      	ldr	r2, [pc, #312]	; (962c <main+0x200>)
    94f4:	2101      	movs	r1, #1
    94f6:	4628      	mov	r0, r5
    94f8:	47a0      	blx	r4

	eth_ipstack_init();
    94fa:	4b4d      	ldr	r3, [pc, #308]	; (9630 <main+0x204>)
    94fc:	4798      	blx	r3
	do {
		ret = ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_up);
    94fe:	4f4d      	ldr	r7, [pc, #308]	; (9634 <main+0x208>)
    9500:	f507 7692 	add.w	r6, r7, #292	; 0x124
    9504:	4d4c      	ldr	r5, [pc, #304]	; (9638 <main+0x20c>)
    9506:	4c4d      	ldr	r4, [pc, #308]	; (963c <main+0x210>)
    9508:	4631      	mov	r1, r6
    950a:	4628      	mov	r0, r5
    950c:	47a0      	blx	r4
		if (ret == ERR_NONE && link_up) {
    950e:	2800      	cmp	r0, #0
    9510:	d1fa      	bne.n	9508 <main+0xdc>
    9512:	f897 3124 	ldrb.w	r3, [r7, #292]	; 0x124
    9516:	2b00      	cmp	r3, #0
    9518:	d0f6      	beq.n	9508 <main+0xdc>
			break;
		}
	} while (true);
	printf("Ethernet Connection established\n");
    951a:	4849      	ldr	r0, [pc, #292]	; (9640 <main+0x214>)
    951c:	4d3f      	ldr	r5, [pc, #252]	; (961c <main+0x1f0>)
    951e:	47a8      	blx	r5
	LWIP_MACIF_init(mac);  //tph: add LWIP callback for recvd input: ethernet_input()
    9520:	a801      	add	r0, sp, #4
    9522:	4b48      	ldr	r3, [pc, #288]	; (9644 <main+0x218>)
    9524:	4798      	blx	r3

	//make this the default interface
	netif_set_default(&LWIP_MACIF_desc);
    9526:	4c48      	ldr	r4, [pc, #288]	; (9648 <main+0x21c>)
    9528:	4620      	mov	r0, r4
    952a:	4b48      	ldr	r3, [pc, #288]	; (964c <main+0x220>)
    952c:	4798      	blx	r3
	
	// Set callback function for netif status change 
	netif_set_status_callback(&LWIP_MACIF_desc, status_callback);
    952e:	4948      	ldr	r1, [pc, #288]	; (9650 <main+0x224>)
    9530:	4620      	mov	r0, r4
    9532:	4b48      	ldr	r3, [pc, #288]	; (9654 <main+0x228>)
    9534:	4798      	blx	r3

	//Set callback function for link status change
	netif_set_link_callback(&LWIP_MACIF_desc, link_callback);
    9536:	4948      	ldr	r1, [pc, #288]	; (9658 <main+0x22c>)
    9538:	4620      	mov	r0, r4
    953a:	4b48      	ldr	r3, [pc, #288]	; (965c <main+0x230>)
    953c:	4798      	blx	r3

		
	mac_async_enable(&ETHERNET_MAC_0);
    953e:	4838      	ldr	r0, [pc, #224]	; (9620 <main+0x1f4>)
    9540:	4b47      	ldr	r3, [pc, #284]	; (9660 <main+0x234>)
    9542:	4798      	blx	r3


//#if 0 
	//udpecho_init(); //START UDP ECHO THREAD - requires netconn 
	//start_udp();
	udpserver_pcb = udp_new();  //create udp server
    9544:	4b47      	ldr	r3, [pc, #284]	; (9664 <main+0x238>)
    9546:	4798      	blx	r3
    9548:	4e47      	ldr	r6, [pc, #284]	; (9668 <main+0x23c>)
    954a:	6030      	str	r0, [r6, #0]
	//IP4_ADDR(&forward_ip, 192, 168,   2, 254);
//	udp_bind(udpserver_pcb, IP_ADDR_ANY, UDP_PORT);   //port UDP_PORT 
	udp_bind(udpserver_pcb, &LWIP_MACIF_desc.ip_addr.addr, UDP_PORT);   //port UDP_PORT 
    954c:	f24d 1206 	movw	r2, #53510	; 0xd106
    9550:	1d21      	adds	r1, r4, #4
    9552:	4b46      	ldr	r3, [pc, #280]	; (966c <main+0x240>)
    9554:	4798      	blx	r3
	udp_recv(udpserver_pcb, udpserver_recv, NULL);  //set udpserver callback function
    9556:	2200      	movs	r2, #0
    9558:	4945      	ldr	r1, [pc, #276]	; (9670 <main+0x244>)
    955a:	6830      	ldr	r0, [r6, #0]
    955c:	4b45      	ldr	r3, [pc, #276]	; (9674 <main+0x248>)
    955e:	4798      	blx	r3


	//bring up the network interface - ned to do here so above interrupts are enabled
	#ifdef LWIP_DHCP
	/* DHCP mode. */
	if (ERR_OK != dhcp_start(&LWIP_MACIF_desc)) {
    9560:	4620      	mov	r0, r4
    9562:	4b45      	ldr	r3, [pc, #276]	; (9678 <main+0x24c>)
    9564:	4798      	blx	r3
		LWIP_ASSERT("ERR_OK != dhcp_start", 0);
	}
	printf("DHCP Started\r\n");
    9566:	4845      	ldr	r0, [pc, #276]	; (967c <main+0x250>)
    9568:	47a8      	blx	r5
	/* Static mode. */
	netif_set_up(&LWIP_MACIF_desc);
	printf("Static IP Address Assigned\r\n");
	#endif

	InitializeMotors(); //set initial settings of all motors
    956a:	4b45      	ldr	r3, [pc, #276]	; (9680 <main+0x254>)
    956c:	4798      	blx	r3
	//currently motor timer stop DHCP from working
	MotorTimer_Initialize();  //start timer for motor pwm
    956e:	4b45      	ldr	r3, [pc, #276]	; (9684 <main+0x258>)
    9570:	4798      	blx	r3
			StartDHCP=0;
			dhcp_start(&LWIP_MACIF_desc); //tph start dhcp
		}
*/

		if (gmac_recv_flag) {
    9572:	4c30      	ldr	r4, [pc, #192]	; (9634 <main+0x208>)
			//printf("gmac_recd");
			//sprintf((char *)OutStr,"recvd2\n");
			//io_write(io,OutStr,strlen(OutStr));
			
			gmac_recv_flag = false;
			ethernetif_mac_input(&LWIP_MACIF_desc);
    9574:	4d34      	ldr	r5, [pc, #208]	; (9648 <main+0x21c>)
    9576:	4e44      	ldr	r6, [pc, #272]	; (9688 <main+0x25c>)
	printf("IP_ADDR    : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.ip_addr), tmp_buff, 16));
    9578:	f504 7894 	add.w	r8, r4, #296	; 0x128
    957c:	1d2f      	adds	r7, r5, #4
	printf("NET_MASK   : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.netmask), tmp_buff, 16));
    957e:	f107 0904 	add.w	r9, r7, #4
    9582:	e006      	b.n	9592 <main+0x166>
			gmac_recv_flag = false;
    9584:	2300      	movs	r3, #0
    9586:	7023      	strb	r3, [r4, #0]
			ethernetif_mac_input(&LWIP_MACIF_desc);
    9588:	4628      	mov	r0, r5
    958a:	47b0      	blx	r6
    958c:	e004      	b.n	9598 <main+0x16c>
	tsr=hri_gmac_read_TSR_reg(GMAC);  //bit 5 tx complete
#endif	
	//could test loop back send and receive: set LBL bit in NCR


	USART_1_input();  //check for usart1 input
    958e:	4b3f      	ldr	r3, [pc, #252]	; (968c <main+0x260>)
    9590:	4798      	blx	r3
		if (gmac_recv_flag) {
    9592:	7823      	ldrb	r3, [r4, #0]
    9594:	2b00      	cmp	r3, #0
    9596:	d1f5      	bne.n	9584 <main+0x158>
		sys_check_timeouts();
    9598:	4b3d      	ldr	r3, [pc, #244]	; (9690 <main+0x264>)
    959a:	4798      	blx	r3
		if (link_up && LWIP_MACIF_desc.ip_addr.addr) {
    959c:	f894 3124 	ldrb.w	r3, [r4, #292]	; 0x124
    95a0:	2b00      	cmp	r3, #0
    95a2:	d0f4      	beq.n	958e <main+0x162>
    95a4:	686b      	ldr	r3, [r5, #4]
    95a6:	2b00      	cmp	r3, #0
    95a8:	d0f1      	beq.n	958e <main+0x162>
			link_up = false;
    95aa:	2300      	movs	r3, #0
    95ac:	f884 3124 	strb.w	r3, [r4, #292]	; 0x124
	printf("IP_ADDR    : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.ip_addr), tmp_buff, 16));
    95b0:	2210      	movs	r2, #16
    95b2:	4641      	mov	r1, r8
    95b4:	4638      	mov	r0, r7
    95b6:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 96a8 <main+0x27c>
    95ba:	47d8      	blx	fp
    95bc:	4601      	mov	r1, r0
    95be:	4835      	ldr	r0, [pc, #212]	; (9694 <main+0x268>)
    95c0:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 96ac <main+0x280>
    95c4:	47d0      	blx	sl
	printf("NET_MASK   : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.netmask), tmp_buff, 16));
    95c6:	2210      	movs	r2, #16
    95c8:	4641      	mov	r1, r8
    95ca:	4648      	mov	r0, r9
    95cc:	47d8      	blx	fp
    95ce:	4601      	mov	r1, r0
    95d0:	4831      	ldr	r0, [pc, #196]	; (9698 <main+0x26c>)
    95d2:	47d0      	blx	sl
	printf("GATEWAY_IP : %s\r\n", ipaddr_ntoa_r((const ip_addr_t *)&(LWIP_MACIF_desc.gw), tmp_buff, 16));
    95d4:	2210      	movs	r2, #16
    95d6:	4641      	mov	r1, r8
    95d8:	f107 0008 	add.w	r0, r7, #8
    95dc:	47d8      	blx	fp
    95de:	4601      	mov	r1, r0
    95e0:	482e      	ldr	r0, [pc, #184]	; (969c <main+0x270>)
    95e2:	47d0      	blx	sl
    95e4:	e7d3      	b.n	958e <main+0x162>
    95e6:	bf00      	nop
    95e8:	000002d1 	.word	0x000002d1
    95ec:	200081fc 	.word	0x200081fc
    95f0:	000090c1 	.word	0x000090c1
    95f4:	00001511 	.word	0x00001511
    95f8:	000014bd 	.word	0x000014bd
    95fc:	0000906d 	.word	0x0000906d
    9600:	00000ccd 	.word	0x00000ccd
    9604:	200081f0 	.word	0x200081f0
    9608:	000016cd 	.word	0x000016cd
    960c:	000016a1 	.word	0x000016a1
    9610:	0000bebc 	.word	0x0000bebc
    9614:	0000bed8 	.word	0x0000bed8
    9618:	0000bef4 	.word	0x0000bef4
    961c:	000098fd 	.word	0x000098fd
    9620:	2000824c 	.word	0x2000824c
    9624:	00008f9d 	.word	0x00008f9d
    9628:	00000f85 	.word	0x00000f85
    962c:	00008ea1 	.word	0x00008ea1
    9630:	00000ddd 	.word	0x00000ddd
    9634:	200080a4 	.word	0x200080a4
    9638:	200081e8 	.word	0x200081e8
    963c:	00000c51 	.word	0x00000c51
    9640:	0000bf0c 	.word	0x0000bf0c
    9644:	00000d91 	.word	0x00000d91
    9648:	2000828c 	.word	0x2000828c
    964c:	00005319 	.word	0x00005319
    9650:	00008fc5 	.word	0x00008fc5
    9654:	00005395 	.word	0x00005395
    9658:	00009009 	.word	0x00009009
    965c:	0000539b 	.word	0x0000539b
    9660:	00000ec9 	.word	0x00000ec9
    9664:	000086d9 	.word	0x000086d9
    9668:	20009304 	.word	0x20009304
    966c:	00008415 	.word	0x00008415
    9670:	0000926d 	.word	0x0000926d
    9674:	00008695 	.word	0x00008695
    9678:	00003e89 	.word	0x00003e89
    967c:	0000bf2c 	.word	0x0000bf2c
    9680:	000093b9 	.word	0x000093b9
    9684:	000090e1 	.word	0x000090e1
    9688:	0000265d 	.word	0x0000265d
    968c:	000091b5 	.word	0x000091b5
    9690:	000081b5 	.word	0x000081b5
    9694:	0000bf3c 	.word	0x0000bf3c
    9698:	0000bf50 	.word	0x0000bf50
    969c:	0000bf64 	.word	0x0000bf64
    96a0:	00009a79 	.word	0x00009a79
    96a4:	00000e25 	.word	0x00000e25
    96a8:	00004779 	.word	0x00004779
    96ac:	00009815 	.word	0x00009815

000096b0 <_read>:

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
	int n = 0;

	if (file != 0) {
    96b0:	b940      	cbnz	r0, 96c4 <_read+0x14>
{
    96b2:	b508      	push	{r3, lr}
    96b4:	460b      	mov	r3, r1
    96b6:	4611      	mov	r1, r2
    96b8:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
    96ba:	4b04      	ldr	r3, [pc, #16]	; (96cc <_read+0x1c>)
    96bc:	4798      	blx	r3
    96be:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
    96c2:	bd08      	pop	{r3, pc}
		return -1;
    96c4:	f04f 30ff 	mov.w	r0, #4294967295
    96c8:	4770      	bx	lr
    96ca:	bf00      	nop
    96cc:	00009721 	.word	0x00009721

000096d0 <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    96d0:	3801      	subs	r0, #1
    96d2:	2802      	cmp	r0, #2
    96d4:	d808      	bhi.n	96e8 <_write+0x18>
{
    96d6:	b508      	push	{r3, lr}
    96d8:	460b      	mov	r3, r1
    96da:	4611      	mov	r1, r2
    96dc:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    96de:	4b04      	ldr	r3, [pc, #16]	; (96f0 <_write+0x20>)
    96e0:	4798      	blx	r3
    96e2:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
    96e6:	bd08      	pop	{r3, pc}
		return -1;
    96e8:	f04f 30ff 	mov.w	r0, #4294967295
    96ec:	4770      	bx	lr
    96ee:	bf00      	nop
    96f0:	00009745 	.word	0x00009745

000096f4 <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
    96f4:	b570      	push	{r4, r5, r6, lr}
    96f6:	4606      	mov	r6, r0
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
    96f8:	4d06      	ldr	r5, [pc, #24]	; (9714 <stdio_io_init+0x20>)
    96fa:	682b      	ldr	r3, [r5, #0]
    96fc:	2100      	movs	r1, #0
    96fe:	6898      	ldr	r0, [r3, #8]
    9700:	4c05      	ldr	r4, [pc, #20]	; (9718 <stdio_io_init+0x24>)
    9702:	47a0      	blx	r4
	setbuf(stdin, NULL);
    9704:	682b      	ldr	r3, [r5, #0]
    9706:	2100      	movs	r1, #0
    9708:	6858      	ldr	r0, [r3, #4]
    970a:	47a0      	blx	r4
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
    970c:	4b03      	ldr	r3, [pc, #12]	; (971c <stdio_io_init+0x28>)
    970e:	601e      	str	r6, [r3, #0]
    9710:	bd70      	pop	{r4, r5, r6, pc}
    9712:	bf00      	nop
    9714:	20000010 	.word	0x20000010
    9718:	0000990d 	.word	0x0000990d
    971c:	200081dc 	.word	0x200081dc

00009720 <stdio_io_read>:
{
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
    9720:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
    9722:	4b06      	ldr	r3, [pc, #24]	; (973c <stdio_io_read+0x1c>)
    9724:	681b      	ldr	r3, [r3, #0]
    9726:	b133      	cbz	r3, 9736 <stdio_io_read+0x16>
    9728:	460a      	mov	r2, r1
    972a:	4601      	mov	r1, r0
		return 0;
	}
	return io_read(stdio_io, buf, len);
    972c:	b292      	uxth	r2, r2
    972e:	4618      	mov	r0, r3
    9730:	4b03      	ldr	r3, [pc, #12]	; (9740 <stdio_io_read+0x20>)
    9732:	4798      	blx	r3
    9734:	bd08      	pop	{r3, pc}
		return 0;
    9736:	2000      	movs	r0, #0
}
    9738:	bd08      	pop	{r3, pc}
    973a:	bf00      	nop
    973c:	200081dc 	.word	0x200081dc
    9740:	00000e55 	.word	0x00000e55

00009744 <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
    9744:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
    9746:	4b06      	ldr	r3, [pc, #24]	; (9760 <stdio_io_write+0x1c>)
    9748:	681b      	ldr	r3, [r3, #0]
    974a:	b133      	cbz	r3, 975a <stdio_io_write+0x16>
    974c:	460a      	mov	r2, r1
    974e:	4601      	mov	r1, r0
		return 0;
	}
	return io_write(stdio_io, buf, len);
    9750:	b292      	uxth	r2, r2
    9752:	4618      	mov	r0, r3
    9754:	4b03      	ldr	r3, [pc, #12]	; (9764 <stdio_io_write+0x20>)
    9756:	4798      	blx	r3
    9758:	bd08      	pop	{r3, pc}
		return 0;
    975a:	2000      	movs	r0, #0
}
    975c:	bd08      	pop	{r3, pc}
    975e:	bf00      	nop
    9760:	200081dc 	.word	0x200081dc
    9764:	00000e25 	.word	0x00000e25

00009768 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
    9768:	b510      	push	{r4, lr}

	usart_sync_enable(&USART_0);
    976a:	4c04      	ldr	r4, [pc, #16]	; (977c <stdio_redirect_init+0x14>)
    976c:	4620      	mov	r0, r4
    976e:	4b04      	ldr	r3, [pc, #16]	; (9780 <stdio_redirect_init+0x18>)
    9770:	4798      	blx	r3
	stdio_io_init(&USART_0.io);
    9772:	4620      	mov	r0, r4
    9774:	4b03      	ldr	r3, [pc, #12]	; (9784 <stdio_redirect_init+0x1c>)
    9776:	4798      	blx	r3
    9778:	bd10      	pop	{r4, pc}
    977a:	bf00      	nop
    977c:	200081f0 	.word	0x200081f0
    9780:	000016a1 	.word	0x000016a1
    9784:	000096f5 	.word	0x000096f5

00009788 <__libc_init_array>:
    9788:	b570      	push	{r4, r5, r6, lr}
    978a:	4e0d      	ldr	r6, [pc, #52]	; (97c0 <__libc_init_array+0x38>)
    978c:	4c0d      	ldr	r4, [pc, #52]	; (97c4 <__libc_init_array+0x3c>)
    978e:	1ba4      	subs	r4, r4, r6
    9790:	10a4      	asrs	r4, r4, #2
    9792:	2500      	movs	r5, #0
    9794:	42a5      	cmp	r5, r4
    9796:	d109      	bne.n	97ac <__libc_init_array+0x24>
    9798:	4e0b      	ldr	r6, [pc, #44]	; (97c8 <__libc_init_array+0x40>)
    979a:	4c0c      	ldr	r4, [pc, #48]	; (97cc <__libc_init_array+0x44>)
    979c:	f002 fc38 	bl	c010 <_init>
    97a0:	1ba4      	subs	r4, r4, r6
    97a2:	10a4      	asrs	r4, r4, #2
    97a4:	2500      	movs	r5, #0
    97a6:	42a5      	cmp	r5, r4
    97a8:	d105      	bne.n	97b6 <__libc_init_array+0x2e>
    97aa:	bd70      	pop	{r4, r5, r6, pc}
    97ac:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    97b0:	4798      	blx	r3
    97b2:	3501      	adds	r5, #1
    97b4:	e7ee      	b.n	9794 <__libc_init_array+0xc>
    97b6:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    97ba:	4798      	blx	r3
    97bc:	3501      	adds	r5, #1
    97be:	e7f2      	b.n	97a6 <__libc_init_array+0x1e>
    97c0:	0000c01c 	.word	0x0000c01c
    97c4:	0000c01c 	.word	0x0000c01c
    97c8:	0000c01c 	.word	0x0000c01c
    97cc:	0000c020 	.word	0x0000c020

000097d0 <memcmp>:
    97d0:	b510      	push	{r4, lr}
    97d2:	3901      	subs	r1, #1
    97d4:	4402      	add	r2, r0
    97d6:	4290      	cmp	r0, r2
    97d8:	d101      	bne.n	97de <memcmp+0xe>
    97da:	2000      	movs	r0, #0
    97dc:	bd10      	pop	{r4, pc}
    97de:	f810 3b01 	ldrb.w	r3, [r0], #1
    97e2:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    97e6:	42a3      	cmp	r3, r4
    97e8:	d0f5      	beq.n	97d6 <memcmp+0x6>
    97ea:	1b18      	subs	r0, r3, r4
    97ec:	bd10      	pop	{r4, pc}

000097ee <memcpy>:
    97ee:	b510      	push	{r4, lr}
    97f0:	1e43      	subs	r3, r0, #1
    97f2:	440a      	add	r2, r1
    97f4:	4291      	cmp	r1, r2
    97f6:	d100      	bne.n	97fa <memcpy+0xc>
    97f8:	bd10      	pop	{r4, pc}
    97fa:	f811 4b01 	ldrb.w	r4, [r1], #1
    97fe:	f803 4f01 	strb.w	r4, [r3, #1]!
    9802:	e7f7      	b.n	97f4 <memcpy+0x6>

00009804 <memset>:
    9804:	4402      	add	r2, r0
    9806:	4603      	mov	r3, r0
    9808:	4293      	cmp	r3, r2
    980a:	d100      	bne.n	980e <memset+0xa>
    980c:	4770      	bx	lr
    980e:	f803 1b01 	strb.w	r1, [r3], #1
    9812:	e7f9      	b.n	9808 <memset+0x4>

00009814 <iprintf>:
    9814:	b40f      	push	{r0, r1, r2, r3}
    9816:	4b0a      	ldr	r3, [pc, #40]	; (9840 <iprintf+0x2c>)
    9818:	b513      	push	{r0, r1, r4, lr}
    981a:	681c      	ldr	r4, [r3, #0]
    981c:	b124      	cbz	r4, 9828 <iprintf+0x14>
    981e:	69a3      	ldr	r3, [r4, #24]
    9820:	b913      	cbnz	r3, 9828 <iprintf+0x14>
    9822:	4620      	mov	r0, r4
    9824:	f000 fae2 	bl	9dec <__sinit>
    9828:	ab05      	add	r3, sp, #20
    982a:	9a04      	ldr	r2, [sp, #16]
    982c:	68a1      	ldr	r1, [r4, #8]
    982e:	9301      	str	r3, [sp, #4]
    9830:	4620      	mov	r0, r4
    9832:	f000 fca5 	bl	a180 <_vfiprintf_r>
    9836:	b002      	add	sp, #8
    9838:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    983c:	b004      	add	sp, #16
    983e:	4770      	bx	lr
    9840:	20000010 	.word	0x20000010

00009844 <_puts_r>:
    9844:	b570      	push	{r4, r5, r6, lr}
    9846:	460e      	mov	r6, r1
    9848:	4605      	mov	r5, r0
    984a:	b118      	cbz	r0, 9854 <_puts_r+0x10>
    984c:	6983      	ldr	r3, [r0, #24]
    984e:	b90b      	cbnz	r3, 9854 <_puts_r+0x10>
    9850:	f000 facc 	bl	9dec <__sinit>
    9854:	69ab      	ldr	r3, [r5, #24]
    9856:	68ac      	ldr	r4, [r5, #8]
    9858:	b913      	cbnz	r3, 9860 <_puts_r+0x1c>
    985a:	4628      	mov	r0, r5
    985c:	f000 fac6 	bl	9dec <__sinit>
    9860:	4b23      	ldr	r3, [pc, #140]	; (98f0 <_puts_r+0xac>)
    9862:	429c      	cmp	r4, r3
    9864:	d117      	bne.n	9896 <_puts_r+0x52>
    9866:	686c      	ldr	r4, [r5, #4]
    9868:	89a3      	ldrh	r3, [r4, #12]
    986a:	071b      	lsls	r3, r3, #28
    986c:	d51d      	bpl.n	98aa <_puts_r+0x66>
    986e:	6923      	ldr	r3, [r4, #16]
    9870:	b1db      	cbz	r3, 98aa <_puts_r+0x66>
    9872:	3e01      	subs	r6, #1
    9874:	68a3      	ldr	r3, [r4, #8]
    9876:	f816 1f01 	ldrb.w	r1, [r6, #1]!
    987a:	3b01      	subs	r3, #1
    987c:	60a3      	str	r3, [r4, #8]
    987e:	b9e9      	cbnz	r1, 98bc <_puts_r+0x78>
    9880:	2b00      	cmp	r3, #0
    9882:	da2e      	bge.n	98e2 <_puts_r+0x9e>
    9884:	4622      	mov	r2, r4
    9886:	210a      	movs	r1, #10
    9888:	4628      	mov	r0, r5
    988a:	f000 f8fd 	bl	9a88 <__swbuf_r>
    988e:	3001      	adds	r0, #1
    9890:	d011      	beq.n	98b6 <_puts_r+0x72>
    9892:	200a      	movs	r0, #10
    9894:	bd70      	pop	{r4, r5, r6, pc}
    9896:	4b17      	ldr	r3, [pc, #92]	; (98f4 <_puts_r+0xb0>)
    9898:	429c      	cmp	r4, r3
    989a:	d101      	bne.n	98a0 <_puts_r+0x5c>
    989c:	68ac      	ldr	r4, [r5, #8]
    989e:	e7e3      	b.n	9868 <_puts_r+0x24>
    98a0:	4b15      	ldr	r3, [pc, #84]	; (98f8 <_puts_r+0xb4>)
    98a2:	429c      	cmp	r4, r3
    98a4:	bf08      	it	eq
    98a6:	68ec      	ldreq	r4, [r5, #12]
    98a8:	e7de      	b.n	9868 <_puts_r+0x24>
    98aa:	4621      	mov	r1, r4
    98ac:	4628      	mov	r0, r5
    98ae:	f000 f93d 	bl	9b2c <__swsetup_r>
    98b2:	2800      	cmp	r0, #0
    98b4:	d0dd      	beq.n	9872 <_puts_r+0x2e>
    98b6:	f04f 30ff 	mov.w	r0, #4294967295
    98ba:	bd70      	pop	{r4, r5, r6, pc}
    98bc:	2b00      	cmp	r3, #0
    98be:	da04      	bge.n	98ca <_puts_r+0x86>
    98c0:	69a2      	ldr	r2, [r4, #24]
    98c2:	4293      	cmp	r3, r2
    98c4:	db06      	blt.n	98d4 <_puts_r+0x90>
    98c6:	290a      	cmp	r1, #10
    98c8:	d004      	beq.n	98d4 <_puts_r+0x90>
    98ca:	6823      	ldr	r3, [r4, #0]
    98cc:	1c5a      	adds	r2, r3, #1
    98ce:	6022      	str	r2, [r4, #0]
    98d0:	7019      	strb	r1, [r3, #0]
    98d2:	e7cf      	b.n	9874 <_puts_r+0x30>
    98d4:	4622      	mov	r2, r4
    98d6:	4628      	mov	r0, r5
    98d8:	f000 f8d6 	bl	9a88 <__swbuf_r>
    98dc:	3001      	adds	r0, #1
    98de:	d1c9      	bne.n	9874 <_puts_r+0x30>
    98e0:	e7e9      	b.n	98b6 <_puts_r+0x72>
    98e2:	6823      	ldr	r3, [r4, #0]
    98e4:	200a      	movs	r0, #10
    98e6:	1c5a      	adds	r2, r3, #1
    98e8:	6022      	str	r2, [r4, #0]
    98ea:	7018      	strb	r0, [r3, #0]
    98ec:	bd70      	pop	{r4, r5, r6, pc}
    98ee:	bf00      	nop
    98f0:	0000bf9c 	.word	0x0000bf9c
    98f4:	0000bfbc 	.word	0x0000bfbc
    98f8:	0000bf7c 	.word	0x0000bf7c

000098fc <puts>:
    98fc:	4b02      	ldr	r3, [pc, #8]	; (9908 <puts+0xc>)
    98fe:	4601      	mov	r1, r0
    9900:	6818      	ldr	r0, [r3, #0]
    9902:	f7ff bf9f 	b.w	9844 <_puts_r>
    9906:	bf00      	nop
    9908:	20000010 	.word	0x20000010

0000990c <setbuf>:
    990c:	2900      	cmp	r1, #0
    990e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    9912:	bf0c      	ite	eq
    9914:	2202      	moveq	r2, #2
    9916:	2200      	movne	r2, #0
    9918:	f000 b800 	b.w	991c <setvbuf>

0000991c <setvbuf>:
    991c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    9920:	461d      	mov	r5, r3
    9922:	4b51      	ldr	r3, [pc, #324]	; (9a68 <setvbuf+0x14c>)
    9924:	681e      	ldr	r6, [r3, #0]
    9926:	4604      	mov	r4, r0
    9928:	460f      	mov	r7, r1
    992a:	4690      	mov	r8, r2
    992c:	b126      	cbz	r6, 9938 <setvbuf+0x1c>
    992e:	69b3      	ldr	r3, [r6, #24]
    9930:	b913      	cbnz	r3, 9938 <setvbuf+0x1c>
    9932:	4630      	mov	r0, r6
    9934:	f000 fa5a 	bl	9dec <__sinit>
    9938:	4b4c      	ldr	r3, [pc, #304]	; (9a6c <setvbuf+0x150>)
    993a:	429c      	cmp	r4, r3
    993c:	d152      	bne.n	99e4 <setvbuf+0xc8>
    993e:	6874      	ldr	r4, [r6, #4]
    9940:	f1b8 0f02 	cmp.w	r8, #2
    9944:	d006      	beq.n	9954 <setvbuf+0x38>
    9946:	f1b8 0f01 	cmp.w	r8, #1
    994a:	f200 8089 	bhi.w	9a60 <setvbuf+0x144>
    994e:	2d00      	cmp	r5, #0
    9950:	f2c0 8086 	blt.w	9a60 <setvbuf+0x144>
    9954:	4621      	mov	r1, r4
    9956:	4630      	mov	r0, r6
    9958:	f000 f9de 	bl	9d18 <_fflush_r>
    995c:	6b61      	ldr	r1, [r4, #52]	; 0x34
    995e:	b141      	cbz	r1, 9972 <setvbuf+0x56>
    9960:	f104 0344 	add.w	r3, r4, #68	; 0x44
    9964:	4299      	cmp	r1, r3
    9966:	d002      	beq.n	996e <setvbuf+0x52>
    9968:	4630      	mov	r0, r6
    996a:	f000 fb35 	bl	9fd8 <_free_r>
    996e:	2300      	movs	r3, #0
    9970:	6363      	str	r3, [r4, #52]	; 0x34
    9972:	2300      	movs	r3, #0
    9974:	61a3      	str	r3, [r4, #24]
    9976:	6063      	str	r3, [r4, #4]
    9978:	89a3      	ldrh	r3, [r4, #12]
    997a:	061b      	lsls	r3, r3, #24
    997c:	d503      	bpl.n	9986 <setvbuf+0x6a>
    997e:	6921      	ldr	r1, [r4, #16]
    9980:	4630      	mov	r0, r6
    9982:	f000 fb29 	bl	9fd8 <_free_r>
    9986:	89a3      	ldrh	r3, [r4, #12]
    9988:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
    998c:	f023 0303 	bic.w	r3, r3, #3
    9990:	f1b8 0f02 	cmp.w	r8, #2
    9994:	81a3      	strh	r3, [r4, #12]
    9996:	d05d      	beq.n	9a54 <setvbuf+0x138>
    9998:	ab01      	add	r3, sp, #4
    999a:	466a      	mov	r2, sp
    999c:	4621      	mov	r1, r4
    999e:	4630      	mov	r0, r6
    99a0:	f000 faae 	bl	9f00 <__swhatbuf_r>
    99a4:	89a3      	ldrh	r3, [r4, #12]
    99a6:	4318      	orrs	r0, r3
    99a8:	81a0      	strh	r0, [r4, #12]
    99aa:	bb2d      	cbnz	r5, 99f8 <setvbuf+0xdc>
    99ac:	9d00      	ldr	r5, [sp, #0]
    99ae:	4628      	mov	r0, r5
    99b0:	f000 fb0a 	bl	9fc8 <malloc>
    99b4:	4607      	mov	r7, r0
    99b6:	2800      	cmp	r0, #0
    99b8:	d14e      	bne.n	9a58 <setvbuf+0x13c>
    99ba:	f8dd 9000 	ldr.w	r9, [sp]
    99be:	45a9      	cmp	r9, r5
    99c0:	d13c      	bne.n	9a3c <setvbuf+0x120>
    99c2:	f04f 30ff 	mov.w	r0, #4294967295
    99c6:	89a3      	ldrh	r3, [r4, #12]
    99c8:	f043 0302 	orr.w	r3, r3, #2
    99cc:	81a3      	strh	r3, [r4, #12]
    99ce:	2300      	movs	r3, #0
    99d0:	60a3      	str	r3, [r4, #8]
    99d2:	f104 0347 	add.w	r3, r4, #71	; 0x47
    99d6:	6023      	str	r3, [r4, #0]
    99d8:	6123      	str	r3, [r4, #16]
    99da:	2301      	movs	r3, #1
    99dc:	6163      	str	r3, [r4, #20]
    99de:	b003      	add	sp, #12
    99e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    99e4:	4b22      	ldr	r3, [pc, #136]	; (9a70 <setvbuf+0x154>)
    99e6:	429c      	cmp	r4, r3
    99e8:	d101      	bne.n	99ee <setvbuf+0xd2>
    99ea:	68b4      	ldr	r4, [r6, #8]
    99ec:	e7a8      	b.n	9940 <setvbuf+0x24>
    99ee:	4b21      	ldr	r3, [pc, #132]	; (9a74 <setvbuf+0x158>)
    99f0:	429c      	cmp	r4, r3
    99f2:	bf08      	it	eq
    99f4:	68f4      	ldreq	r4, [r6, #12]
    99f6:	e7a3      	b.n	9940 <setvbuf+0x24>
    99f8:	2f00      	cmp	r7, #0
    99fa:	d0d8      	beq.n	99ae <setvbuf+0x92>
    99fc:	69b3      	ldr	r3, [r6, #24]
    99fe:	b913      	cbnz	r3, 9a06 <setvbuf+0xea>
    9a00:	4630      	mov	r0, r6
    9a02:	f000 f9f3 	bl	9dec <__sinit>
    9a06:	f1b8 0f01 	cmp.w	r8, #1
    9a0a:	bf08      	it	eq
    9a0c:	89a3      	ldrheq	r3, [r4, #12]
    9a0e:	6027      	str	r7, [r4, #0]
    9a10:	bf04      	itt	eq
    9a12:	f043 0301 	orreq.w	r3, r3, #1
    9a16:	81a3      	strheq	r3, [r4, #12]
    9a18:	89a3      	ldrh	r3, [r4, #12]
    9a1a:	6127      	str	r7, [r4, #16]
    9a1c:	f013 0008 	ands.w	r0, r3, #8
    9a20:	6165      	str	r5, [r4, #20]
    9a22:	d01b      	beq.n	9a5c <setvbuf+0x140>
    9a24:	f013 0001 	ands.w	r0, r3, #1
    9a28:	bf18      	it	ne
    9a2a:	426d      	negne	r5, r5
    9a2c:	f04f 0300 	mov.w	r3, #0
    9a30:	bf1d      	ittte	ne
    9a32:	60a3      	strne	r3, [r4, #8]
    9a34:	61a5      	strne	r5, [r4, #24]
    9a36:	4618      	movne	r0, r3
    9a38:	60a5      	streq	r5, [r4, #8]
    9a3a:	e7d0      	b.n	99de <setvbuf+0xc2>
    9a3c:	4648      	mov	r0, r9
    9a3e:	f000 fac3 	bl	9fc8 <malloc>
    9a42:	4607      	mov	r7, r0
    9a44:	2800      	cmp	r0, #0
    9a46:	d0bc      	beq.n	99c2 <setvbuf+0xa6>
    9a48:	89a3      	ldrh	r3, [r4, #12]
    9a4a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    9a4e:	81a3      	strh	r3, [r4, #12]
    9a50:	464d      	mov	r5, r9
    9a52:	e7d3      	b.n	99fc <setvbuf+0xe0>
    9a54:	2000      	movs	r0, #0
    9a56:	e7b6      	b.n	99c6 <setvbuf+0xaa>
    9a58:	46a9      	mov	r9, r5
    9a5a:	e7f5      	b.n	9a48 <setvbuf+0x12c>
    9a5c:	60a0      	str	r0, [r4, #8]
    9a5e:	e7be      	b.n	99de <setvbuf+0xc2>
    9a60:	f04f 30ff 	mov.w	r0, #4294967295
    9a64:	e7bb      	b.n	99de <setvbuf+0xc2>
    9a66:	bf00      	nop
    9a68:	20000010 	.word	0x20000010
    9a6c:	0000bf9c 	.word	0x0000bf9c
    9a70:	0000bfbc 	.word	0x0000bfbc
    9a74:	0000bf7c 	.word	0x0000bf7c

00009a78 <strlen>:
    9a78:	4603      	mov	r3, r0
    9a7a:	f813 2b01 	ldrb.w	r2, [r3], #1
    9a7e:	2a00      	cmp	r2, #0
    9a80:	d1fb      	bne.n	9a7a <strlen+0x2>
    9a82:	1a18      	subs	r0, r3, r0
    9a84:	3801      	subs	r0, #1
    9a86:	4770      	bx	lr

00009a88 <__swbuf_r>:
    9a88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9a8a:	460e      	mov	r6, r1
    9a8c:	4614      	mov	r4, r2
    9a8e:	4605      	mov	r5, r0
    9a90:	b118      	cbz	r0, 9a9a <__swbuf_r+0x12>
    9a92:	6983      	ldr	r3, [r0, #24]
    9a94:	b90b      	cbnz	r3, 9a9a <__swbuf_r+0x12>
    9a96:	f000 f9a9 	bl	9dec <__sinit>
    9a9a:	4b21      	ldr	r3, [pc, #132]	; (9b20 <__swbuf_r+0x98>)
    9a9c:	429c      	cmp	r4, r3
    9a9e:	d12a      	bne.n	9af6 <__swbuf_r+0x6e>
    9aa0:	686c      	ldr	r4, [r5, #4]
    9aa2:	69a3      	ldr	r3, [r4, #24]
    9aa4:	60a3      	str	r3, [r4, #8]
    9aa6:	89a3      	ldrh	r3, [r4, #12]
    9aa8:	071a      	lsls	r2, r3, #28
    9aaa:	d52e      	bpl.n	9b0a <__swbuf_r+0x82>
    9aac:	6923      	ldr	r3, [r4, #16]
    9aae:	b363      	cbz	r3, 9b0a <__swbuf_r+0x82>
    9ab0:	6923      	ldr	r3, [r4, #16]
    9ab2:	6820      	ldr	r0, [r4, #0]
    9ab4:	1ac0      	subs	r0, r0, r3
    9ab6:	6963      	ldr	r3, [r4, #20]
    9ab8:	b2f6      	uxtb	r6, r6
    9aba:	4298      	cmp	r0, r3
    9abc:	4637      	mov	r7, r6
    9abe:	db04      	blt.n	9aca <__swbuf_r+0x42>
    9ac0:	4621      	mov	r1, r4
    9ac2:	4628      	mov	r0, r5
    9ac4:	f000 f928 	bl	9d18 <_fflush_r>
    9ac8:	bb28      	cbnz	r0, 9b16 <__swbuf_r+0x8e>
    9aca:	68a3      	ldr	r3, [r4, #8]
    9acc:	3b01      	subs	r3, #1
    9ace:	60a3      	str	r3, [r4, #8]
    9ad0:	6823      	ldr	r3, [r4, #0]
    9ad2:	1c5a      	adds	r2, r3, #1
    9ad4:	6022      	str	r2, [r4, #0]
    9ad6:	701e      	strb	r6, [r3, #0]
    9ad8:	6963      	ldr	r3, [r4, #20]
    9ada:	3001      	adds	r0, #1
    9adc:	4298      	cmp	r0, r3
    9ade:	d004      	beq.n	9aea <__swbuf_r+0x62>
    9ae0:	89a3      	ldrh	r3, [r4, #12]
    9ae2:	07db      	lsls	r3, r3, #31
    9ae4:	d519      	bpl.n	9b1a <__swbuf_r+0x92>
    9ae6:	2e0a      	cmp	r6, #10
    9ae8:	d117      	bne.n	9b1a <__swbuf_r+0x92>
    9aea:	4621      	mov	r1, r4
    9aec:	4628      	mov	r0, r5
    9aee:	f000 f913 	bl	9d18 <_fflush_r>
    9af2:	b190      	cbz	r0, 9b1a <__swbuf_r+0x92>
    9af4:	e00f      	b.n	9b16 <__swbuf_r+0x8e>
    9af6:	4b0b      	ldr	r3, [pc, #44]	; (9b24 <__swbuf_r+0x9c>)
    9af8:	429c      	cmp	r4, r3
    9afa:	d101      	bne.n	9b00 <__swbuf_r+0x78>
    9afc:	68ac      	ldr	r4, [r5, #8]
    9afe:	e7d0      	b.n	9aa2 <__swbuf_r+0x1a>
    9b00:	4b09      	ldr	r3, [pc, #36]	; (9b28 <__swbuf_r+0xa0>)
    9b02:	429c      	cmp	r4, r3
    9b04:	bf08      	it	eq
    9b06:	68ec      	ldreq	r4, [r5, #12]
    9b08:	e7cb      	b.n	9aa2 <__swbuf_r+0x1a>
    9b0a:	4621      	mov	r1, r4
    9b0c:	4628      	mov	r0, r5
    9b0e:	f000 f80d 	bl	9b2c <__swsetup_r>
    9b12:	2800      	cmp	r0, #0
    9b14:	d0cc      	beq.n	9ab0 <__swbuf_r+0x28>
    9b16:	f04f 37ff 	mov.w	r7, #4294967295
    9b1a:	4638      	mov	r0, r7
    9b1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9b1e:	bf00      	nop
    9b20:	0000bf9c 	.word	0x0000bf9c
    9b24:	0000bfbc 	.word	0x0000bfbc
    9b28:	0000bf7c 	.word	0x0000bf7c

00009b2c <__swsetup_r>:
    9b2c:	4b32      	ldr	r3, [pc, #200]	; (9bf8 <__swsetup_r+0xcc>)
    9b2e:	b570      	push	{r4, r5, r6, lr}
    9b30:	681d      	ldr	r5, [r3, #0]
    9b32:	4606      	mov	r6, r0
    9b34:	460c      	mov	r4, r1
    9b36:	b125      	cbz	r5, 9b42 <__swsetup_r+0x16>
    9b38:	69ab      	ldr	r3, [r5, #24]
    9b3a:	b913      	cbnz	r3, 9b42 <__swsetup_r+0x16>
    9b3c:	4628      	mov	r0, r5
    9b3e:	f000 f955 	bl	9dec <__sinit>
    9b42:	4b2e      	ldr	r3, [pc, #184]	; (9bfc <__swsetup_r+0xd0>)
    9b44:	429c      	cmp	r4, r3
    9b46:	d10f      	bne.n	9b68 <__swsetup_r+0x3c>
    9b48:	686c      	ldr	r4, [r5, #4]
    9b4a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    9b4e:	b29a      	uxth	r2, r3
    9b50:	0715      	lsls	r5, r2, #28
    9b52:	d42c      	bmi.n	9bae <__swsetup_r+0x82>
    9b54:	06d0      	lsls	r0, r2, #27
    9b56:	d411      	bmi.n	9b7c <__swsetup_r+0x50>
    9b58:	2209      	movs	r2, #9
    9b5a:	6032      	str	r2, [r6, #0]
    9b5c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    9b60:	81a3      	strh	r3, [r4, #12]
    9b62:	f04f 30ff 	mov.w	r0, #4294967295
    9b66:	bd70      	pop	{r4, r5, r6, pc}
    9b68:	4b25      	ldr	r3, [pc, #148]	; (9c00 <__swsetup_r+0xd4>)
    9b6a:	429c      	cmp	r4, r3
    9b6c:	d101      	bne.n	9b72 <__swsetup_r+0x46>
    9b6e:	68ac      	ldr	r4, [r5, #8]
    9b70:	e7eb      	b.n	9b4a <__swsetup_r+0x1e>
    9b72:	4b24      	ldr	r3, [pc, #144]	; (9c04 <__swsetup_r+0xd8>)
    9b74:	429c      	cmp	r4, r3
    9b76:	bf08      	it	eq
    9b78:	68ec      	ldreq	r4, [r5, #12]
    9b7a:	e7e6      	b.n	9b4a <__swsetup_r+0x1e>
    9b7c:	0751      	lsls	r1, r2, #29
    9b7e:	d512      	bpl.n	9ba6 <__swsetup_r+0x7a>
    9b80:	6b61      	ldr	r1, [r4, #52]	; 0x34
    9b82:	b141      	cbz	r1, 9b96 <__swsetup_r+0x6a>
    9b84:	f104 0344 	add.w	r3, r4, #68	; 0x44
    9b88:	4299      	cmp	r1, r3
    9b8a:	d002      	beq.n	9b92 <__swsetup_r+0x66>
    9b8c:	4630      	mov	r0, r6
    9b8e:	f000 fa23 	bl	9fd8 <_free_r>
    9b92:	2300      	movs	r3, #0
    9b94:	6363      	str	r3, [r4, #52]	; 0x34
    9b96:	89a3      	ldrh	r3, [r4, #12]
    9b98:	f023 0324 	bic.w	r3, r3, #36	; 0x24
    9b9c:	81a3      	strh	r3, [r4, #12]
    9b9e:	2300      	movs	r3, #0
    9ba0:	6063      	str	r3, [r4, #4]
    9ba2:	6923      	ldr	r3, [r4, #16]
    9ba4:	6023      	str	r3, [r4, #0]
    9ba6:	89a3      	ldrh	r3, [r4, #12]
    9ba8:	f043 0308 	orr.w	r3, r3, #8
    9bac:	81a3      	strh	r3, [r4, #12]
    9bae:	6923      	ldr	r3, [r4, #16]
    9bb0:	b94b      	cbnz	r3, 9bc6 <__swsetup_r+0x9a>
    9bb2:	89a3      	ldrh	r3, [r4, #12]
    9bb4:	f403 7320 	and.w	r3, r3, #640	; 0x280
    9bb8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    9bbc:	d003      	beq.n	9bc6 <__swsetup_r+0x9a>
    9bbe:	4621      	mov	r1, r4
    9bc0:	4630      	mov	r0, r6
    9bc2:	f000 f9c1 	bl	9f48 <__smakebuf_r>
    9bc6:	89a2      	ldrh	r2, [r4, #12]
    9bc8:	f012 0301 	ands.w	r3, r2, #1
    9bcc:	d00c      	beq.n	9be8 <__swsetup_r+0xbc>
    9bce:	2300      	movs	r3, #0
    9bd0:	60a3      	str	r3, [r4, #8]
    9bd2:	6963      	ldr	r3, [r4, #20]
    9bd4:	425b      	negs	r3, r3
    9bd6:	61a3      	str	r3, [r4, #24]
    9bd8:	6923      	ldr	r3, [r4, #16]
    9bda:	b953      	cbnz	r3, 9bf2 <__swsetup_r+0xc6>
    9bdc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    9be0:	f013 0080 	ands.w	r0, r3, #128	; 0x80
    9be4:	d1ba      	bne.n	9b5c <__swsetup_r+0x30>
    9be6:	bd70      	pop	{r4, r5, r6, pc}
    9be8:	0792      	lsls	r2, r2, #30
    9bea:	bf58      	it	pl
    9bec:	6963      	ldrpl	r3, [r4, #20]
    9bee:	60a3      	str	r3, [r4, #8]
    9bf0:	e7f2      	b.n	9bd8 <__swsetup_r+0xac>
    9bf2:	2000      	movs	r0, #0
    9bf4:	e7f7      	b.n	9be6 <__swsetup_r+0xba>
    9bf6:	bf00      	nop
    9bf8:	20000010 	.word	0x20000010
    9bfc:	0000bf9c 	.word	0x0000bf9c
    9c00:	0000bfbc 	.word	0x0000bfbc
    9c04:	0000bf7c 	.word	0x0000bf7c

00009c08 <__sflush_r>:
    9c08:	898a      	ldrh	r2, [r1, #12]
    9c0a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9c0e:	4605      	mov	r5, r0
    9c10:	0710      	lsls	r0, r2, #28
    9c12:	460c      	mov	r4, r1
    9c14:	d45a      	bmi.n	9ccc <__sflush_r+0xc4>
    9c16:	684b      	ldr	r3, [r1, #4]
    9c18:	2b00      	cmp	r3, #0
    9c1a:	dc05      	bgt.n	9c28 <__sflush_r+0x20>
    9c1c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    9c1e:	2b00      	cmp	r3, #0
    9c20:	dc02      	bgt.n	9c28 <__sflush_r+0x20>
    9c22:	2000      	movs	r0, #0
    9c24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9c28:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    9c2a:	2e00      	cmp	r6, #0
    9c2c:	d0f9      	beq.n	9c22 <__sflush_r+0x1a>
    9c2e:	2300      	movs	r3, #0
    9c30:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
    9c34:	682f      	ldr	r7, [r5, #0]
    9c36:	602b      	str	r3, [r5, #0]
    9c38:	d033      	beq.n	9ca2 <__sflush_r+0x9a>
    9c3a:	6d60      	ldr	r0, [r4, #84]	; 0x54
    9c3c:	89a3      	ldrh	r3, [r4, #12]
    9c3e:	075a      	lsls	r2, r3, #29
    9c40:	d505      	bpl.n	9c4e <__sflush_r+0x46>
    9c42:	6863      	ldr	r3, [r4, #4]
    9c44:	1ac0      	subs	r0, r0, r3
    9c46:	6b63      	ldr	r3, [r4, #52]	; 0x34
    9c48:	b10b      	cbz	r3, 9c4e <__sflush_r+0x46>
    9c4a:	6c23      	ldr	r3, [r4, #64]	; 0x40
    9c4c:	1ac0      	subs	r0, r0, r3
    9c4e:	2300      	movs	r3, #0
    9c50:	4602      	mov	r2, r0
    9c52:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    9c54:	6a21      	ldr	r1, [r4, #32]
    9c56:	4628      	mov	r0, r5
    9c58:	47b0      	blx	r6
    9c5a:	1c43      	adds	r3, r0, #1
    9c5c:	89a3      	ldrh	r3, [r4, #12]
    9c5e:	d106      	bne.n	9c6e <__sflush_r+0x66>
    9c60:	6829      	ldr	r1, [r5, #0]
    9c62:	291d      	cmp	r1, #29
    9c64:	d84b      	bhi.n	9cfe <__sflush_r+0xf6>
    9c66:	4a2b      	ldr	r2, [pc, #172]	; (9d14 <__sflush_r+0x10c>)
    9c68:	40ca      	lsrs	r2, r1
    9c6a:	07d6      	lsls	r6, r2, #31
    9c6c:	d547      	bpl.n	9cfe <__sflush_r+0xf6>
    9c6e:	2200      	movs	r2, #0
    9c70:	6062      	str	r2, [r4, #4]
    9c72:	04d9      	lsls	r1, r3, #19
    9c74:	6922      	ldr	r2, [r4, #16]
    9c76:	6022      	str	r2, [r4, #0]
    9c78:	d504      	bpl.n	9c84 <__sflush_r+0x7c>
    9c7a:	1c42      	adds	r2, r0, #1
    9c7c:	d101      	bne.n	9c82 <__sflush_r+0x7a>
    9c7e:	682b      	ldr	r3, [r5, #0]
    9c80:	b903      	cbnz	r3, 9c84 <__sflush_r+0x7c>
    9c82:	6560      	str	r0, [r4, #84]	; 0x54
    9c84:	6b61      	ldr	r1, [r4, #52]	; 0x34
    9c86:	602f      	str	r7, [r5, #0]
    9c88:	2900      	cmp	r1, #0
    9c8a:	d0ca      	beq.n	9c22 <__sflush_r+0x1a>
    9c8c:	f104 0344 	add.w	r3, r4, #68	; 0x44
    9c90:	4299      	cmp	r1, r3
    9c92:	d002      	beq.n	9c9a <__sflush_r+0x92>
    9c94:	4628      	mov	r0, r5
    9c96:	f000 f99f 	bl	9fd8 <_free_r>
    9c9a:	2000      	movs	r0, #0
    9c9c:	6360      	str	r0, [r4, #52]	; 0x34
    9c9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9ca2:	6a21      	ldr	r1, [r4, #32]
    9ca4:	2301      	movs	r3, #1
    9ca6:	4628      	mov	r0, r5
    9ca8:	47b0      	blx	r6
    9caa:	1c41      	adds	r1, r0, #1
    9cac:	d1c6      	bne.n	9c3c <__sflush_r+0x34>
    9cae:	682b      	ldr	r3, [r5, #0]
    9cb0:	2b00      	cmp	r3, #0
    9cb2:	d0c3      	beq.n	9c3c <__sflush_r+0x34>
    9cb4:	2b1d      	cmp	r3, #29
    9cb6:	d001      	beq.n	9cbc <__sflush_r+0xb4>
    9cb8:	2b16      	cmp	r3, #22
    9cba:	d101      	bne.n	9cc0 <__sflush_r+0xb8>
    9cbc:	602f      	str	r7, [r5, #0]
    9cbe:	e7b0      	b.n	9c22 <__sflush_r+0x1a>
    9cc0:	89a3      	ldrh	r3, [r4, #12]
    9cc2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    9cc6:	81a3      	strh	r3, [r4, #12]
    9cc8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9ccc:	690f      	ldr	r7, [r1, #16]
    9cce:	2f00      	cmp	r7, #0
    9cd0:	d0a7      	beq.n	9c22 <__sflush_r+0x1a>
    9cd2:	0793      	lsls	r3, r2, #30
    9cd4:	680e      	ldr	r6, [r1, #0]
    9cd6:	bf08      	it	eq
    9cd8:	694b      	ldreq	r3, [r1, #20]
    9cda:	600f      	str	r7, [r1, #0]
    9cdc:	bf18      	it	ne
    9cde:	2300      	movne	r3, #0
    9ce0:	eba6 0807 	sub.w	r8, r6, r7
    9ce4:	608b      	str	r3, [r1, #8]
    9ce6:	f1b8 0f00 	cmp.w	r8, #0
    9cea:	dd9a      	ble.n	9c22 <__sflush_r+0x1a>
    9cec:	4643      	mov	r3, r8
    9cee:	463a      	mov	r2, r7
    9cf0:	6a21      	ldr	r1, [r4, #32]
    9cf2:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    9cf4:	4628      	mov	r0, r5
    9cf6:	47b0      	blx	r6
    9cf8:	2800      	cmp	r0, #0
    9cfa:	dc07      	bgt.n	9d0c <__sflush_r+0x104>
    9cfc:	89a3      	ldrh	r3, [r4, #12]
    9cfe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    9d02:	81a3      	strh	r3, [r4, #12]
    9d04:	f04f 30ff 	mov.w	r0, #4294967295
    9d08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9d0c:	4407      	add	r7, r0
    9d0e:	eba8 0800 	sub.w	r8, r8, r0
    9d12:	e7e8      	b.n	9ce6 <__sflush_r+0xde>
    9d14:	20400001 	.word	0x20400001

00009d18 <_fflush_r>:
    9d18:	b538      	push	{r3, r4, r5, lr}
    9d1a:	690b      	ldr	r3, [r1, #16]
    9d1c:	4605      	mov	r5, r0
    9d1e:	460c      	mov	r4, r1
    9d20:	b1db      	cbz	r3, 9d5a <_fflush_r+0x42>
    9d22:	b118      	cbz	r0, 9d2c <_fflush_r+0x14>
    9d24:	6983      	ldr	r3, [r0, #24]
    9d26:	b90b      	cbnz	r3, 9d2c <_fflush_r+0x14>
    9d28:	f000 f860 	bl	9dec <__sinit>
    9d2c:	4b0c      	ldr	r3, [pc, #48]	; (9d60 <_fflush_r+0x48>)
    9d2e:	429c      	cmp	r4, r3
    9d30:	d109      	bne.n	9d46 <_fflush_r+0x2e>
    9d32:	686c      	ldr	r4, [r5, #4]
    9d34:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    9d38:	b17b      	cbz	r3, 9d5a <_fflush_r+0x42>
    9d3a:	4621      	mov	r1, r4
    9d3c:	4628      	mov	r0, r5
    9d3e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    9d42:	f7ff bf61 	b.w	9c08 <__sflush_r>
    9d46:	4b07      	ldr	r3, [pc, #28]	; (9d64 <_fflush_r+0x4c>)
    9d48:	429c      	cmp	r4, r3
    9d4a:	d101      	bne.n	9d50 <_fflush_r+0x38>
    9d4c:	68ac      	ldr	r4, [r5, #8]
    9d4e:	e7f1      	b.n	9d34 <_fflush_r+0x1c>
    9d50:	4b05      	ldr	r3, [pc, #20]	; (9d68 <_fflush_r+0x50>)
    9d52:	429c      	cmp	r4, r3
    9d54:	bf08      	it	eq
    9d56:	68ec      	ldreq	r4, [r5, #12]
    9d58:	e7ec      	b.n	9d34 <_fflush_r+0x1c>
    9d5a:	2000      	movs	r0, #0
    9d5c:	bd38      	pop	{r3, r4, r5, pc}
    9d5e:	bf00      	nop
    9d60:	0000bf9c 	.word	0x0000bf9c
    9d64:	0000bfbc 	.word	0x0000bfbc
    9d68:	0000bf7c 	.word	0x0000bf7c

00009d6c <_cleanup_r>:
    9d6c:	4901      	ldr	r1, [pc, #4]	; (9d74 <_cleanup_r+0x8>)
    9d6e:	f000 b8a9 	b.w	9ec4 <_fwalk_reent>
    9d72:	bf00      	nop
    9d74:	00009d19 	.word	0x00009d19

00009d78 <std.isra.0>:
    9d78:	2300      	movs	r3, #0
    9d7a:	b510      	push	{r4, lr}
    9d7c:	4604      	mov	r4, r0
    9d7e:	6003      	str	r3, [r0, #0]
    9d80:	6043      	str	r3, [r0, #4]
    9d82:	6083      	str	r3, [r0, #8]
    9d84:	8181      	strh	r1, [r0, #12]
    9d86:	6643      	str	r3, [r0, #100]	; 0x64
    9d88:	81c2      	strh	r2, [r0, #14]
    9d8a:	6103      	str	r3, [r0, #16]
    9d8c:	6143      	str	r3, [r0, #20]
    9d8e:	6183      	str	r3, [r0, #24]
    9d90:	4619      	mov	r1, r3
    9d92:	2208      	movs	r2, #8
    9d94:	305c      	adds	r0, #92	; 0x5c
    9d96:	f7ff fd35 	bl	9804 <memset>
    9d9a:	4b05      	ldr	r3, [pc, #20]	; (9db0 <std.isra.0+0x38>)
    9d9c:	6263      	str	r3, [r4, #36]	; 0x24
    9d9e:	4b05      	ldr	r3, [pc, #20]	; (9db4 <std.isra.0+0x3c>)
    9da0:	62a3      	str	r3, [r4, #40]	; 0x28
    9da2:	4b05      	ldr	r3, [pc, #20]	; (9db8 <std.isra.0+0x40>)
    9da4:	62e3      	str	r3, [r4, #44]	; 0x2c
    9da6:	4b05      	ldr	r3, [pc, #20]	; (9dbc <std.isra.0+0x44>)
    9da8:	6224      	str	r4, [r4, #32]
    9daa:	6323      	str	r3, [r4, #48]	; 0x30
    9dac:	bd10      	pop	{r4, pc}
    9dae:	bf00      	nop
    9db0:	0000a6f9 	.word	0x0000a6f9
    9db4:	0000a71b 	.word	0x0000a71b
    9db8:	0000a753 	.word	0x0000a753
    9dbc:	0000a777 	.word	0x0000a777

00009dc0 <__sfmoreglue>:
    9dc0:	b570      	push	{r4, r5, r6, lr}
    9dc2:	1e4a      	subs	r2, r1, #1
    9dc4:	2568      	movs	r5, #104	; 0x68
    9dc6:	4355      	muls	r5, r2
    9dc8:	460e      	mov	r6, r1
    9dca:	f105 0174 	add.w	r1, r5, #116	; 0x74
    9dce:	f000 f951 	bl	a074 <_malloc_r>
    9dd2:	4604      	mov	r4, r0
    9dd4:	b140      	cbz	r0, 9de8 <__sfmoreglue+0x28>
    9dd6:	2100      	movs	r1, #0
    9dd8:	e880 0042 	stmia.w	r0, {r1, r6}
    9ddc:	300c      	adds	r0, #12
    9dde:	60a0      	str	r0, [r4, #8]
    9de0:	f105 0268 	add.w	r2, r5, #104	; 0x68
    9de4:	f7ff fd0e 	bl	9804 <memset>
    9de8:	4620      	mov	r0, r4
    9dea:	bd70      	pop	{r4, r5, r6, pc}

00009dec <__sinit>:
    9dec:	6983      	ldr	r3, [r0, #24]
    9dee:	b510      	push	{r4, lr}
    9df0:	4604      	mov	r4, r0
    9df2:	bb33      	cbnz	r3, 9e42 <__sinit+0x56>
    9df4:	6483      	str	r3, [r0, #72]	; 0x48
    9df6:	64c3      	str	r3, [r0, #76]	; 0x4c
    9df8:	6503      	str	r3, [r0, #80]	; 0x50
    9dfa:	4b12      	ldr	r3, [pc, #72]	; (9e44 <__sinit+0x58>)
    9dfc:	4a12      	ldr	r2, [pc, #72]	; (9e48 <__sinit+0x5c>)
    9dfe:	681b      	ldr	r3, [r3, #0]
    9e00:	6282      	str	r2, [r0, #40]	; 0x28
    9e02:	4298      	cmp	r0, r3
    9e04:	bf04      	itt	eq
    9e06:	2301      	moveq	r3, #1
    9e08:	6183      	streq	r3, [r0, #24]
    9e0a:	f000 f81f 	bl	9e4c <__sfp>
    9e0e:	6060      	str	r0, [r4, #4]
    9e10:	4620      	mov	r0, r4
    9e12:	f000 f81b 	bl	9e4c <__sfp>
    9e16:	60a0      	str	r0, [r4, #8]
    9e18:	4620      	mov	r0, r4
    9e1a:	f000 f817 	bl	9e4c <__sfp>
    9e1e:	2200      	movs	r2, #0
    9e20:	60e0      	str	r0, [r4, #12]
    9e22:	2104      	movs	r1, #4
    9e24:	6860      	ldr	r0, [r4, #4]
    9e26:	f7ff ffa7 	bl	9d78 <std.isra.0>
    9e2a:	2201      	movs	r2, #1
    9e2c:	2109      	movs	r1, #9
    9e2e:	68a0      	ldr	r0, [r4, #8]
    9e30:	f7ff ffa2 	bl	9d78 <std.isra.0>
    9e34:	2202      	movs	r2, #2
    9e36:	2112      	movs	r1, #18
    9e38:	68e0      	ldr	r0, [r4, #12]
    9e3a:	f7ff ff9d 	bl	9d78 <std.isra.0>
    9e3e:	2301      	movs	r3, #1
    9e40:	61a3      	str	r3, [r4, #24]
    9e42:	bd10      	pop	{r4, pc}
    9e44:	0000bf78 	.word	0x0000bf78
    9e48:	00009d6d 	.word	0x00009d6d

00009e4c <__sfp>:
    9e4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9e4e:	4b1c      	ldr	r3, [pc, #112]	; (9ec0 <__sfp+0x74>)
    9e50:	681e      	ldr	r6, [r3, #0]
    9e52:	69b3      	ldr	r3, [r6, #24]
    9e54:	4607      	mov	r7, r0
    9e56:	b913      	cbnz	r3, 9e5e <__sfp+0x12>
    9e58:	4630      	mov	r0, r6
    9e5a:	f7ff ffc7 	bl	9dec <__sinit>
    9e5e:	3648      	adds	r6, #72	; 0x48
    9e60:	68b4      	ldr	r4, [r6, #8]
    9e62:	6873      	ldr	r3, [r6, #4]
    9e64:	3b01      	subs	r3, #1
    9e66:	d503      	bpl.n	9e70 <__sfp+0x24>
    9e68:	6833      	ldr	r3, [r6, #0]
    9e6a:	b133      	cbz	r3, 9e7a <__sfp+0x2e>
    9e6c:	6836      	ldr	r6, [r6, #0]
    9e6e:	e7f7      	b.n	9e60 <__sfp+0x14>
    9e70:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
    9e74:	b16d      	cbz	r5, 9e92 <__sfp+0x46>
    9e76:	3468      	adds	r4, #104	; 0x68
    9e78:	e7f4      	b.n	9e64 <__sfp+0x18>
    9e7a:	2104      	movs	r1, #4
    9e7c:	4638      	mov	r0, r7
    9e7e:	f7ff ff9f 	bl	9dc0 <__sfmoreglue>
    9e82:	6030      	str	r0, [r6, #0]
    9e84:	2800      	cmp	r0, #0
    9e86:	d1f1      	bne.n	9e6c <__sfp+0x20>
    9e88:	230c      	movs	r3, #12
    9e8a:	603b      	str	r3, [r7, #0]
    9e8c:	4604      	mov	r4, r0
    9e8e:	4620      	mov	r0, r4
    9e90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9e92:	f64f 73ff 	movw	r3, #65535	; 0xffff
    9e96:	81e3      	strh	r3, [r4, #14]
    9e98:	2301      	movs	r3, #1
    9e9a:	81a3      	strh	r3, [r4, #12]
    9e9c:	6665      	str	r5, [r4, #100]	; 0x64
    9e9e:	6025      	str	r5, [r4, #0]
    9ea0:	60a5      	str	r5, [r4, #8]
    9ea2:	6065      	str	r5, [r4, #4]
    9ea4:	6125      	str	r5, [r4, #16]
    9ea6:	6165      	str	r5, [r4, #20]
    9ea8:	61a5      	str	r5, [r4, #24]
    9eaa:	2208      	movs	r2, #8
    9eac:	4629      	mov	r1, r5
    9eae:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    9eb2:	f7ff fca7 	bl	9804 <memset>
    9eb6:	6365      	str	r5, [r4, #52]	; 0x34
    9eb8:	63a5      	str	r5, [r4, #56]	; 0x38
    9eba:	64a5      	str	r5, [r4, #72]	; 0x48
    9ebc:	64e5      	str	r5, [r4, #76]	; 0x4c
    9ebe:	e7e6      	b.n	9e8e <__sfp+0x42>
    9ec0:	0000bf78 	.word	0x0000bf78

00009ec4 <_fwalk_reent>:
    9ec4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    9ec8:	4680      	mov	r8, r0
    9eca:	4689      	mov	r9, r1
    9ecc:	f100 0448 	add.w	r4, r0, #72	; 0x48
    9ed0:	2600      	movs	r6, #0
    9ed2:	b914      	cbnz	r4, 9eda <_fwalk_reent+0x16>
    9ed4:	4630      	mov	r0, r6
    9ed6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    9eda:	68a5      	ldr	r5, [r4, #8]
    9edc:	6867      	ldr	r7, [r4, #4]
    9ede:	3f01      	subs	r7, #1
    9ee0:	d501      	bpl.n	9ee6 <_fwalk_reent+0x22>
    9ee2:	6824      	ldr	r4, [r4, #0]
    9ee4:	e7f5      	b.n	9ed2 <_fwalk_reent+0xe>
    9ee6:	89ab      	ldrh	r3, [r5, #12]
    9ee8:	2b01      	cmp	r3, #1
    9eea:	d907      	bls.n	9efc <_fwalk_reent+0x38>
    9eec:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    9ef0:	3301      	adds	r3, #1
    9ef2:	d003      	beq.n	9efc <_fwalk_reent+0x38>
    9ef4:	4629      	mov	r1, r5
    9ef6:	4640      	mov	r0, r8
    9ef8:	47c8      	blx	r9
    9efa:	4306      	orrs	r6, r0
    9efc:	3568      	adds	r5, #104	; 0x68
    9efe:	e7ee      	b.n	9ede <_fwalk_reent+0x1a>

00009f00 <__swhatbuf_r>:
    9f00:	b570      	push	{r4, r5, r6, lr}
    9f02:	460e      	mov	r6, r1
    9f04:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    9f08:	2900      	cmp	r1, #0
    9f0a:	b090      	sub	sp, #64	; 0x40
    9f0c:	4614      	mov	r4, r2
    9f0e:	461d      	mov	r5, r3
    9f10:	da07      	bge.n	9f22 <__swhatbuf_r+0x22>
    9f12:	2300      	movs	r3, #0
    9f14:	602b      	str	r3, [r5, #0]
    9f16:	89b3      	ldrh	r3, [r6, #12]
    9f18:	061a      	lsls	r2, r3, #24
    9f1a:	d410      	bmi.n	9f3e <__swhatbuf_r+0x3e>
    9f1c:	f44f 6380 	mov.w	r3, #1024	; 0x400
    9f20:	e00e      	b.n	9f40 <__swhatbuf_r+0x40>
    9f22:	aa01      	add	r2, sp, #4
    9f24:	f000 fc4e 	bl	a7c4 <_fstat_r>
    9f28:	2800      	cmp	r0, #0
    9f2a:	dbf2      	blt.n	9f12 <__swhatbuf_r+0x12>
    9f2c:	9a02      	ldr	r2, [sp, #8]
    9f2e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
    9f32:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
    9f36:	425a      	negs	r2, r3
    9f38:	415a      	adcs	r2, r3
    9f3a:	602a      	str	r2, [r5, #0]
    9f3c:	e7ee      	b.n	9f1c <__swhatbuf_r+0x1c>
    9f3e:	2340      	movs	r3, #64	; 0x40
    9f40:	2000      	movs	r0, #0
    9f42:	6023      	str	r3, [r4, #0]
    9f44:	b010      	add	sp, #64	; 0x40
    9f46:	bd70      	pop	{r4, r5, r6, pc}

00009f48 <__smakebuf_r>:
    9f48:	898b      	ldrh	r3, [r1, #12]
    9f4a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9f4c:	079d      	lsls	r5, r3, #30
    9f4e:	4606      	mov	r6, r0
    9f50:	460c      	mov	r4, r1
    9f52:	d507      	bpl.n	9f64 <__smakebuf_r+0x1c>
    9f54:	f104 0347 	add.w	r3, r4, #71	; 0x47
    9f58:	6023      	str	r3, [r4, #0]
    9f5a:	6123      	str	r3, [r4, #16]
    9f5c:	2301      	movs	r3, #1
    9f5e:	6163      	str	r3, [r4, #20]
    9f60:	b002      	add	sp, #8
    9f62:	bd70      	pop	{r4, r5, r6, pc}
    9f64:	ab01      	add	r3, sp, #4
    9f66:	466a      	mov	r2, sp
    9f68:	f7ff ffca 	bl	9f00 <__swhatbuf_r>
    9f6c:	9900      	ldr	r1, [sp, #0]
    9f6e:	4605      	mov	r5, r0
    9f70:	4630      	mov	r0, r6
    9f72:	f000 f87f 	bl	a074 <_malloc_r>
    9f76:	b948      	cbnz	r0, 9f8c <__smakebuf_r+0x44>
    9f78:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    9f7c:	059a      	lsls	r2, r3, #22
    9f7e:	d4ef      	bmi.n	9f60 <__smakebuf_r+0x18>
    9f80:	f023 0303 	bic.w	r3, r3, #3
    9f84:	f043 0302 	orr.w	r3, r3, #2
    9f88:	81a3      	strh	r3, [r4, #12]
    9f8a:	e7e3      	b.n	9f54 <__smakebuf_r+0xc>
    9f8c:	4b0d      	ldr	r3, [pc, #52]	; (9fc4 <__smakebuf_r+0x7c>)
    9f8e:	62b3      	str	r3, [r6, #40]	; 0x28
    9f90:	89a3      	ldrh	r3, [r4, #12]
    9f92:	6020      	str	r0, [r4, #0]
    9f94:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    9f98:	81a3      	strh	r3, [r4, #12]
    9f9a:	9b00      	ldr	r3, [sp, #0]
    9f9c:	6163      	str	r3, [r4, #20]
    9f9e:	9b01      	ldr	r3, [sp, #4]
    9fa0:	6120      	str	r0, [r4, #16]
    9fa2:	b15b      	cbz	r3, 9fbc <__smakebuf_r+0x74>
    9fa4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    9fa8:	4630      	mov	r0, r6
    9faa:	f000 fc1d 	bl	a7e8 <_isatty_r>
    9fae:	b128      	cbz	r0, 9fbc <__smakebuf_r+0x74>
    9fb0:	89a3      	ldrh	r3, [r4, #12]
    9fb2:	f023 0303 	bic.w	r3, r3, #3
    9fb6:	f043 0301 	orr.w	r3, r3, #1
    9fba:	81a3      	strh	r3, [r4, #12]
    9fbc:	89a3      	ldrh	r3, [r4, #12]
    9fbe:	431d      	orrs	r5, r3
    9fc0:	81a5      	strh	r5, [r4, #12]
    9fc2:	e7cd      	b.n	9f60 <__smakebuf_r+0x18>
    9fc4:	00009d6d 	.word	0x00009d6d

00009fc8 <malloc>:
    9fc8:	4b02      	ldr	r3, [pc, #8]	; (9fd4 <malloc+0xc>)
    9fca:	4601      	mov	r1, r0
    9fcc:	6818      	ldr	r0, [r3, #0]
    9fce:	f000 b851 	b.w	a074 <_malloc_r>
    9fd2:	bf00      	nop
    9fd4:	20000010 	.word	0x20000010

00009fd8 <_free_r>:
    9fd8:	b538      	push	{r3, r4, r5, lr}
    9fda:	4605      	mov	r5, r0
    9fdc:	2900      	cmp	r1, #0
    9fde:	d045      	beq.n	a06c <_free_r+0x94>
    9fe0:	f851 3c04 	ldr.w	r3, [r1, #-4]
    9fe4:	1f0c      	subs	r4, r1, #4
    9fe6:	2b00      	cmp	r3, #0
    9fe8:	bfb8      	it	lt
    9fea:	18e4      	addlt	r4, r4, r3
    9fec:	f000 fc70 	bl	a8d0 <__malloc_lock>
    9ff0:	4a1f      	ldr	r2, [pc, #124]	; (a070 <_free_r+0x98>)
    9ff2:	6813      	ldr	r3, [r2, #0]
    9ff4:	4610      	mov	r0, r2
    9ff6:	b933      	cbnz	r3, a006 <_free_r+0x2e>
    9ff8:	6063      	str	r3, [r4, #4]
    9ffa:	6014      	str	r4, [r2, #0]
    9ffc:	4628      	mov	r0, r5
    9ffe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    a002:	f000 bc66 	b.w	a8d2 <__malloc_unlock>
    a006:	42a3      	cmp	r3, r4
    a008:	d90c      	bls.n	a024 <_free_r+0x4c>
    a00a:	6821      	ldr	r1, [r4, #0]
    a00c:	1862      	adds	r2, r4, r1
    a00e:	4293      	cmp	r3, r2
    a010:	bf04      	itt	eq
    a012:	681a      	ldreq	r2, [r3, #0]
    a014:	685b      	ldreq	r3, [r3, #4]
    a016:	6063      	str	r3, [r4, #4]
    a018:	bf04      	itt	eq
    a01a:	1852      	addeq	r2, r2, r1
    a01c:	6022      	streq	r2, [r4, #0]
    a01e:	6004      	str	r4, [r0, #0]
    a020:	e7ec      	b.n	9ffc <_free_r+0x24>
    a022:	4613      	mov	r3, r2
    a024:	685a      	ldr	r2, [r3, #4]
    a026:	b10a      	cbz	r2, a02c <_free_r+0x54>
    a028:	42a2      	cmp	r2, r4
    a02a:	d9fa      	bls.n	a022 <_free_r+0x4a>
    a02c:	6819      	ldr	r1, [r3, #0]
    a02e:	1858      	adds	r0, r3, r1
    a030:	42a0      	cmp	r0, r4
    a032:	d10b      	bne.n	a04c <_free_r+0x74>
    a034:	6820      	ldr	r0, [r4, #0]
    a036:	4401      	add	r1, r0
    a038:	1858      	adds	r0, r3, r1
    a03a:	4282      	cmp	r2, r0
    a03c:	6019      	str	r1, [r3, #0]
    a03e:	d1dd      	bne.n	9ffc <_free_r+0x24>
    a040:	6810      	ldr	r0, [r2, #0]
    a042:	6852      	ldr	r2, [r2, #4]
    a044:	605a      	str	r2, [r3, #4]
    a046:	4401      	add	r1, r0
    a048:	6019      	str	r1, [r3, #0]
    a04a:	e7d7      	b.n	9ffc <_free_r+0x24>
    a04c:	d902      	bls.n	a054 <_free_r+0x7c>
    a04e:	230c      	movs	r3, #12
    a050:	602b      	str	r3, [r5, #0]
    a052:	e7d3      	b.n	9ffc <_free_r+0x24>
    a054:	6820      	ldr	r0, [r4, #0]
    a056:	1821      	adds	r1, r4, r0
    a058:	428a      	cmp	r2, r1
    a05a:	bf04      	itt	eq
    a05c:	6811      	ldreq	r1, [r2, #0]
    a05e:	6852      	ldreq	r2, [r2, #4]
    a060:	6062      	str	r2, [r4, #4]
    a062:	bf04      	itt	eq
    a064:	1809      	addeq	r1, r1, r0
    a066:	6021      	streq	r1, [r4, #0]
    a068:	605c      	str	r4, [r3, #4]
    a06a:	e7c7      	b.n	9ffc <_free_r+0x24>
    a06c:	bd38      	pop	{r3, r4, r5, pc}
    a06e:	bf00      	nop
    a070:	200081e0 	.word	0x200081e0

0000a074 <_malloc_r>:
    a074:	b570      	push	{r4, r5, r6, lr}
    a076:	1ccd      	adds	r5, r1, #3
    a078:	f025 0503 	bic.w	r5, r5, #3
    a07c:	3508      	adds	r5, #8
    a07e:	2d0c      	cmp	r5, #12
    a080:	bf38      	it	cc
    a082:	250c      	movcc	r5, #12
    a084:	2d00      	cmp	r5, #0
    a086:	4606      	mov	r6, r0
    a088:	db01      	blt.n	a08e <_malloc_r+0x1a>
    a08a:	42a9      	cmp	r1, r5
    a08c:	d903      	bls.n	a096 <_malloc_r+0x22>
    a08e:	230c      	movs	r3, #12
    a090:	6033      	str	r3, [r6, #0]
    a092:	2000      	movs	r0, #0
    a094:	bd70      	pop	{r4, r5, r6, pc}
    a096:	f000 fc1b 	bl	a8d0 <__malloc_lock>
    a09a:	4a23      	ldr	r2, [pc, #140]	; (a128 <_malloc_r+0xb4>)
    a09c:	6814      	ldr	r4, [r2, #0]
    a09e:	4621      	mov	r1, r4
    a0a0:	b991      	cbnz	r1, a0c8 <_malloc_r+0x54>
    a0a2:	4c22      	ldr	r4, [pc, #136]	; (a12c <_malloc_r+0xb8>)
    a0a4:	6823      	ldr	r3, [r4, #0]
    a0a6:	b91b      	cbnz	r3, a0b0 <_malloc_r+0x3c>
    a0a8:	4630      	mov	r0, r6
    a0aa:	f000 fb15 	bl	a6d8 <_sbrk_r>
    a0ae:	6020      	str	r0, [r4, #0]
    a0b0:	4629      	mov	r1, r5
    a0b2:	4630      	mov	r0, r6
    a0b4:	f000 fb10 	bl	a6d8 <_sbrk_r>
    a0b8:	1c43      	adds	r3, r0, #1
    a0ba:	d126      	bne.n	a10a <_malloc_r+0x96>
    a0bc:	230c      	movs	r3, #12
    a0be:	6033      	str	r3, [r6, #0]
    a0c0:	4630      	mov	r0, r6
    a0c2:	f000 fc06 	bl	a8d2 <__malloc_unlock>
    a0c6:	e7e4      	b.n	a092 <_malloc_r+0x1e>
    a0c8:	680b      	ldr	r3, [r1, #0]
    a0ca:	1b5b      	subs	r3, r3, r5
    a0cc:	d41a      	bmi.n	a104 <_malloc_r+0x90>
    a0ce:	2b0b      	cmp	r3, #11
    a0d0:	d90f      	bls.n	a0f2 <_malloc_r+0x7e>
    a0d2:	600b      	str	r3, [r1, #0]
    a0d4:	50cd      	str	r5, [r1, r3]
    a0d6:	18cc      	adds	r4, r1, r3
    a0d8:	4630      	mov	r0, r6
    a0da:	f000 fbfa 	bl	a8d2 <__malloc_unlock>
    a0de:	f104 000b 	add.w	r0, r4, #11
    a0e2:	1d23      	adds	r3, r4, #4
    a0e4:	f020 0007 	bic.w	r0, r0, #7
    a0e8:	1ac3      	subs	r3, r0, r3
    a0ea:	d01b      	beq.n	a124 <_malloc_r+0xb0>
    a0ec:	425a      	negs	r2, r3
    a0ee:	50e2      	str	r2, [r4, r3]
    a0f0:	bd70      	pop	{r4, r5, r6, pc}
    a0f2:	428c      	cmp	r4, r1
    a0f4:	bf0d      	iteet	eq
    a0f6:	6863      	ldreq	r3, [r4, #4]
    a0f8:	684b      	ldrne	r3, [r1, #4]
    a0fa:	6063      	strne	r3, [r4, #4]
    a0fc:	6013      	streq	r3, [r2, #0]
    a0fe:	bf18      	it	ne
    a100:	460c      	movne	r4, r1
    a102:	e7e9      	b.n	a0d8 <_malloc_r+0x64>
    a104:	460c      	mov	r4, r1
    a106:	6849      	ldr	r1, [r1, #4]
    a108:	e7ca      	b.n	a0a0 <_malloc_r+0x2c>
    a10a:	1cc4      	adds	r4, r0, #3
    a10c:	f024 0403 	bic.w	r4, r4, #3
    a110:	42a0      	cmp	r0, r4
    a112:	d005      	beq.n	a120 <_malloc_r+0xac>
    a114:	1a21      	subs	r1, r4, r0
    a116:	4630      	mov	r0, r6
    a118:	f000 fade 	bl	a6d8 <_sbrk_r>
    a11c:	3001      	adds	r0, #1
    a11e:	d0cd      	beq.n	a0bc <_malloc_r+0x48>
    a120:	6025      	str	r5, [r4, #0]
    a122:	e7d9      	b.n	a0d8 <_malloc_r+0x64>
    a124:	bd70      	pop	{r4, r5, r6, pc}
    a126:	bf00      	nop
    a128:	200081e0 	.word	0x200081e0
    a12c:	200081e4 	.word	0x200081e4

0000a130 <__sfputc_r>:
    a130:	6893      	ldr	r3, [r2, #8]
    a132:	3b01      	subs	r3, #1
    a134:	2b00      	cmp	r3, #0
    a136:	b410      	push	{r4}
    a138:	6093      	str	r3, [r2, #8]
    a13a:	da08      	bge.n	a14e <__sfputc_r+0x1e>
    a13c:	6994      	ldr	r4, [r2, #24]
    a13e:	42a3      	cmp	r3, r4
    a140:	db02      	blt.n	a148 <__sfputc_r+0x18>
    a142:	b2cb      	uxtb	r3, r1
    a144:	2b0a      	cmp	r3, #10
    a146:	d102      	bne.n	a14e <__sfputc_r+0x1e>
    a148:	bc10      	pop	{r4}
    a14a:	f7ff bc9d 	b.w	9a88 <__swbuf_r>
    a14e:	6813      	ldr	r3, [r2, #0]
    a150:	1c58      	adds	r0, r3, #1
    a152:	6010      	str	r0, [r2, #0]
    a154:	7019      	strb	r1, [r3, #0]
    a156:	b2c8      	uxtb	r0, r1
    a158:	bc10      	pop	{r4}
    a15a:	4770      	bx	lr

0000a15c <__sfputs_r>:
    a15c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a15e:	4606      	mov	r6, r0
    a160:	460f      	mov	r7, r1
    a162:	4614      	mov	r4, r2
    a164:	18d5      	adds	r5, r2, r3
    a166:	42ac      	cmp	r4, r5
    a168:	d101      	bne.n	a16e <__sfputs_r+0x12>
    a16a:	2000      	movs	r0, #0
    a16c:	e007      	b.n	a17e <__sfputs_r+0x22>
    a16e:	463a      	mov	r2, r7
    a170:	f814 1b01 	ldrb.w	r1, [r4], #1
    a174:	4630      	mov	r0, r6
    a176:	f7ff ffdb 	bl	a130 <__sfputc_r>
    a17a:	1c43      	adds	r3, r0, #1
    a17c:	d1f3      	bne.n	a166 <__sfputs_r+0xa>
    a17e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000a180 <_vfiprintf_r>:
    a180:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a184:	b09d      	sub	sp, #116	; 0x74
    a186:	460c      	mov	r4, r1
    a188:	4617      	mov	r7, r2
    a18a:	9303      	str	r3, [sp, #12]
    a18c:	4606      	mov	r6, r0
    a18e:	b118      	cbz	r0, a198 <_vfiprintf_r+0x18>
    a190:	6983      	ldr	r3, [r0, #24]
    a192:	b90b      	cbnz	r3, a198 <_vfiprintf_r+0x18>
    a194:	f7ff fe2a 	bl	9dec <__sinit>
    a198:	4b7c      	ldr	r3, [pc, #496]	; (a38c <_vfiprintf_r+0x20c>)
    a19a:	429c      	cmp	r4, r3
    a19c:	d157      	bne.n	a24e <_vfiprintf_r+0xce>
    a19e:	6874      	ldr	r4, [r6, #4]
    a1a0:	89a3      	ldrh	r3, [r4, #12]
    a1a2:	0718      	lsls	r0, r3, #28
    a1a4:	d55d      	bpl.n	a262 <_vfiprintf_r+0xe2>
    a1a6:	6923      	ldr	r3, [r4, #16]
    a1a8:	2b00      	cmp	r3, #0
    a1aa:	d05a      	beq.n	a262 <_vfiprintf_r+0xe2>
    a1ac:	2300      	movs	r3, #0
    a1ae:	9309      	str	r3, [sp, #36]	; 0x24
    a1b0:	2320      	movs	r3, #32
    a1b2:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    a1b6:	2330      	movs	r3, #48	; 0x30
    a1b8:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    a1bc:	f04f 0b01 	mov.w	fp, #1
    a1c0:	46b8      	mov	r8, r7
    a1c2:	4645      	mov	r5, r8
    a1c4:	f815 3b01 	ldrb.w	r3, [r5], #1
    a1c8:	2b00      	cmp	r3, #0
    a1ca:	d155      	bne.n	a278 <_vfiprintf_r+0xf8>
    a1cc:	ebb8 0a07 	subs.w	sl, r8, r7
    a1d0:	d00b      	beq.n	a1ea <_vfiprintf_r+0x6a>
    a1d2:	4653      	mov	r3, sl
    a1d4:	463a      	mov	r2, r7
    a1d6:	4621      	mov	r1, r4
    a1d8:	4630      	mov	r0, r6
    a1da:	f7ff ffbf 	bl	a15c <__sfputs_r>
    a1de:	3001      	adds	r0, #1
    a1e0:	f000 80c4 	beq.w	a36c <_vfiprintf_r+0x1ec>
    a1e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a1e6:	4453      	add	r3, sl
    a1e8:	9309      	str	r3, [sp, #36]	; 0x24
    a1ea:	f898 3000 	ldrb.w	r3, [r8]
    a1ee:	2b00      	cmp	r3, #0
    a1f0:	f000 80bc 	beq.w	a36c <_vfiprintf_r+0x1ec>
    a1f4:	2300      	movs	r3, #0
    a1f6:	f04f 32ff 	mov.w	r2, #4294967295
    a1fa:	9304      	str	r3, [sp, #16]
    a1fc:	9307      	str	r3, [sp, #28]
    a1fe:	9205      	str	r2, [sp, #20]
    a200:	9306      	str	r3, [sp, #24]
    a202:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    a206:	931a      	str	r3, [sp, #104]	; 0x68
    a208:	2205      	movs	r2, #5
    a20a:	7829      	ldrb	r1, [r5, #0]
    a20c:	4860      	ldr	r0, [pc, #384]	; (a390 <_vfiprintf_r+0x210>)
    a20e:	f000 fb0f 	bl	a830 <memchr>
    a212:	f105 0801 	add.w	r8, r5, #1
    a216:	9b04      	ldr	r3, [sp, #16]
    a218:	2800      	cmp	r0, #0
    a21a:	d131      	bne.n	a280 <_vfiprintf_r+0x100>
    a21c:	06d9      	lsls	r1, r3, #27
    a21e:	bf44      	itt	mi
    a220:	2220      	movmi	r2, #32
    a222:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    a226:	071a      	lsls	r2, r3, #28
    a228:	bf44      	itt	mi
    a22a:	222b      	movmi	r2, #43	; 0x2b
    a22c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    a230:	782a      	ldrb	r2, [r5, #0]
    a232:	2a2a      	cmp	r2, #42	; 0x2a
    a234:	d02c      	beq.n	a290 <_vfiprintf_r+0x110>
    a236:	9a07      	ldr	r2, [sp, #28]
    a238:	2100      	movs	r1, #0
    a23a:	200a      	movs	r0, #10
    a23c:	46a8      	mov	r8, r5
    a23e:	3501      	adds	r5, #1
    a240:	f898 3000 	ldrb.w	r3, [r8]
    a244:	3b30      	subs	r3, #48	; 0x30
    a246:	2b09      	cmp	r3, #9
    a248:	d96d      	bls.n	a326 <_vfiprintf_r+0x1a6>
    a24a:	b371      	cbz	r1, a2aa <_vfiprintf_r+0x12a>
    a24c:	e026      	b.n	a29c <_vfiprintf_r+0x11c>
    a24e:	4b51      	ldr	r3, [pc, #324]	; (a394 <_vfiprintf_r+0x214>)
    a250:	429c      	cmp	r4, r3
    a252:	d101      	bne.n	a258 <_vfiprintf_r+0xd8>
    a254:	68b4      	ldr	r4, [r6, #8]
    a256:	e7a3      	b.n	a1a0 <_vfiprintf_r+0x20>
    a258:	4b4f      	ldr	r3, [pc, #316]	; (a398 <_vfiprintf_r+0x218>)
    a25a:	429c      	cmp	r4, r3
    a25c:	bf08      	it	eq
    a25e:	68f4      	ldreq	r4, [r6, #12]
    a260:	e79e      	b.n	a1a0 <_vfiprintf_r+0x20>
    a262:	4621      	mov	r1, r4
    a264:	4630      	mov	r0, r6
    a266:	f7ff fc61 	bl	9b2c <__swsetup_r>
    a26a:	2800      	cmp	r0, #0
    a26c:	d09e      	beq.n	a1ac <_vfiprintf_r+0x2c>
    a26e:	f04f 30ff 	mov.w	r0, #4294967295
    a272:	b01d      	add	sp, #116	; 0x74
    a274:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a278:	2b25      	cmp	r3, #37	; 0x25
    a27a:	d0a7      	beq.n	a1cc <_vfiprintf_r+0x4c>
    a27c:	46a8      	mov	r8, r5
    a27e:	e7a0      	b.n	a1c2 <_vfiprintf_r+0x42>
    a280:	4a43      	ldr	r2, [pc, #268]	; (a390 <_vfiprintf_r+0x210>)
    a282:	1a80      	subs	r0, r0, r2
    a284:	fa0b f000 	lsl.w	r0, fp, r0
    a288:	4318      	orrs	r0, r3
    a28a:	9004      	str	r0, [sp, #16]
    a28c:	4645      	mov	r5, r8
    a28e:	e7bb      	b.n	a208 <_vfiprintf_r+0x88>
    a290:	9a03      	ldr	r2, [sp, #12]
    a292:	1d11      	adds	r1, r2, #4
    a294:	6812      	ldr	r2, [r2, #0]
    a296:	9103      	str	r1, [sp, #12]
    a298:	2a00      	cmp	r2, #0
    a29a:	db01      	blt.n	a2a0 <_vfiprintf_r+0x120>
    a29c:	9207      	str	r2, [sp, #28]
    a29e:	e004      	b.n	a2aa <_vfiprintf_r+0x12a>
    a2a0:	4252      	negs	r2, r2
    a2a2:	f043 0302 	orr.w	r3, r3, #2
    a2a6:	9207      	str	r2, [sp, #28]
    a2a8:	9304      	str	r3, [sp, #16]
    a2aa:	f898 3000 	ldrb.w	r3, [r8]
    a2ae:	2b2e      	cmp	r3, #46	; 0x2e
    a2b0:	d110      	bne.n	a2d4 <_vfiprintf_r+0x154>
    a2b2:	f898 3001 	ldrb.w	r3, [r8, #1]
    a2b6:	2b2a      	cmp	r3, #42	; 0x2a
    a2b8:	f108 0101 	add.w	r1, r8, #1
    a2bc:	d137      	bne.n	a32e <_vfiprintf_r+0x1ae>
    a2be:	9b03      	ldr	r3, [sp, #12]
    a2c0:	1d1a      	adds	r2, r3, #4
    a2c2:	681b      	ldr	r3, [r3, #0]
    a2c4:	9203      	str	r2, [sp, #12]
    a2c6:	2b00      	cmp	r3, #0
    a2c8:	bfb8      	it	lt
    a2ca:	f04f 33ff 	movlt.w	r3, #4294967295
    a2ce:	f108 0802 	add.w	r8, r8, #2
    a2d2:	9305      	str	r3, [sp, #20]
    a2d4:	4d31      	ldr	r5, [pc, #196]	; (a39c <_vfiprintf_r+0x21c>)
    a2d6:	f898 1000 	ldrb.w	r1, [r8]
    a2da:	2203      	movs	r2, #3
    a2dc:	4628      	mov	r0, r5
    a2de:	f000 faa7 	bl	a830 <memchr>
    a2e2:	b140      	cbz	r0, a2f6 <_vfiprintf_r+0x176>
    a2e4:	2340      	movs	r3, #64	; 0x40
    a2e6:	1b40      	subs	r0, r0, r5
    a2e8:	fa03 f000 	lsl.w	r0, r3, r0
    a2ec:	9b04      	ldr	r3, [sp, #16]
    a2ee:	4303      	orrs	r3, r0
    a2f0:	9304      	str	r3, [sp, #16]
    a2f2:	f108 0801 	add.w	r8, r8, #1
    a2f6:	f898 1000 	ldrb.w	r1, [r8]
    a2fa:	4829      	ldr	r0, [pc, #164]	; (a3a0 <_vfiprintf_r+0x220>)
    a2fc:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    a300:	2206      	movs	r2, #6
    a302:	f108 0701 	add.w	r7, r8, #1
    a306:	f000 fa93 	bl	a830 <memchr>
    a30a:	2800      	cmp	r0, #0
    a30c:	d034      	beq.n	a378 <_vfiprintf_r+0x1f8>
    a30e:	4b25      	ldr	r3, [pc, #148]	; (a3a4 <_vfiprintf_r+0x224>)
    a310:	bb03      	cbnz	r3, a354 <_vfiprintf_r+0x1d4>
    a312:	9b03      	ldr	r3, [sp, #12]
    a314:	3307      	adds	r3, #7
    a316:	f023 0307 	bic.w	r3, r3, #7
    a31a:	3308      	adds	r3, #8
    a31c:	9303      	str	r3, [sp, #12]
    a31e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a320:	444b      	add	r3, r9
    a322:	9309      	str	r3, [sp, #36]	; 0x24
    a324:	e74c      	b.n	a1c0 <_vfiprintf_r+0x40>
    a326:	fb00 3202 	mla	r2, r0, r2, r3
    a32a:	2101      	movs	r1, #1
    a32c:	e786      	b.n	a23c <_vfiprintf_r+0xbc>
    a32e:	2300      	movs	r3, #0
    a330:	9305      	str	r3, [sp, #20]
    a332:	4618      	mov	r0, r3
    a334:	250a      	movs	r5, #10
    a336:	4688      	mov	r8, r1
    a338:	3101      	adds	r1, #1
    a33a:	f898 2000 	ldrb.w	r2, [r8]
    a33e:	3a30      	subs	r2, #48	; 0x30
    a340:	2a09      	cmp	r2, #9
    a342:	d903      	bls.n	a34c <_vfiprintf_r+0x1cc>
    a344:	2b00      	cmp	r3, #0
    a346:	d0c5      	beq.n	a2d4 <_vfiprintf_r+0x154>
    a348:	9005      	str	r0, [sp, #20]
    a34a:	e7c3      	b.n	a2d4 <_vfiprintf_r+0x154>
    a34c:	fb05 2000 	mla	r0, r5, r0, r2
    a350:	2301      	movs	r3, #1
    a352:	e7f0      	b.n	a336 <_vfiprintf_r+0x1b6>
    a354:	ab03      	add	r3, sp, #12
    a356:	9300      	str	r3, [sp, #0]
    a358:	4622      	mov	r2, r4
    a35a:	4b13      	ldr	r3, [pc, #76]	; (a3a8 <_vfiprintf_r+0x228>)
    a35c:	a904      	add	r1, sp, #16
    a35e:	4630      	mov	r0, r6
    a360:	f3af 8000 	nop.w
    a364:	f1b0 3fff 	cmp.w	r0, #4294967295
    a368:	4681      	mov	r9, r0
    a36a:	d1d8      	bne.n	a31e <_vfiprintf_r+0x19e>
    a36c:	89a3      	ldrh	r3, [r4, #12]
    a36e:	065b      	lsls	r3, r3, #25
    a370:	f53f af7d 	bmi.w	a26e <_vfiprintf_r+0xee>
    a374:	9809      	ldr	r0, [sp, #36]	; 0x24
    a376:	e77c      	b.n	a272 <_vfiprintf_r+0xf2>
    a378:	ab03      	add	r3, sp, #12
    a37a:	9300      	str	r3, [sp, #0]
    a37c:	4622      	mov	r2, r4
    a37e:	4b0a      	ldr	r3, [pc, #40]	; (a3a8 <_vfiprintf_r+0x228>)
    a380:	a904      	add	r1, sp, #16
    a382:	4630      	mov	r0, r6
    a384:	f000 f888 	bl	a498 <_printf_i>
    a388:	e7ec      	b.n	a364 <_vfiprintf_r+0x1e4>
    a38a:	bf00      	nop
    a38c:	0000bf9c 	.word	0x0000bf9c
    a390:	0000bfdc 	.word	0x0000bfdc
    a394:	0000bfbc 	.word	0x0000bfbc
    a398:	0000bf7c 	.word	0x0000bf7c
    a39c:	0000bfe2 	.word	0x0000bfe2
    a3a0:	0000bfe6 	.word	0x0000bfe6
    a3a4:	00000000 	.word	0x00000000
    a3a8:	0000a15d 	.word	0x0000a15d

0000a3ac <_printf_common>:
    a3ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a3b0:	4691      	mov	r9, r2
    a3b2:	461f      	mov	r7, r3
    a3b4:	688a      	ldr	r2, [r1, #8]
    a3b6:	690b      	ldr	r3, [r1, #16]
    a3b8:	f8dd 8020 	ldr.w	r8, [sp, #32]
    a3bc:	4293      	cmp	r3, r2
    a3be:	bfb8      	it	lt
    a3c0:	4613      	movlt	r3, r2
    a3c2:	f8c9 3000 	str.w	r3, [r9]
    a3c6:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
    a3ca:	4606      	mov	r6, r0
    a3cc:	460c      	mov	r4, r1
    a3ce:	b112      	cbz	r2, a3d6 <_printf_common+0x2a>
    a3d0:	3301      	adds	r3, #1
    a3d2:	f8c9 3000 	str.w	r3, [r9]
    a3d6:	6823      	ldr	r3, [r4, #0]
    a3d8:	0699      	lsls	r1, r3, #26
    a3da:	bf42      	ittt	mi
    a3dc:	f8d9 3000 	ldrmi.w	r3, [r9]
    a3e0:	3302      	addmi	r3, #2
    a3e2:	f8c9 3000 	strmi.w	r3, [r9]
    a3e6:	6825      	ldr	r5, [r4, #0]
    a3e8:	f015 0506 	ands.w	r5, r5, #6
    a3ec:	d107      	bne.n	a3fe <_printf_common+0x52>
    a3ee:	f104 0a19 	add.w	sl, r4, #25
    a3f2:	68e3      	ldr	r3, [r4, #12]
    a3f4:	f8d9 2000 	ldr.w	r2, [r9]
    a3f8:	1a9b      	subs	r3, r3, r2
    a3fa:	429d      	cmp	r5, r3
    a3fc:	db29      	blt.n	a452 <_printf_common+0xa6>
    a3fe:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    a402:	6822      	ldr	r2, [r4, #0]
    a404:	3300      	adds	r3, #0
    a406:	bf18      	it	ne
    a408:	2301      	movne	r3, #1
    a40a:	0692      	lsls	r2, r2, #26
    a40c:	d42e      	bmi.n	a46c <_printf_common+0xc0>
    a40e:	f104 0243 	add.w	r2, r4, #67	; 0x43
    a412:	4639      	mov	r1, r7
    a414:	4630      	mov	r0, r6
    a416:	47c0      	blx	r8
    a418:	3001      	adds	r0, #1
    a41a:	d021      	beq.n	a460 <_printf_common+0xb4>
    a41c:	6823      	ldr	r3, [r4, #0]
    a41e:	68e5      	ldr	r5, [r4, #12]
    a420:	f8d9 2000 	ldr.w	r2, [r9]
    a424:	f003 0306 	and.w	r3, r3, #6
    a428:	2b04      	cmp	r3, #4
    a42a:	bf08      	it	eq
    a42c:	1aad      	subeq	r5, r5, r2
    a42e:	68a3      	ldr	r3, [r4, #8]
    a430:	6922      	ldr	r2, [r4, #16]
    a432:	bf0c      	ite	eq
    a434:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
    a438:	2500      	movne	r5, #0
    a43a:	4293      	cmp	r3, r2
    a43c:	bfc4      	itt	gt
    a43e:	1a9b      	subgt	r3, r3, r2
    a440:	18ed      	addgt	r5, r5, r3
    a442:	f04f 0900 	mov.w	r9, #0
    a446:	341a      	adds	r4, #26
    a448:	454d      	cmp	r5, r9
    a44a:	d11b      	bne.n	a484 <_printf_common+0xd8>
    a44c:	2000      	movs	r0, #0
    a44e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a452:	2301      	movs	r3, #1
    a454:	4652      	mov	r2, sl
    a456:	4639      	mov	r1, r7
    a458:	4630      	mov	r0, r6
    a45a:	47c0      	blx	r8
    a45c:	3001      	adds	r0, #1
    a45e:	d103      	bne.n	a468 <_printf_common+0xbc>
    a460:	f04f 30ff 	mov.w	r0, #4294967295
    a464:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a468:	3501      	adds	r5, #1
    a46a:	e7c2      	b.n	a3f2 <_printf_common+0x46>
    a46c:	18e1      	adds	r1, r4, r3
    a46e:	1c5a      	adds	r2, r3, #1
    a470:	2030      	movs	r0, #48	; 0x30
    a472:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
    a476:	4422      	add	r2, r4
    a478:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
    a47c:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
    a480:	3302      	adds	r3, #2
    a482:	e7c4      	b.n	a40e <_printf_common+0x62>
    a484:	2301      	movs	r3, #1
    a486:	4622      	mov	r2, r4
    a488:	4639      	mov	r1, r7
    a48a:	4630      	mov	r0, r6
    a48c:	47c0      	blx	r8
    a48e:	3001      	adds	r0, #1
    a490:	d0e6      	beq.n	a460 <_printf_common+0xb4>
    a492:	f109 0901 	add.w	r9, r9, #1
    a496:	e7d7      	b.n	a448 <_printf_common+0x9c>

0000a498 <_printf_i>:
    a498:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    a49c:	4617      	mov	r7, r2
    a49e:	7e0a      	ldrb	r2, [r1, #24]
    a4a0:	b085      	sub	sp, #20
    a4a2:	2a6e      	cmp	r2, #110	; 0x6e
    a4a4:	4698      	mov	r8, r3
    a4a6:	4606      	mov	r6, r0
    a4a8:	460c      	mov	r4, r1
    a4aa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    a4ac:	f101 0e43 	add.w	lr, r1, #67	; 0x43
    a4b0:	f000 80bc 	beq.w	a62c <_printf_i+0x194>
    a4b4:	d81a      	bhi.n	a4ec <_printf_i+0x54>
    a4b6:	2a63      	cmp	r2, #99	; 0x63
    a4b8:	d02e      	beq.n	a518 <_printf_i+0x80>
    a4ba:	d80a      	bhi.n	a4d2 <_printf_i+0x3a>
    a4bc:	2a00      	cmp	r2, #0
    a4be:	f000 80c8 	beq.w	a652 <_printf_i+0x1ba>
    a4c2:	2a58      	cmp	r2, #88	; 0x58
    a4c4:	f000 808a 	beq.w	a5dc <_printf_i+0x144>
    a4c8:	f104 0542 	add.w	r5, r4, #66	; 0x42
    a4cc:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
    a4d0:	e02a      	b.n	a528 <_printf_i+0x90>
    a4d2:	2a64      	cmp	r2, #100	; 0x64
    a4d4:	d001      	beq.n	a4da <_printf_i+0x42>
    a4d6:	2a69      	cmp	r2, #105	; 0x69
    a4d8:	d1f6      	bne.n	a4c8 <_printf_i+0x30>
    a4da:	6821      	ldr	r1, [r4, #0]
    a4dc:	681a      	ldr	r2, [r3, #0]
    a4de:	f011 0f80 	tst.w	r1, #128	; 0x80
    a4e2:	d023      	beq.n	a52c <_printf_i+0x94>
    a4e4:	1d11      	adds	r1, r2, #4
    a4e6:	6019      	str	r1, [r3, #0]
    a4e8:	6813      	ldr	r3, [r2, #0]
    a4ea:	e027      	b.n	a53c <_printf_i+0xa4>
    a4ec:	2a73      	cmp	r2, #115	; 0x73
    a4ee:	f000 80b4 	beq.w	a65a <_printf_i+0x1c2>
    a4f2:	d808      	bhi.n	a506 <_printf_i+0x6e>
    a4f4:	2a6f      	cmp	r2, #111	; 0x6f
    a4f6:	d02a      	beq.n	a54e <_printf_i+0xb6>
    a4f8:	2a70      	cmp	r2, #112	; 0x70
    a4fa:	d1e5      	bne.n	a4c8 <_printf_i+0x30>
    a4fc:	680a      	ldr	r2, [r1, #0]
    a4fe:	f042 0220 	orr.w	r2, r2, #32
    a502:	600a      	str	r2, [r1, #0]
    a504:	e003      	b.n	a50e <_printf_i+0x76>
    a506:	2a75      	cmp	r2, #117	; 0x75
    a508:	d021      	beq.n	a54e <_printf_i+0xb6>
    a50a:	2a78      	cmp	r2, #120	; 0x78
    a50c:	d1dc      	bne.n	a4c8 <_printf_i+0x30>
    a50e:	2278      	movs	r2, #120	; 0x78
    a510:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
    a514:	496e      	ldr	r1, [pc, #440]	; (a6d0 <_printf_i+0x238>)
    a516:	e064      	b.n	a5e2 <_printf_i+0x14a>
    a518:	681a      	ldr	r2, [r3, #0]
    a51a:	f101 0542 	add.w	r5, r1, #66	; 0x42
    a51e:	1d11      	adds	r1, r2, #4
    a520:	6019      	str	r1, [r3, #0]
    a522:	6813      	ldr	r3, [r2, #0]
    a524:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    a528:	2301      	movs	r3, #1
    a52a:	e0a3      	b.n	a674 <_printf_i+0x1dc>
    a52c:	f011 0f40 	tst.w	r1, #64	; 0x40
    a530:	f102 0104 	add.w	r1, r2, #4
    a534:	6019      	str	r1, [r3, #0]
    a536:	d0d7      	beq.n	a4e8 <_printf_i+0x50>
    a538:	f9b2 3000 	ldrsh.w	r3, [r2]
    a53c:	2b00      	cmp	r3, #0
    a53e:	da03      	bge.n	a548 <_printf_i+0xb0>
    a540:	222d      	movs	r2, #45	; 0x2d
    a542:	425b      	negs	r3, r3
    a544:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
    a548:	4962      	ldr	r1, [pc, #392]	; (a6d4 <_printf_i+0x23c>)
    a54a:	220a      	movs	r2, #10
    a54c:	e017      	b.n	a57e <_printf_i+0xe6>
    a54e:	6820      	ldr	r0, [r4, #0]
    a550:	6819      	ldr	r1, [r3, #0]
    a552:	f010 0f80 	tst.w	r0, #128	; 0x80
    a556:	d003      	beq.n	a560 <_printf_i+0xc8>
    a558:	1d08      	adds	r0, r1, #4
    a55a:	6018      	str	r0, [r3, #0]
    a55c:	680b      	ldr	r3, [r1, #0]
    a55e:	e006      	b.n	a56e <_printf_i+0xd6>
    a560:	f010 0f40 	tst.w	r0, #64	; 0x40
    a564:	f101 0004 	add.w	r0, r1, #4
    a568:	6018      	str	r0, [r3, #0]
    a56a:	d0f7      	beq.n	a55c <_printf_i+0xc4>
    a56c:	880b      	ldrh	r3, [r1, #0]
    a56e:	4959      	ldr	r1, [pc, #356]	; (a6d4 <_printf_i+0x23c>)
    a570:	2a6f      	cmp	r2, #111	; 0x6f
    a572:	bf14      	ite	ne
    a574:	220a      	movne	r2, #10
    a576:	2208      	moveq	r2, #8
    a578:	2000      	movs	r0, #0
    a57a:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
    a57e:	6865      	ldr	r5, [r4, #4]
    a580:	60a5      	str	r5, [r4, #8]
    a582:	2d00      	cmp	r5, #0
    a584:	f2c0 809c 	blt.w	a6c0 <_printf_i+0x228>
    a588:	6820      	ldr	r0, [r4, #0]
    a58a:	f020 0004 	bic.w	r0, r0, #4
    a58e:	6020      	str	r0, [r4, #0]
    a590:	2b00      	cmp	r3, #0
    a592:	d13f      	bne.n	a614 <_printf_i+0x17c>
    a594:	2d00      	cmp	r5, #0
    a596:	f040 8095 	bne.w	a6c4 <_printf_i+0x22c>
    a59a:	4675      	mov	r5, lr
    a59c:	2a08      	cmp	r2, #8
    a59e:	d10b      	bne.n	a5b8 <_printf_i+0x120>
    a5a0:	6823      	ldr	r3, [r4, #0]
    a5a2:	07da      	lsls	r2, r3, #31
    a5a4:	d508      	bpl.n	a5b8 <_printf_i+0x120>
    a5a6:	6923      	ldr	r3, [r4, #16]
    a5a8:	6862      	ldr	r2, [r4, #4]
    a5aa:	429a      	cmp	r2, r3
    a5ac:	bfde      	ittt	le
    a5ae:	2330      	movle	r3, #48	; 0x30
    a5b0:	f805 3c01 	strble.w	r3, [r5, #-1]
    a5b4:	f105 35ff 	addle.w	r5, r5, #4294967295
    a5b8:	ebae 0305 	sub.w	r3, lr, r5
    a5bc:	6123      	str	r3, [r4, #16]
    a5be:	f8cd 8000 	str.w	r8, [sp]
    a5c2:	463b      	mov	r3, r7
    a5c4:	aa03      	add	r2, sp, #12
    a5c6:	4621      	mov	r1, r4
    a5c8:	4630      	mov	r0, r6
    a5ca:	f7ff feef 	bl	a3ac <_printf_common>
    a5ce:	3001      	adds	r0, #1
    a5d0:	d155      	bne.n	a67e <_printf_i+0x1e6>
    a5d2:	f04f 30ff 	mov.w	r0, #4294967295
    a5d6:	b005      	add	sp, #20
    a5d8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    a5dc:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
    a5e0:	493c      	ldr	r1, [pc, #240]	; (a6d4 <_printf_i+0x23c>)
    a5e2:	6822      	ldr	r2, [r4, #0]
    a5e4:	6818      	ldr	r0, [r3, #0]
    a5e6:	f012 0f80 	tst.w	r2, #128	; 0x80
    a5ea:	f100 0504 	add.w	r5, r0, #4
    a5ee:	601d      	str	r5, [r3, #0]
    a5f0:	d001      	beq.n	a5f6 <_printf_i+0x15e>
    a5f2:	6803      	ldr	r3, [r0, #0]
    a5f4:	e002      	b.n	a5fc <_printf_i+0x164>
    a5f6:	0655      	lsls	r5, r2, #25
    a5f8:	d5fb      	bpl.n	a5f2 <_printf_i+0x15a>
    a5fa:	8803      	ldrh	r3, [r0, #0]
    a5fc:	07d0      	lsls	r0, r2, #31
    a5fe:	bf44      	itt	mi
    a600:	f042 0220 	orrmi.w	r2, r2, #32
    a604:	6022      	strmi	r2, [r4, #0]
    a606:	b91b      	cbnz	r3, a610 <_printf_i+0x178>
    a608:	6822      	ldr	r2, [r4, #0]
    a60a:	f022 0220 	bic.w	r2, r2, #32
    a60e:	6022      	str	r2, [r4, #0]
    a610:	2210      	movs	r2, #16
    a612:	e7b1      	b.n	a578 <_printf_i+0xe0>
    a614:	4675      	mov	r5, lr
    a616:	fbb3 f0f2 	udiv	r0, r3, r2
    a61a:	fb02 3310 	mls	r3, r2, r0, r3
    a61e:	5ccb      	ldrb	r3, [r1, r3]
    a620:	f805 3d01 	strb.w	r3, [r5, #-1]!
    a624:	4603      	mov	r3, r0
    a626:	2800      	cmp	r0, #0
    a628:	d1f5      	bne.n	a616 <_printf_i+0x17e>
    a62a:	e7b7      	b.n	a59c <_printf_i+0x104>
    a62c:	6808      	ldr	r0, [r1, #0]
    a62e:	681a      	ldr	r2, [r3, #0]
    a630:	6949      	ldr	r1, [r1, #20]
    a632:	f010 0f80 	tst.w	r0, #128	; 0x80
    a636:	d004      	beq.n	a642 <_printf_i+0x1aa>
    a638:	1d10      	adds	r0, r2, #4
    a63a:	6018      	str	r0, [r3, #0]
    a63c:	6813      	ldr	r3, [r2, #0]
    a63e:	6019      	str	r1, [r3, #0]
    a640:	e007      	b.n	a652 <_printf_i+0x1ba>
    a642:	f010 0f40 	tst.w	r0, #64	; 0x40
    a646:	f102 0004 	add.w	r0, r2, #4
    a64a:	6018      	str	r0, [r3, #0]
    a64c:	6813      	ldr	r3, [r2, #0]
    a64e:	d0f6      	beq.n	a63e <_printf_i+0x1a6>
    a650:	8019      	strh	r1, [r3, #0]
    a652:	2300      	movs	r3, #0
    a654:	6123      	str	r3, [r4, #16]
    a656:	4675      	mov	r5, lr
    a658:	e7b1      	b.n	a5be <_printf_i+0x126>
    a65a:	681a      	ldr	r2, [r3, #0]
    a65c:	1d11      	adds	r1, r2, #4
    a65e:	6019      	str	r1, [r3, #0]
    a660:	6815      	ldr	r5, [r2, #0]
    a662:	6862      	ldr	r2, [r4, #4]
    a664:	2100      	movs	r1, #0
    a666:	4628      	mov	r0, r5
    a668:	f000 f8e2 	bl	a830 <memchr>
    a66c:	b108      	cbz	r0, a672 <_printf_i+0x1da>
    a66e:	1b40      	subs	r0, r0, r5
    a670:	6060      	str	r0, [r4, #4]
    a672:	6863      	ldr	r3, [r4, #4]
    a674:	6123      	str	r3, [r4, #16]
    a676:	2300      	movs	r3, #0
    a678:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    a67c:	e79f      	b.n	a5be <_printf_i+0x126>
    a67e:	6923      	ldr	r3, [r4, #16]
    a680:	462a      	mov	r2, r5
    a682:	4639      	mov	r1, r7
    a684:	4630      	mov	r0, r6
    a686:	47c0      	blx	r8
    a688:	3001      	adds	r0, #1
    a68a:	d0a2      	beq.n	a5d2 <_printf_i+0x13a>
    a68c:	6823      	ldr	r3, [r4, #0]
    a68e:	079b      	lsls	r3, r3, #30
    a690:	d507      	bpl.n	a6a2 <_printf_i+0x20a>
    a692:	2500      	movs	r5, #0
    a694:	f104 0919 	add.w	r9, r4, #25
    a698:	68e3      	ldr	r3, [r4, #12]
    a69a:	9a03      	ldr	r2, [sp, #12]
    a69c:	1a9b      	subs	r3, r3, r2
    a69e:	429d      	cmp	r5, r3
    a6a0:	db05      	blt.n	a6ae <_printf_i+0x216>
    a6a2:	68e0      	ldr	r0, [r4, #12]
    a6a4:	9b03      	ldr	r3, [sp, #12]
    a6a6:	4298      	cmp	r0, r3
    a6a8:	bfb8      	it	lt
    a6aa:	4618      	movlt	r0, r3
    a6ac:	e793      	b.n	a5d6 <_printf_i+0x13e>
    a6ae:	2301      	movs	r3, #1
    a6b0:	464a      	mov	r2, r9
    a6b2:	4639      	mov	r1, r7
    a6b4:	4630      	mov	r0, r6
    a6b6:	47c0      	blx	r8
    a6b8:	3001      	adds	r0, #1
    a6ba:	d08a      	beq.n	a5d2 <_printf_i+0x13a>
    a6bc:	3501      	adds	r5, #1
    a6be:	e7eb      	b.n	a698 <_printf_i+0x200>
    a6c0:	2b00      	cmp	r3, #0
    a6c2:	d1a7      	bne.n	a614 <_printf_i+0x17c>
    a6c4:	780b      	ldrb	r3, [r1, #0]
    a6c6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    a6ca:	f104 0542 	add.w	r5, r4, #66	; 0x42
    a6ce:	e765      	b.n	a59c <_printf_i+0x104>
    a6d0:	0000bffe 	.word	0x0000bffe
    a6d4:	0000bfed 	.word	0x0000bfed

0000a6d8 <_sbrk_r>:
    a6d8:	b538      	push	{r3, r4, r5, lr}
    a6da:	4c06      	ldr	r4, [pc, #24]	; (a6f4 <_sbrk_r+0x1c>)
    a6dc:	2300      	movs	r3, #0
    a6de:	4605      	mov	r5, r0
    a6e0:	4608      	mov	r0, r1
    a6e2:	6023      	str	r3, [r4, #0]
    a6e4:	f7f7 f8b6 	bl	1854 <_sbrk>
    a6e8:	1c43      	adds	r3, r0, #1
    a6ea:	d102      	bne.n	a6f2 <_sbrk_r+0x1a>
    a6ec:	6823      	ldr	r3, [r4, #0]
    a6ee:	b103      	cbz	r3, a6f2 <_sbrk_r+0x1a>
    a6f0:	602b      	str	r3, [r5, #0]
    a6f2:	bd38      	pop	{r3, r4, r5, pc}
    a6f4:	200095d0 	.word	0x200095d0

0000a6f8 <__sread>:
    a6f8:	b510      	push	{r4, lr}
    a6fa:	460c      	mov	r4, r1
    a6fc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    a700:	f000 f8e8 	bl	a8d4 <_read_r>
    a704:	2800      	cmp	r0, #0
    a706:	bfab      	itete	ge
    a708:	6d63      	ldrge	r3, [r4, #84]	; 0x54
    a70a:	89a3      	ldrhlt	r3, [r4, #12]
    a70c:	181b      	addge	r3, r3, r0
    a70e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
    a712:	bfac      	ite	ge
    a714:	6563      	strge	r3, [r4, #84]	; 0x54
    a716:	81a3      	strhlt	r3, [r4, #12]
    a718:	bd10      	pop	{r4, pc}

0000a71a <__swrite>:
    a71a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a71e:	461f      	mov	r7, r3
    a720:	898b      	ldrh	r3, [r1, #12]
    a722:	05db      	lsls	r3, r3, #23
    a724:	4605      	mov	r5, r0
    a726:	460c      	mov	r4, r1
    a728:	4616      	mov	r6, r2
    a72a:	d505      	bpl.n	a738 <__swrite+0x1e>
    a72c:	2302      	movs	r3, #2
    a72e:	2200      	movs	r2, #0
    a730:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    a734:	f000 f868 	bl	a808 <_lseek_r>
    a738:	89a3      	ldrh	r3, [r4, #12]
    a73a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    a73e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    a742:	81a3      	strh	r3, [r4, #12]
    a744:	4632      	mov	r2, r6
    a746:	463b      	mov	r3, r7
    a748:	4628      	mov	r0, r5
    a74a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    a74e:	f000 b817 	b.w	a780 <_write_r>

0000a752 <__sseek>:
    a752:	b510      	push	{r4, lr}
    a754:	460c      	mov	r4, r1
    a756:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    a75a:	f000 f855 	bl	a808 <_lseek_r>
    a75e:	1c43      	adds	r3, r0, #1
    a760:	89a3      	ldrh	r3, [r4, #12]
    a762:	bf15      	itete	ne
    a764:	6560      	strne	r0, [r4, #84]	; 0x54
    a766:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    a76a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    a76e:	81a3      	strheq	r3, [r4, #12]
    a770:	bf18      	it	ne
    a772:	81a3      	strhne	r3, [r4, #12]
    a774:	bd10      	pop	{r4, pc}

0000a776 <__sclose>:
    a776:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    a77a:	f000 b813 	b.w	a7a4 <_close_r>
	...

0000a780 <_write_r>:
    a780:	b538      	push	{r3, r4, r5, lr}
    a782:	4c07      	ldr	r4, [pc, #28]	; (a7a0 <_write_r+0x20>)
    a784:	4605      	mov	r5, r0
    a786:	4608      	mov	r0, r1
    a788:	4611      	mov	r1, r2
    a78a:	2200      	movs	r2, #0
    a78c:	6022      	str	r2, [r4, #0]
    a78e:	461a      	mov	r2, r3
    a790:	f7fe ff9e 	bl	96d0 <_write>
    a794:	1c43      	adds	r3, r0, #1
    a796:	d102      	bne.n	a79e <_write_r+0x1e>
    a798:	6823      	ldr	r3, [r4, #0]
    a79a:	b103      	cbz	r3, a79e <_write_r+0x1e>
    a79c:	602b      	str	r3, [r5, #0]
    a79e:	bd38      	pop	{r3, r4, r5, pc}
    a7a0:	200095d0 	.word	0x200095d0

0000a7a4 <_close_r>:
    a7a4:	b538      	push	{r3, r4, r5, lr}
    a7a6:	4c06      	ldr	r4, [pc, #24]	; (a7c0 <_close_r+0x1c>)
    a7a8:	2300      	movs	r3, #0
    a7aa:	4605      	mov	r5, r0
    a7ac:	4608      	mov	r0, r1
    a7ae:	6023      	str	r3, [r4, #0]
    a7b0:	f7f7 f862 	bl	1878 <_close>
    a7b4:	1c43      	adds	r3, r0, #1
    a7b6:	d102      	bne.n	a7be <_close_r+0x1a>
    a7b8:	6823      	ldr	r3, [r4, #0]
    a7ba:	b103      	cbz	r3, a7be <_close_r+0x1a>
    a7bc:	602b      	str	r3, [r5, #0]
    a7be:	bd38      	pop	{r3, r4, r5, pc}
    a7c0:	200095d0 	.word	0x200095d0

0000a7c4 <_fstat_r>:
    a7c4:	b538      	push	{r3, r4, r5, lr}
    a7c6:	4c07      	ldr	r4, [pc, #28]	; (a7e4 <_fstat_r+0x20>)
    a7c8:	2300      	movs	r3, #0
    a7ca:	4605      	mov	r5, r0
    a7cc:	4608      	mov	r0, r1
    a7ce:	4611      	mov	r1, r2
    a7d0:	6023      	str	r3, [r4, #0]
    a7d2:	f7f7 f854 	bl	187e <_fstat>
    a7d6:	1c43      	adds	r3, r0, #1
    a7d8:	d102      	bne.n	a7e0 <_fstat_r+0x1c>
    a7da:	6823      	ldr	r3, [r4, #0]
    a7dc:	b103      	cbz	r3, a7e0 <_fstat_r+0x1c>
    a7de:	602b      	str	r3, [r5, #0]
    a7e0:	bd38      	pop	{r3, r4, r5, pc}
    a7e2:	bf00      	nop
    a7e4:	200095d0 	.word	0x200095d0

0000a7e8 <_isatty_r>:
    a7e8:	b538      	push	{r3, r4, r5, lr}
    a7ea:	4c06      	ldr	r4, [pc, #24]	; (a804 <_isatty_r+0x1c>)
    a7ec:	2300      	movs	r3, #0
    a7ee:	4605      	mov	r5, r0
    a7f0:	4608      	mov	r0, r1
    a7f2:	6023      	str	r3, [r4, #0]
    a7f4:	f7f7 f848 	bl	1888 <_isatty>
    a7f8:	1c43      	adds	r3, r0, #1
    a7fa:	d102      	bne.n	a802 <_isatty_r+0x1a>
    a7fc:	6823      	ldr	r3, [r4, #0]
    a7fe:	b103      	cbz	r3, a802 <_isatty_r+0x1a>
    a800:	602b      	str	r3, [r5, #0]
    a802:	bd38      	pop	{r3, r4, r5, pc}
    a804:	200095d0 	.word	0x200095d0

0000a808 <_lseek_r>:
    a808:	b538      	push	{r3, r4, r5, lr}
    a80a:	4c07      	ldr	r4, [pc, #28]	; (a828 <_lseek_r+0x20>)
    a80c:	4605      	mov	r5, r0
    a80e:	4608      	mov	r0, r1
    a810:	4611      	mov	r1, r2
    a812:	2200      	movs	r2, #0
    a814:	6022      	str	r2, [r4, #0]
    a816:	461a      	mov	r2, r3
    a818:	f7f7 f838 	bl	188c <_lseek>
    a81c:	1c43      	adds	r3, r0, #1
    a81e:	d102      	bne.n	a826 <_lseek_r+0x1e>
    a820:	6823      	ldr	r3, [r4, #0]
    a822:	b103      	cbz	r3, a826 <_lseek_r+0x1e>
    a824:	602b      	str	r3, [r5, #0]
    a826:	bd38      	pop	{r3, r4, r5, pc}
    a828:	200095d0 	.word	0x200095d0
    a82c:	00000000 	.word	0x00000000

0000a830 <memchr>:
    a830:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    a834:	2a10      	cmp	r2, #16
    a836:	db2b      	blt.n	a890 <memchr+0x60>
    a838:	f010 0f07 	tst.w	r0, #7
    a83c:	d008      	beq.n	a850 <memchr+0x20>
    a83e:	f810 3b01 	ldrb.w	r3, [r0], #1
    a842:	3a01      	subs	r2, #1
    a844:	428b      	cmp	r3, r1
    a846:	d02d      	beq.n	a8a4 <memchr+0x74>
    a848:	f010 0f07 	tst.w	r0, #7
    a84c:	b342      	cbz	r2, a8a0 <memchr+0x70>
    a84e:	d1f6      	bne.n	a83e <memchr+0xe>
    a850:	b4f0      	push	{r4, r5, r6, r7}
    a852:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
    a856:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
    a85a:	f022 0407 	bic.w	r4, r2, #7
    a85e:	f07f 0700 	mvns.w	r7, #0
    a862:	2300      	movs	r3, #0
    a864:	e8f0 5602 	ldrd	r5, r6, [r0], #8
    a868:	3c08      	subs	r4, #8
    a86a:	ea85 0501 	eor.w	r5, r5, r1
    a86e:	ea86 0601 	eor.w	r6, r6, r1
    a872:	fa85 f547 	uadd8	r5, r5, r7
    a876:	faa3 f587 	sel	r5, r3, r7
    a87a:	fa86 f647 	uadd8	r6, r6, r7
    a87e:	faa5 f687 	sel	r6, r5, r7
    a882:	b98e      	cbnz	r6, a8a8 <memchr+0x78>
    a884:	d1ee      	bne.n	a864 <memchr+0x34>
    a886:	bcf0      	pop	{r4, r5, r6, r7}
    a888:	f001 01ff 	and.w	r1, r1, #255	; 0xff
    a88c:	f002 0207 	and.w	r2, r2, #7
    a890:	b132      	cbz	r2, a8a0 <memchr+0x70>
    a892:	f810 3b01 	ldrb.w	r3, [r0], #1
    a896:	3a01      	subs	r2, #1
    a898:	ea83 0301 	eor.w	r3, r3, r1
    a89c:	b113      	cbz	r3, a8a4 <memchr+0x74>
    a89e:	d1f8      	bne.n	a892 <memchr+0x62>
    a8a0:	2000      	movs	r0, #0
    a8a2:	4770      	bx	lr
    a8a4:	3801      	subs	r0, #1
    a8a6:	4770      	bx	lr
    a8a8:	2d00      	cmp	r5, #0
    a8aa:	bf06      	itte	eq
    a8ac:	4635      	moveq	r5, r6
    a8ae:	3803      	subeq	r0, #3
    a8b0:	3807      	subne	r0, #7
    a8b2:	f015 0f01 	tst.w	r5, #1
    a8b6:	d107      	bne.n	a8c8 <memchr+0x98>
    a8b8:	3001      	adds	r0, #1
    a8ba:	f415 7f80 	tst.w	r5, #256	; 0x100
    a8be:	bf02      	ittt	eq
    a8c0:	3001      	addeq	r0, #1
    a8c2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
    a8c6:	3001      	addeq	r0, #1
    a8c8:	bcf0      	pop	{r4, r5, r6, r7}
    a8ca:	3801      	subs	r0, #1
    a8cc:	4770      	bx	lr
    a8ce:	bf00      	nop

0000a8d0 <__malloc_lock>:
    a8d0:	4770      	bx	lr

0000a8d2 <__malloc_unlock>:
    a8d2:	4770      	bx	lr

0000a8d4 <_read_r>:
    a8d4:	b538      	push	{r3, r4, r5, lr}
    a8d6:	4c07      	ldr	r4, [pc, #28]	; (a8f4 <_read_r+0x20>)
    a8d8:	4605      	mov	r5, r0
    a8da:	4608      	mov	r0, r1
    a8dc:	4611      	mov	r1, r2
    a8de:	2200      	movs	r2, #0
    a8e0:	6022      	str	r2, [r4, #0]
    a8e2:	461a      	mov	r2, r3
    a8e4:	f7fe fee4 	bl	96b0 <_read>
    a8e8:	1c43      	adds	r3, r0, #1
    a8ea:	d102      	bne.n	a8f2 <_read_r+0x1e>
    a8ec:	6823      	ldr	r3, [r4, #0]
    a8ee:	b103      	cbz	r3, a8f2 <_read_r+0x1e>
    a8f0:	602b      	str	r3, [r5, #0]
    a8f2:	bd38      	pop	{r3, r4, r5, pc}
    a8f4:	200095d0 	.word	0x200095d0
    a8f8:	652f2e2e 	.word	0x652f2e2e
    a8fc:	72656874 	.word	0x72656874
    a900:	5f74656e 	.word	0x5f74656e
    a904:	2f796870 	.word	0x2f796870
    a908:	65687465 	.word	0x65687465
    a90c:	74656e72 	.word	0x74656e72
    a910:	7968705f 	.word	0x7968705f
    a914:	0000632e 	.word	0x0000632e
    a918:	682f2e2e 	.word	0x682f2e2e
    a91c:	732f6c61 	.word	0x732f6c61
    a920:	682f6372 	.word	0x682f6372
    a924:	695f6c61 	.word	0x695f6c61
    a928:	00632e6f 	.word	0x00632e6f
    a92c:	682f2e2e 	.word	0x682f2e2e
    a930:	732f6c61 	.word	0x732f6c61
    a934:	682f6372 	.word	0x682f6372
    a938:	6d5f6c61 	.word	0x6d5f6c61
    a93c:	615f6361 	.word	0x615f6361
    a940:	636e7973 	.word	0x636e7973
    a944:	0000632e 	.word	0x0000632e
    a948:	682f2e2e 	.word	0x682f2e2e
    a94c:	732f6c61 	.word	0x732f6c61
    a950:	682f6372 	.word	0x682f6372
    a954:	745f6c61 	.word	0x745f6c61
    a958:	72656d69 	.word	0x72656d69
    a95c:	0000632e 	.word	0x0000632e
    a960:	682f2e2e 	.word	0x682f2e2e
    a964:	732f6c61 	.word	0x732f6c61
    a968:	682f6372 	.word	0x682f6372
    a96c:	755f6c61 	.word	0x755f6c61
    a970:	74726173 	.word	0x74726173
    a974:	7973615f 	.word	0x7973615f
    a978:	632e636e 	.word	0x632e636e
    a97c:	00000000 	.word	0x00000000
    a980:	682f2e2e 	.word	0x682f2e2e
    a984:	732f6c61 	.word	0x732f6c61
    a988:	682f6372 	.word	0x682f6372
    a98c:	755f6c61 	.word	0x755f6c61
    a990:	74726173 	.word	0x74726173
    a994:	6e79735f 	.word	0x6e79735f
    a998:	00632e63 	.word	0x00632e63
    a99c:	682f2e2e 	.word	0x682f2e2e
    a9a0:	752f6c61 	.word	0x752f6c61
    a9a4:	736c6974 	.word	0x736c6974
    a9a8:	6372732f 	.word	0x6372732f
    a9ac:	6974752f 	.word	0x6974752f
    a9b0:	6c5f736c 	.word	0x6c5f736c
    a9b4:	2e747369 	.word	0x2e747369
    a9b8:	00000063 	.word	0x00000063
    a9bc:	682f2e2e 	.word	0x682f2e2e
    a9c0:	752f6c61 	.word	0x752f6c61
    a9c4:	736c6974 	.word	0x736c6974
    a9c8:	6372732f 	.word	0x6372732f
    a9cc:	6974752f 	.word	0x6974752f
    a9d0:	725f736c 	.word	0x725f736c
    a9d4:	62676e69 	.word	0x62676e69
    a9d8:	65666675 	.word	0x65666675
    a9dc:	00632e72 	.word	0x00632e72
    a9e0:	682f2e2e 	.word	0x682f2e2e
    a9e4:	672f6c70 	.word	0x672f6c70
    a9e8:	2f63616d 	.word	0x2f63616d
    a9ec:	5f6c7068 	.word	0x5f6c7068
    a9f0:	63616d67 	.word	0x63616d67
    a9f4:	0000632e 	.word	0x0000632e
    a9f8:	40003000 	.word	0x40003000
    a9fc:	40003400 	.word	0x40003400
    aa00:	41012000 	.word	0x41012000
    aa04:	41014000 	.word	0x41014000
    aa08:	43000000 	.word	0x43000000
    aa0c:	43000400 	.word	0x43000400
    aa10:	43000800 	.word	0x43000800
    aa14:	43000c00 	.word	0x43000c00

0000aa18 <_usarts>:
    aa18:	00000001 40100004 00030000 00700002     .......@......p.
    aa28:	00001412 00000000 00000005 40100004     ...............@
    aa38:	00030000 00700002 00001412 00000000     ......p.........

0000aa48 <_i2cms>:
	...
    aa60:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
    aa70:	65735f6c 6d6f6372 0000632e 40003800     l_sercom.c...8.@
    aa80:	40003c00 4101a000 4101c000 42001400     .<.@...A...A...B
    aa90:	42001800 43001400 43001800              ...B...C...C

0000aa9c <_tcs>:
    aa9c:	006b0000 00000008 00000000 00000032     ..k.........2...
    aaac:	00000000 682f2e2e 742f6c70 70682f63     ....../hpl/tc/hp
    aabc:	63745f6c 0000632e 6c2f2e2e 2f706977     l_tc.c..../lwip/
    aacc:	7069776c 342e312d 732f302e 632f6372     lwip-1.4.0/src/c
    aadc:	2f65726f 70636864 0000632e 70636864     ore/dhcp.c..dhcp
    aaec:	74706f5f 5f6e6f69 69617274 3a72656c     _option_trailer:
    aafc:	63686420 3d212070 4c554e20 0000004c      dhcp != NULL...
    ab0c:	65737341 6f697472 2522206e 66202273     Assertion "%s" f
    ab1c:	656c6961 74612064 6e696c20 64252065     ailed at line %d
    ab2c:	206e6920 000a7325 70636864 6572635f      in %s..dhcp_cre
    ab3c:	5f657461 3a67736d 74656e20 21206669     ate_msg: netif !
    ab4c:	554e203d 00004c4c 70636864 6572635f     = NULL..dhcp_cre
    ab5c:	5f657461 3a67736d 63686420 3d212070     ate_msg: dhcp !=
    ab6c:	4c554e20 0000004c 70636864 6572635f      NULL...dhcp_cre
    ab7c:	5f657461 2867736d 63203a29 646c756f     ate_msg(): could
    ab8c:	746f6e20 6c6c6120 7461636f 62702065      not allocate pb
    ab9c:	00006675 6e617274 74636173 206e6f69     uf..transaction 
    abac:	78206469 25286469 000a2978 70636864     id xid(%x)..dhcp
    abbc:	6c65645f 5f657465 3a67736d 63686420     _delete_msg: dhc
    abcc:	3d212070 4c554e20 0000004c 70636864     p != NULL...dhcp
    abdc:	6265725f 28646e69 00000029 70636864     _rebind()...dhcp
    abec:	6265725f 3a646e69 42455220 49444e49     _rebind: REBINDI
    abfc:	0000474e 70636864 6265725f 3a646e69     NG..dhcp_rebind:
    ac0c:	756f6320 6e20646c 6120746f 636f6c6c      could not alloc
    ac1c:	20657461 50434844 71657220 74736575     ate DHCP request
    ac2c:	00000000 70636864 6265725f 28646e69     ....dhcp_rebind(
    ac3c:	73203a29 72207465 65757165 74207473     ): set request t
    ac4c:	6f656d69 25207475 6d207568 73636573     imeout %hu msecs
    ac5c:	0000000a 70636864 7369645f 65766f63     ....dhcp_discove
    ac6c:	00292872 70636864 7369645f 65766f63     r().dhcp_discove
    ac7c:	6d203a72 6e696b61 65722067 73657571     r: making reques
    ac8c:	00000074 70636864 7369645f 65766f63     t...dhcp_discove
    ac9c:	72203a72 6c6c6165 2928636f 00676e69     r: realloc()ing.
    acac:	70636864 7369645f 65766f63 73203a72     dhcp_discover: s
    acbc:	74646e65 4944286f 564f4353 202c5245     endto(DISCOVER, 
    accc:	415f5049 5f524444 414f5242 53414344     IP_ADDR_BROADCAS
    acdc:	44202c54 5f504348 56524553 505f5245     T, DHCP_SERVER_P
    acec:	2954524f 00000000 70636864 7369645f     ORT)....dhcp_dis
    acfc:	65766f63 64203a72 74656c65 28676e69     cover: deleting(
    ad0c:	676e6929 00000000 70636864 7369645f     )ing....dhcp_dis
    ad1c:	65766f63 53203a72 43454c45 474e4954     cover: SELECTING
    ad2c:	00000000 70636864 7369645f 65766f63     ....dhcp_discove
    ad3c:	63203a72 646c756f 746f6e20 6c6c6120     r: could not all
    ad4c:	7461636f 48442065 72205043 65757165     ocate DHCP reque
    ad5c:	00007473 70636864 7369645f 65766f63     st..dhcp_discove
    ad6c:	3a292872 74657320 71657220 74736575     r(): set request
    ad7c:	6d697420 74756f65 75682520 65736d20      timeout %hu mse
    ad8c:	000a7363 70636864 6c65735f 28746365     cs..dhcp_select(
    ad9c:	6974656e 70253d66 63252029 68256325     netif=%p) %c%c%h
    adac:	00000a75 70636864 6c65735f 3a746365     u...dhcp_select:
    adbc:	51455220 54534555 00474e49 70636864      REQUESTING.dhcp
    adcc:	6c65735f 3a746365 756f6320 6e20646c     _select: could n
    addc:	6120746f 636f6c6c 20657461 50434844     ot allocate DHCP
    adec:	71657220 74736575 00000000 70636864      request....dhcp
    adfc:	6c65735f 28746365 73203a29 72207465     _select(): set r
    ae0c:	65757165 74207473 6f656d69 25207475     equest timeout %
    ae1c:	6d207568 73636573 0000000a 70636864     hu msecs....dhcp
    ae2c:	6265725f 28746f6f 00000029 70636864     _reboot()...dhcp
    ae3c:	6265725f 3a746f6f 42455220 49544f4f     _reboot: REBOOTI
    ae4c:	0000474e 70636864 6265725f 3a746f6f     NG..dhcp_reboot:
    ae5c:	756f6320 6e20646c 6120746f 636f6c6c      could not alloc
    ae6c:	20657461 50434844 71657220 74736575     ate DHCP request
    ae7c:	00000000 70636864 6265725f 28746f6f     ....dhcp_reboot(
    ae8c:	73203a29 72207465 65757165 74207473     ): set request t
    ae9c:	6f656d69 25207475 6d207568 73636573     imeout %hu msecs
    aeac:	0000000a 70636864 6568635f 6e286b63     ....dhcp_check(n
    aebc:	66697465 2970253d 25632520 00000a63     etif=%p) %c%c...
    aecc:	70636864 6568635f 203a6b63 6c756f63     dhcp_check: coul
    aedc:	6f6e2064 65702074 726f6672 5241206d     d not perform AR
    aeec:	75712050 00797265 70636864 6568635f     P query.dhcp_che
    aefc:	29286b63 6573203a 65722074 73657571     ck(): set reques
    af0c:	69742074 756f656d 68252074 736d2075     t timeout %hu ms
    af1c:	0a736365 00000000 70636864 6e69625f     ecs.....dhcp_bin
    af2c:	6e203a64 66697465 203d2120 4c4c554e     d: netif != NULL
    af3c:	00000000 70636864 6e69625f 64203a64     ....dhcp_bind: d
    af4c:	20706368 4e203d21 004c4c55 70636864     hcp != NULL.dhcp
    af5c:	6e69625f 656e2864 3d666974 20297025     _bind(netif=%p) 
    af6c:	63256325 0a756825 00000000 70636864     %c%c%hu.....dhcp
    af7c:	6e69625f 3a292864 20317420 656e6572     _bind(): t1 rene
    af8c:	206c6177 656d6974 75252072 63657320     wal timer %u sec
    af9c:	00000a73 70636864 6e69625f 3a292864     s...dhcp_bind():
    afac:	74657320 71657220 74736575 6d697420      set request tim
    afbc:	74756f65 20752520 6365736d 00000a73     eout %u msecs...
    afcc:	70636864 6e69625f 3a292864 20327420     dhcp_bind(): t2 
    afdc:	69626572 7420646e 72656d69 20752520     rebind timer %u 
    afec:	73636573 0000000a 70636864 6e69625f     secs....dhcp_bin
    affc:	3a292864 3a504920 25783020 0a783830     d(): IP: 0x%08x.
    b00c:	00000000 70636864 6e69625f 3a292864     ....dhcp_bind():
    b01c:	3a4e5320 25783020 0a783830 00000000      SN: 0x%08x.....
    b02c:	70636864 6e69625f 3a292864 3a574720     dhcp_bind(): GW:
    b03c:	25783020 0a783830 00000000 70636864      0x%08x.....dhcp
    b04c:	6365725f 62702876 3d206675 29702520     _recv(pbuf = %p)
    b05c:	6f726620 4844206d 73205043 65767265      from DHCP serve
    b06c:	68252072 68252e75 68252e75 68252e75     r %hu.%hu.%hu.%h
    b07c:	6f702075 25207472 000a7568 66756270     u port %hu..pbuf
    b08c:	656c3e2d 203d206e 0a756825 00000000     ->len = %hu.....
    b09c:	66756270 6f743e2d 656c5f74 203d206e     pbuf->tot_len = 
    b0ac:	0a756825 00000000 50434844 70657220     %hu.....DHCP rep
    b0bc:	6d20796c 61737365 6f206567 62702072     ly message or pb
    b0cc:	74206675 73206f6f 74726f68 00000000     uf too short....
    b0dc:	20746f6e 48442061 72205043 796c7065     not a DHCP reply
    b0ec:	73656d20 65676173 7562202c 79742074      message, but ty
    b0fc:	25206570 000a7568 6974656e 683e2d66     pe %hu..netif->h
    b10c:	64646177 68255b72 3d3d5d75 68323025     waddr[%hu]==%02h
    b11c:	3d212078 70657220 6d5f796c 3e2d6773     x != reply_msg->
    b12c:	64616863 255b7264 3d5d7568 3230253d     chaddr[%hu]==%02
    b13c:	000a7868 6e617274 74636173 206e6f69     hx..transaction 
    b14c:	6d206469 616d7369 20686374 6c706572     id mismatch repl
    b15c:	736d5f79 783e2d67 25286469 3d212978     y_msg->xid(%x)!=
    b16c:	70636864 69783e2d 78252864 00000a29     dhcp->xid(%x)...
    b17c:	206e656c 34203d3d 00000000 206e656c     len == 4....len 
    b18c:	64203d3e 646f6365 656c5f65 0000006e     >= decode_len...
    b19c:	206e656c 20342025 30203d3d 00000000     len % 4 == 0....
    b1ac:	206e656c 31203d3d 00000000 70696b73     len == 1....skip
    b1bc:	676e6970 74706f20 206e6f69 20756825     ping option %hu 
    b1cc:	6f206e69 6f697470 000a736e 6f636564     in options..deco
    b1dc:	6c5f6564 25206e65 3d203420 0030203d     de_len % 4 == 0.
    b1ec:	61766e69 2064696c 6f636564 6c5f6564     invalid decode_l
    b1fc:	00006e65 7265766f 64616f6c 66206465     en..overloaded f
    b20c:	20656c69 6c656966 00000064 7265766f     ile field...over
    b21c:	64616f6c 73206465 656d616e 65696620     loaded sname fie
    b22c:	0000646c 7265766f 64616f6c 73206465     ld..overloaded s
    b23c:	656d616e 646e6120 6c696620 69662065     name and file fi
    b24c:	00646c65 61766e69 2064696c 7265766f     eld.invalid over
    b25c:	64616f6c 74706f20 3a6e6f69 0a642520     load option: %d.
    b26c:	00000000 626f7270 206d656c 6f666e75     ....problem unfo
    b27c:	6e69646c 48442067 6d205043 61737365     lding DHCP messa
    b28c:	2d206567 6f6f7420 6f687320 6f207472     ge - too short o
    b29c:	656d206e 79726f6d 0000003f 72616573     n memory?...sear
    b2ac:	6e696863 48442067 4f5f5043 4f495450     ching DHCP_OPTIO
    b2bc:	454d5f4e 47415353 59545f45 00004550     N_MESSAGE_TYPE..
    b2cc:	50434844 54504f5f 5f4e4f49 5353454d     DHCP_OPTION_MESS
    b2dc:	5f454741 45505954 74706f20 206e6f69     AGE_TYPE option 
    b2ec:	20746f6e 6e756f66 00000064 50434844     not found...DHCP
    b2fc:	4b43415f 63657220 65766965 00000064     _ACK received...
    b30c:	50434844 4b414e5f 63657220 65766965     DHCP_NAK receive
    b31c:	00000064 70636864 6e61685f 5f656c64     d...dhcp_handle_
    b32c:	286b616e 6974656e 70253d66 63252029     nak(netif=%p) %c
    b33c:	68256325 00000a75 50434844 46464f5f     %c%hu...DHCP_OFF
    b34c:	72205245 69656365 20646576 44206e69     ER received in D
    b35c:	5f504348 454c4553 4e495443 74732047     HCP_SELECTING st
    b36c:	00657461 70636864 6e61685f 5f656c64     ate.dhcp_handle_
    b37c:	6566666f 656e2872 3d666974 20297025     offer(netif=%p) 
    b38c:	63256325 0a756825 00000000 70636864     %c%c%hu.....dhcp
    b39c:	6e61685f 5f656c64 6566666f 3a292872     _handle_offer():
    b3ac:	72657320 20726576 30257830 000a7838      server 0x%08x..
    b3bc:	70636864 6e61685f 5f656c64 6566666f     dhcp_handle_offe
    b3cc:	3a292872 66666f20 66207265 3020726f     r(): offer for 0
    b3dc:	38302578 00000a78 70636864 6e61685f     x%08x...dhcp_han
    b3ec:	5f656c64 6566666f 656e2872 3d666974     dle_offer(netif=
    b3fc:	20297025 20646964 20746f6e 20746567     %p) did not get 
    b40c:	76726573 49207265 000a2144 6974656e     server ID!..neti
    b41c:	3d212066 4c554e20 0000004c 70636864     f != NULL...dhcp
    b42c:	666e695f 286d726f 63203a29 646c756f     _inform(): could
    b43c:	746f6e20 74626f20 206e6961 00626370      not obtain pcb.
    b44c:	70636864 666e695f 286d726f 63203a29     dhcp_inform(): c
    b45c:	74616572 6e206465 75207765 70207064     reated new udp p
    b46c:	00006263 70636864 666e695f 3a6d726f     cb..dhcp_inform:
    b47c:	464e4920 494d524f 0000474e 70636864      INFORMING..dhcp
    b48c:	666e695f 3a6d726f 756f6320 6e20646c     _inform: could n
    b49c:	6120746f 636f6c6c 20657461 50434844     ot allocate DHCP
    b4ac:	71657220 74736575 00000000 70636864      request....dhcp
    b4bc:	7072615f 7065725f 2928796c 00000000     _arp_reply()....
    b4cc:	70636864 7072615f 7065725f 2928796c     dhcp_arp_reply()
    b4dc:	4843203a 494b4345 202c474e 20707261     : CHECKING, arp 
    b4ec:	6c706572 6f662079 78302072 78383025     reply for 0x%08x
    b4fc:	0000000a 70636864 7072615f 7065725f     ....dhcp_arp_rep
    b50c:	2928796c 7261203a 65722070 20796c70     ly(): arp reply 
    b51c:	6374616d 20646568 68746977 66666f20     matched with off
    b52c:	64657265 64646120 73736572 6564202c     ered address, de
    b53c:	6e696c63 00676e69 70636864 6365645f     clining.dhcp_dec
    b54c:	656e696c 00002928 70636864 6365645f     line()..dhcp_dec
    b55c:	656e696c 4142203a 4e494b43 464f2047     line: BACKING OF
    b56c:	00000046 70636864 6365645f 656e696c     F...dhcp_decline
    b57c:	6f63203a 20646c75 20746f6e 6f6c6c61     : could not allo
    b58c:	65746163 43484420 65722050 73657571     cate DHCP reques
    b59c:	00000074 70636864 6365645f 656e696c     t...dhcp_decline
    b5ac:	203a2928 20746573 75716572 20747365     (): set request 
    b5bc:	656d6974 2074756f 20756825 6365736d     timeout %hu msec
    b5cc:	00000a73 70636864 6e65725f 29287765     s...dhcp_renew()
    b5dc:	00000000 70636864 6e65725f 203a7765     ....dhcp_renew: 
    b5ec:	454e4552 474e4957 00000000 70636864     RENEWING....dhcp
    b5fc:	6e65725f 203a7765 6c756f63 6f6e2064     _renew: could no
    b60c:	6c612074 61636f6c 44206574 20504348     t allocate DHCP 
    b61c:	75716572 00747365 70636864 6e65725f     request.dhcp_ren
    b62c:	29287765 6573203a 65722074 73657571     ew(): set reques
    b63c:	69742074 756f656d 68252074 736d2075     t timeout %hu ms
    b64c:	0a736365 00000000 70636864 616f635f     ecs.....dhcp_coa
    b65c:	5f657372 28726d74 00000029 70636864     rse_tmr()...dhcp
    b66c:	616f635f 5f657372 28726d74 74203a29     _coarse_tmr(): t
    b67c:	69742032 756f656d 00000074 70636864     2 timeout...dhcp
    b68c:	5f32745f 656d6974 2874756f 00000029     _t2_timeout()...
    b69c:	70636864 5f32745f 656d6974 2874756f     dhcp_t2_timeout(
    b6ac:	6d203a29 20747375 69626572 0000646e     ): must rebind..
    b6bc:	70636864 616f635f 5f657372 28726d74     dhcp_coarse_tmr(
    b6cc:	74203a29 69742031 756f656d 00000074     ): t1 timeout...
    b6dc:	70636864 5f31745f 656d6974 2874756f     dhcp_t1_timeout(
    b6ec:	00000029 70636864 5f31745f 656d6974     )...dhcp_t1_time
    b6fc:	2874756f 6d203a29 20747375 656e6572     out(): must rene
    b70c:	00000077 70636864 6c65725f 65736165     w...dhcp_release
    b71c:	00002928 70636864 6c65725f 65736165     ()..dhcp_release
    b72c:	4552203a 5341454c 202c4445 50434844     : RELEASED, DHCP
    b73c:	46464f5f 00000000 70636864 6c65725f     _OFF....dhcp_rel
    b74c:	65736165 6f63203a 20646c75 20746f6e     ease: could not 
    b75c:	6f6c6c61 65746163 43484420 65722050     allocate DHCP re
    b76c:	73657571 00000074 70636864 6c65725f     quest...dhcp_rel
    b77c:	65736165 203a2928 20746573 75716572     ease(): set requ
    b78c:	20747365 656d6974 2074756f 20756825     est timeout %hu 
    b79c:	6365736d 00000a73 70636864 6e69665f     msecs...dhcp_fin
    b7ac:	6d745f65 3a292872 71657220 74736575     e_tmr(): request
    b7bc:	6d697420 74756f65 00000000 70636864      timeout....dhcp
    b7cc:	6d69745f 74756f65 00002928 70636864     _timeout()..dhcp
    b7dc:	6d69745f 74756f65 203a2928 74736572     _timeout(): rest
    b7ec:	69747261 6420676e 6f637369 79726576     arting discovery
    b7fc:	00000000 70636864 6d69745f 74756f65     ....dhcp_timeout
    b80c:	203a2928 55514552 49545345 202c474e     (): REQUESTING, 
    b81c:	50434844 71657220 74736575 6d697420     DHCP request tim
    b82c:	6f206465 00007475 70636864 6d69745f     ed out..dhcp_tim
    b83c:	74756f65 203a2928 55514552 49545345     eout(): REQUESTI
    b84c:	202c474e 656c6572 6e697361 72202c67     NG, releasing, r
    b85c:	61747365 6e697472 00000067 70636864     estarting...dhcp
    b86c:	6d69745f 74756f65 203a2928 43454843     _timeout(): CHEC
    b87c:	474e494b 5241202c 65722050 73657571     KING, ARP reques
    b88c:	69742074 2064656d 0074756f 70636864     t timed out.dhcp
    b89c:	6d69745f 74756f65 203a2928 454e4552     _timeout(): RENE
    b8ac:	474e4957 4844202c 72205043 65757165     WING, DHCP reque
    b8bc:	74207473 64656d69 74756f20 00000000     st timed out....
    b8cc:	70636864 6d69745f 74756f65 203a2928     dhcp_timeout(): 
    b8dc:	49424552 4e49444e 44202c47 20504348     REBINDING, DHCP 
    b8ec:	75716572 20747365 656d6974 756f2064     request timed ou
    b8fc:	00000074 70636864 6d69745f 74756f65     t...dhcp_timeout
    b90c:	203a2928 454c4552 4e495341 44202c47     (): RELEASING, D
    b91c:	4f435349 49524556 0000474e 70636864     ISCOVERING..dhcp
    b92c:	6f74735f 6e203a70 66697465 203d2120     _stop: netif != 
    b93c:	4c4c554e 00000000 70636864 6f74735f     NULL....dhcp_sto
    b94c:	00292870 70636864 6174735f 6e287472     p().dhcp_start(n
    b95c:	66697465 2970253d 25632520 75682563     etif=%p) %c%c%hu
    b96c:	0000000a 70636864 6174735f 29287472     ....dhcp_start()
    b97c:	6f4e203a 48544520 20505241 6974656e     : No ETHARP neti
    b98c:	00000066 70636864 6174735f 29287472     f...dhcp_start()
    b99c:	6143203a 746f6e6e 65737520 69687420     : Cannot use thi
    b9ac:	656e2073 20666974 68746977 43484420     s netif with DHC
    b9bc:	4d203a50 69205554 6f742073 6d73206f     P: MTU is too sm
    b9cc:	006c6c61 70636864 6174735f 29287472     all.dhcp_start()
    b9dc:	7473203a 69747261 6e20676e 44207765     : starting new D
    b9ec:	20504348 65696c63 0000746e 70636864     HCP client..dhcp
    b9fc:	6174735f 29287472 6f63203a 20646c75     _start(): could 
    ba0c:	20746f6e 6f6c6c61 65746163 63686420     not allocate dhc
    ba1c:	00000070 70636864 6174735f 29287472     p...dhcp_start()
    ba2c:	6c61203a 61636f6c 20646574 70636864     : allocated dhcp
    ba3c:	00000000 70636864 6174735f 29287472     ....dhcp_start()
    ba4c:	6572203a 72617473 676e6974 43484420     : restarting DHC
    ba5c:	6f632050 6769666e 74617275 006e6f69     P configuration.
    ba6c:	70636864 6174735f 29287472 6f63203a     dhcp_start(): co
    ba7c:	20646c75 20746f6e 6174626f 70206e69     uld not obtain p
    ba8c:	00006263 70636864 6174735f 29287472     cb..dhcp_start()
    ba9c:	7473203a 69747261 4420676e 20504348     : starting DHCP 
    baac:	666e6f63 72756769 6f697461 0000006e     configuration...

0000babc <ip_addr_broadcast>:
    babc:	ffffffff                                ....

0000bac0 <ip_addr_any>:
    bac0:	00000000                                ....

0000bac4 <memp_num>:
    bac4:	00040004 00080005 00050010 0005000f     ................
    bad4:	00100010                                ....

0000bad8 <memp_sizes>:
    bad8:	0020001c 001c0098 00200014 00100018     .. ....... .....
    bae8:	05fc0010 6c2f2e2e 2f706977 7069776c     ....../lwip/lwip
    baf8:	342e312d 732f302e 632f6372 2f65726f     -1.4.0/src/core/
    bb08:	706d656d 0000632e 706d656d 6c616d5f     memp.c..memp_mal
    bb18:	3a636f6c 70797420 203c2065 504d454d     loc: type < MEMP
    bb28:	58414d5f 00000000 6c2f2e2e 2f706977     _MAX....../lwip/
    bb38:	7069776c 342e312d 732f302e 632f6372     lwip-1.4.0/src/c
    bb48:	2f65726f 66756270 0000632e 72636e69     ore/pbuf.c..incr
    bb58:	6e656d65 616d5f74 74696e67 20656475     ement_magnitude 
    bb68:	70203d3c 656c3e2d 0000006e 21206828     <= p->len...(h !
    bb78:	554e203d 20294c4c 28202626 3d212074     = NULL) && (t !=
    bb88:	4c554e20 2820294c 676f7270 6d6d6172      NULL) (programm
    bb98:	76207265 616c6f69 20736574 29495041     er violates API)
    bba8:	00000000 66756270 706f635f 74203a79     ....pbuf_copy: t
    bbb8:	65677261 6f6e2074 69622074 6e652067     arget not big en
    bbc8:	6867756f 206f7420 646c6f68 756f7320     ough to hold sou
    bbd8:	00656372 6f745f70 203d2120 4c4c554e     rce.p_to != NULL
    bbe8:	00000000 66756270 706f635f 20292879     ....pbuf_copy() 
    bbf8:	73656f64 746f6e20 6c6c6120 7020776f     does not allow p
    bc08:	656b6361 75712074 73657565 00000a21     acket queues!...
    bc18:	66756270 706f635f 61705f79 61697472     pbuf_copy_partia
    bc28:	69203a6c 6c61766e 62206469 00006675     l: invalid buf..
    bc38:	66756270 706f635f 61705f79 61697472     pbuf_copy_partia
    bc48:	69203a6c 6c61766e 64206469 70617461     l: invalid datap
    bc58:	00007274 66756270 6b61745f 69203a65     tr..pbuf_take: i
    bc68:	6c61766e 62206469 00006675 66756270     nvalid buf..pbuf
    bc78:	6b61745f 69203a65 6c61766e 64206469     _take: invalid d
    bc88:	70617461 00007274                       ataptr..

0000bc90 <tcp_pcb_lists>:
    bc90:	200092e8 200092f0 200092e0 200092f4     ... ... ... ... 

0000bca0 <tcp_persist_backoff>:
    bca0:	180c0603 00786030                       ....0`x.

0000bca8 <tcp_backoff>:
    bca8:	04030201 07070605 07070707 00000007     ................

0000bcb8 <tcp_state_str>:
    bcb8:	0000bd84 0000bd8c 0000bd94 0000bda0     ................
    bcc8:	0000bdac 0000bdb8 0000bdc4 0000bdd0     ................
    bcd8:	0000bddc 0000bde4 0000bdf0 6c2f2e2e     ............../l
    bce8:	2f706977 7069776c 342e312d 732f302e     wip/lwip-1.4.0/s
    bcf8:	632f6372 2f65726f 2e706374 00000063     rc/core/tcp.c...
    bd08:	5f706374 646e6962 6163203a 6e6f206e     tcp_bind: can on
    bd18:	6220796c 20646e69 73206e69 65746174     ly bind in state
    bd28:	4f4c4320 00444553 5f706374 7473696c      CLOSED.tcp_list
    bd38:	203a6e65 20626370 65726c61 20796461     en: pcb already 
    bd48:	6e6e6f63 65746365 00000064 5f706374     connected...tcp_
    bd58:	6e6e6f63 3a746365 6e616320 6c6e6f20     connect: can onl
    bd68:	6f632079 63656e6e 72662074 73206d6f     y connect from s
    bd78:	65746174 4f4c4320 00444553 534f4c43     tate CLOSED.CLOS
    bd88:	00004445 5453494c 00004e45 5f4e5953     ED..LISTEN..SYN_
    bd98:	544e4553 00000000 5f4e5953 44564352     SENT....SYN_RCVD
    bda8:	00000000 41545345 53494c42 00444548     ....ESTABLISHED.
    bdb8:	5f4e4946 54494157 0000315f 5f4e4946     FIN_WAIT_1..FIN_
    bdc8:	54494157 0000325f 534f4c43 41575f45     WAIT_2..CLOSE_WA
    bdd8:	00005449 534f4c43 00474e49 5453414c     IT..CLOSING.LAST
    bde8:	4b43415f 00000000 454d4954 4941575f     _ACK....TIME_WAI
    bdf8:	00000054                                T...

0000bdfc <ethzero>:
	...

0000be04 <ethbroadcast>:
    be04:	ffffffff 0000ffff 6c2f2e2e 2f706977     ........../lwip/
    be14:	7069776c 342e312d 732f302e 6e2f6372     lwip-1.4.0/src/n
    be24:	66697465 6874652f 2e707261 00000063     etif/etharp.c...
    be34:	43484428 00002950 41545328 29434954     (DHCP)..(STATIC)
    be44:	00000000 65746e49 63616672 70552065     ....Interface Up
    be54:	3a732520 0000000a 65746e49 63616672      %s:....Interfac
    be64:	6f442065 002e6e77 6b6e694c 2e705520     e Down..Link Up.
    be74:	00000000 74736552 69747261 4420676e     ....Restarting D
    be84:	00504348 6b6e694c 776f4420 00002e6e     HCP.Link Down...
    be94:	2e2f2e2e 69616d2f 00632e6e 25203a57     .././main.c.W: %
    bea4:	0a573a73 00000000 00206425 6f746f4d     s:W.....%d .Moto
    beb4:	00000072 00007325 2a2a2a2a 2a2a2a2a     r...%s..********
    bec4:	2a2a2a2a 2a2a2a2a 2a2a2a2a 2a2a2a2a     ****************
    bed4:	000a2a2a 4d687445 726f746f 6d724173     **..EthMotorsArm
    bee4:	5652445f 30303838 7665725f 000a3230     _DRV8800_rev02..
    bef4:	65480a0d 206f6c6c 454d5441 6f57204c     ..Hello ATMEL Wo
    bf04:	21646c72 0000000d 65687445 74656e72     rld!....Ethernet
    bf14:	6e6f4320 7463656e 206e6f69 61747365      Connection esta
    bf24:	73696c62 00646568 50434844 61745320     blished.DHCP Sta
    bf34:	64657472 0000000d 415f5049 20524444     rted....IP_ADDR 
    bf44:	3a202020 0d732520 0000000a 5f54454e        : %s.....NET_
    bf54:	4b53414d 3a202020 0d732520 0000000a     MASK   : %s.....
    bf64:	45544147 5f594157 3a205049 0d732520     GATEWAY_IP : %s.
    bf74:	0000000a                                ....

0000bf78 <_global_impure_ptr>:
    bf78:	20000014                                ... 

0000bf7c <__sf_fake_stderr>:
	...

0000bf9c <__sf_fake_stdin>:
	...

0000bfbc <__sf_fake_stdout>:
	...
    bfdc:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
    bfec:	32313000 36353433 41393837 45444342     .0123456789ABCDE
    bffc:	31300046 35343332 39383736 64636261     F.0123456789abcd
    c00c:	00006665                                ef..

0000c010 <_init>:
    c010:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c012:	bf00      	nop
    c014:	bcf8      	pop	{r3, r4, r5, r6, r7}
    c016:	bc08      	pop	{r3}
    c018:	469e      	mov	lr, r3
    c01a:	4770      	bx	lr

0000c01c <__init_array_start>:
    c01c:	00000289 	.word	0x00000289

0000c020 <_fini>:
    c020:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c022:	bf00      	nop
    c024:	bcf8      	pop	{r3, r4, r5, r6, r7}
    c026:	bc08      	pop	{r3}
    c028:	469e      	mov	lr, r3
    c02a:	4770      	bx	lr

0000c02c <__fini_array_start>:
    c02c:	00000265 	.word	0x00000265
